module Change where
{--
https://stepik.org/lesson/8328/step/9?unit=1476

Пусть есть список положительных достоинств монет `coins`
отсортированный по возрастанию

Воспользовавшись механизмом генераторов списков
напишите функцию `change`

которая разбивает переданную ей положительную сумму денег 
на монеты из списка `coins`
всеми возможными способами

Примечание. Порядок монет в каждом разбиении имеет значение, 
то есть наборы `[2,2,3]` и `[2,3,2]` — различаются.
Список `coins` определять не надо

Например, если `{coins :: (Ord a, Num a) => [a]; coins = [2, 3, 7]}`
GHCi> change 7
[[2,2,3],[2,3,2],[3,2,2],[7]]

comments:

Все числа в coins различны.
Они целые (то есть не надо проверять равенство нулю каким-нибудь эпсилоном).
Они положительны (то есть ноль не корректное значение).
Порядок вывода списков неважен (либо лексикографический).

Если сдачу выдать невозможно, то вариантов разбиения — ноль, то есть ответ — пустой список

Список из одного пустого списка соответствует случаю, 
когда нужная сумма набирается пустым множеством монет, 
а сумма по пустому списку, как известно, равна нулю

поскольку это единственный разумный ответ, при правильном решении он, конечно же, получается даже если ни о чём не задумываться

решение в две строчки
Есть решения действительно в две строчки, но они какие-то странные. Нормальное в три, конечно.
решение в две строки неправильно определяет функцию на некоторых значениях, а потом добавляет, проверку некоторого условия, не потому что она концептуально нужна, а только чтобы пофиксить этот баг.

однозначная правда жизни: число ноль на слагаемые из любого набора раскладывается одним способом
при таком подходе очень легко написать простое решение этой задачи

удалось сделать как решение чисто на list comprehension без единого (кроме рекурсивного) вызова функций, 
так и заменить этот list comprehension на комбинацию concatMap, map и filter

На каждом шаге рассматривайте текущую сумму и смотрите, что получится, если в размене этой суммы будет участвовать каждая из монет. 
Там есть варианты: монетка слишком большая, монетка строго равна сумме, монетка меньше суммы и в этом случае 
спускаемся дальше и смотрим, можно ли разменять или нет. Если всё делать правильно, решение очень простое и прямолинейное

В любом разбиении суммы сдачи на заданные монетки первая монетка будет какой-то из того самого списка, 
а с остатком суммы можно как-нибудь разобраться

Почувствуйте разницу:
*Main> [ x:y | x <- [1,2,3], y <- [] ]
[]
*Main> [ x:y | x <- [1,2,3], y <- [[]] ]
[[1],[2],[3]]

change 1 = [] -- если нет монетки 1, если монетка есть, ответ [[1]]
change 0 = [[]] -- ибо `sum [] == 0`
подробнее:
сумма значений в списке должна дать заданную сумму;
сумма пустого списка дает 0 (такая реализация ф. sum);
чтобы получить искомую сумму = 1, надо либо список [1] если есть монетка 1, либо отсутствие списка - как отсутствие решения. 

change 1 = [[1] | 1 `elem` coins] -- [] or [[1]]
change 7 = [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]] -- test

import Debug.Trace -- use traceShow
--}

-- header

coins :: (Ord a, Num a) => [a]
coins = [2, 3, 7]

-- solution, coins are given, list sorted asc. `coins :: (Ord a, Num a) => [a]`
change :: (Ord a, Num a) => a -> [[a]]
change 0 = [[]] -- sum [] == 0
change n
    | n < head coins = [] -- have no solutions, coins are sorted asc. and head is a min coins
    | otherwise = [cs | c <- coins, c <= n, cs <- partialSolution n c]
    where
        -- test case: n == 7 && c == 2 = [[2, 2, 3], [2, 3, 2]] -- given coins = [2, 3, 7]
        partialSolution :: (Ord a, Num a) => a -> a -> [[a]]
        partialSolution currSum currCoin
            | currSum == currCoin = [[currCoin]]
            | currSum < currCoin = []
            | otherwise = [
                currCoin : rest |
                c <- coins
                , c <= restSum
                , rest <- partialSolution restSum c
                , sum rest <= restSum
            ] where 
                restSum = currSum - currCoin
