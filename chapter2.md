# FP Haskell, chapter 2, basics

[Функциональное программирование на языке Haskell / Денис Москвин / stepik](https://stepik.org/course/75/syllabus?next=)

## chapter 2.1, параметрический полиморфизм

https://stepik.org/lesson/8417/step/1?unit=1555

### 2.1.2 полиморфизм функций

Функция полиморфна: если может быть применена к значениям разных типов.
Сложение: полиморфный оператор, может складывать как целые, так и дробные числа.

Два типа полиморфизма функций: параметрический, специальный.
Параметричекий: код функции одинаков для всех подходящих типов.
Специальный: для каждого типа внутри своя реализация.

Оператор сложения: специальный полиморфизм, реализация сложения для разных типов разная.

Примеры параметрически полиморфных функций
```hs
ghci> let id x = x

-- используется "переменная типа": `p`, с маленькой буквы. Хотя типы всегда с большой.
-- означает "любой тип".
ghci> :t id
id :: p -> p

ghci> :t id id 4
id id 4 :: Num t => t

ghci> :t (id id)
(id id) :: p -> p
-- многословное обьяснение: как p -> p, где p = p -> p, т.е. p -> p -> p -> p
-- превратился в p -> p
-- "при применении функции арность уменьшается на единицу" ...
-- (p -> p) -> (p -> p)
-- ~> (p -> p) -> p -> p
-- ~> p -> p
ghci> :t id id 
id id :: p -> p

-- п.п. функция двух аргументов
let k x y = -- мы ничего не знаме про типы аргументов и можем только комбинировать их по разному в выходе:
    x -- или
    y -- или ...
    (x, y)
    (y, x)
    x y
    y x
-- I wonder, term "combinators" have to do smth. with it?
-- комбинаторы: функции без свободных переменных.

ghci> let k x y = x
ghci> :t k
k :: p1 -> p2 -> p1 -- всегда первый параметр, любого типа (переменная типа)

-- стандартная функ. позволяет создавать функции возвращающие заданную константу
ghci> :t const
const :: a -> b -> a

ghci> let constTrue = const True
ghci> :t constTrue 
constTrue :: b -> Bool
ghci> constTrue "foo"
True

-- функция возвращает "любой" тип, поэтому может проходить проверку типов в любом выражении
ghci> :t undefined
undefined :: GHC.Stack.Types.HasCallStack => a
-- константа undefined населяет любой допустимый тип
-- обладает наивысшей степенью полиморфизма
```
repl

```hs
-- Напишите функцию трех аргументов `getSecondFrom`,
-- полиморфную по каждому из них,
-- которая полностью игнорирует первый и третий аргумент, а возвращает второй.
-- Укажите ее тип.

GHCi> getSecondFrom True 'x' "Hello"
'x'
GHCi> getSecondFrom 'x' 42 True 
42

getSecondFrom :: a -> b -> c -> b
getSecondFrom a b c = b

-- Сколько разных всегда завершающихся функций с типом `a -> a -> b -> a -> a` можно реализовать?
-- Две функции одинаковой арности считаются разными,
-- если существует набор значений их аргументов, на котором они дают разные результирующие значения.
3
-- почему? Функция 4 аргументов, три из них а. Возвращает а.
-- Сколько вариантов вернуть а? 3
-- речь про типы, конкретные значения могут быть и одинаковые.
```
test

### 2.1.5 полиморфизм функций

https://stepik.org/lesson/8417/step/5?unit=1555

Указывая конкретный тип мы ограничиваем полиморфизм
```hs
mono :: Char -> Char
mono x = x -- мономорфная функ. только один тип, в отличие от полиморфной `id` с такой же реализацией

-- частично ограниченнй полиморфизм
semiMono :: Char -> a -> Char -- полиморфна по второму аргументу, мономорфна по первому
semiMono x y =x

-- при выводе типов Хаскел выводит наиболее общий тип из возможных.
ghci> semiMono x y =x
ghci> :t semiMono 
semiMono :: p1 -> p2 -> p1

```
repl

Аппликативная структура в правой части дает набор уравнений.
Любое применение `x -> y` говорит о том, что справа тип любой а слева стрелочный.

> A Hindley–Milner (HM) type system is a classical type system for the lambda calculus with parametric polymorphism. It is also known as Damas–Milner or Damas–Hindley–Milner.
https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
https://web.cecs.pdx.edu/~mpj/thih/

### 2.1.6

https://stepik.org/lesson/8417/step/6?unit=1555
