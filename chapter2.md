# FP Haskell, chapter 2, basics

[Функциональное программирование на языке Haskell / Денис Москвин / stepik](https://stepik.org/course/75/syllabus?next=)

## chapter 2.1, параметрический полиморфизм

https://stepik.org/lesson/8417/step/1?unit=1555

### 2.1.2 полиморфизм функций

Функция полиморфна: если может быть применена к значениям разных типов.
Сложение: полиморфный оператор, может складывать как целые, так и дробные числа.

Два типа полиморфизма функций: параметрический, специальный.
Параметричекий: код функции одинаков для всех подходящих типов.
Специальный: для каждого типа внутри своя реализация.

Оператор сложения: специальный полиморфизм, реализация сложения для разных типов разная.

Примеры параметрически полиморфных функций
```hs
ghci> let id x = x

-- используется "переменная типа": `p`, с маленькой буквы. Хотя типы всегда с большой.
-- означает "любой тип".
ghci> :t id
id :: p -> p

ghci> :t id id 4
id id 4 :: Num t => t

ghci> :t (id id)
(id id) :: p -> p
-- многословное обьяснение: как p -> p, где p = p -> p, т.е. p -> p -> p -> p
-- превратился в p -> p
-- "при применении функции арность уменьшается на единицу" ...
-- (p -> p) -> (p -> p)
-- ~> (p -> p) -> p -> p
-- ~> p -> p
ghci> :t id id 
id id :: p -> p

-- п.п. функция двух аргументов
let k x y = -- мы ничего не знаме про типы аргументов и можем только комбинировать их по разному в выходе:
    x -- или
    y -- или ...
    (x, y)
    (y, x)
    x y
    y x
-- I wonder, term "combinators" have to do smth. with it?
-- комбинаторы: функции без свободных переменных.

ghci> let k x y = x
ghci> :t k
k :: p1 -> p2 -> p1 -- всегда первый параметр, любого типа (переменная типа)

-- стандартная функ. позволяет создавать функции возвращающие заданную константу
ghci> :t const
const :: a -> b -> a

ghci> let constTrue = const True
ghci> :t constTrue 
constTrue :: b -> Bool
ghci> constTrue "foo"
True

-- функция возвращает "любой" тип, поэтому может проходить проверку типов в любом выражении
ghci> :t undefined
undefined :: GHC.Stack.Types.HasCallStack => a
-- константа undefined населяет любой допустимый тип
-- обладает наивысшей степенью полиморфизма
```
repl

```hs
-- Напишите функцию трех аргументов `getSecondFrom`,
-- полиморфную по каждому из них,
-- которая полностью игнорирует первый и третий аргумент, а возвращает второй.
-- Укажите ее тип.

GHCi> getSecondFrom True 'x' "Hello"
'x'
GHCi> getSecondFrom 'x' 42 True 
42

getSecondFrom :: a -> b -> c -> b
getSecondFrom a b c = b

-- Сколько разных всегда завершающихся функций с типом `a -> a -> b -> a -> a` можно реализовать?
-- Две функции одинаковой арности считаются разными,
-- если существует набор значений их аргументов, на котором они дают разные результирующие значения.
3
-- почему? Функция 4 аргументов, три из них а. Возвращает а.
-- Сколько вариантов вернуть а? 3
-- речь про типы, конкретные значения могут быть и одинаковые.
```
test

### 2.1.5 полиморфизм функций

https://stepik.org/lesson/8417/step/5?unit=1555

Указывая конкретный тип мы ограничиваем полиморфизм
```hs
-- мономорфная функ. - только один тип, в отличие от полиморфной `id` с такой же реализацией
mono :: Char -> Char
mono x = x

-- частично ограниченнй полиморфизм
-- функ. полиморфна по второму аргументу, мономорфна по первому
semiMono :: Char -> a -> Char
semiMono x y = x

-- при выводе типов Хаскел выводит наиболее общий тип из возможных.
ghci> semiMono x y = x
ghci> :t semiMono 
semiMono :: p1 -> p2 -> p1 -- переменные типа: любые типы
```
repl

Аппликативная структура в правой части (определения функ.) дает набор уравнений.
Любое применение `x -> y` говорит о том, что справа тип любой а слева стрелочный.

> A Hindley–Milner (HM) type system is a classical type system for the lambda calculus with parametric polymorphism.
It is also known as Damas–Milner or Damas–Hindley–Milner.
https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
https://web.cecs.pdx.edu/~mpj/thih/

### 2.1.6 функции высших порядков

https://stepik.org/lesson/8417/step/6?unit=1555

Функ. высшего порядка: аргумент это функция.
Например: оператор `$`
```hs
-- принимает функцию одного аргумента, возвращает функ. одного аргумента
-- читается как: оператор это функция двух аргументов (две стрелочки в определении),
-- под капотом применяет первый аргумент ко второму
-- можно прочитать так: принимает функ. одного аргумента, возвращает функ. одного аргумента
ghci> :i ($)
($) :: (a -> b) -> a -> b       -- Defined in ‘GHC.Base’
infixr 0 $

-- другой интересный пример функ. высшего порядка, требует совпадения типа у входа и выхода функц. f
-- ибо f применяется к результату своего применения
ghci> apply2 f x = f $ f x
ghci> :t apply2
-- принимает функ. одного аргумента, возвращает функ. одного аргумента (полученная ф. реализует двойной апплай)
-- т.е. мы модифицировали поведение принятой ф.
apply2 :: (a -> a) -> a -> a
ghci>
-- что в оригинале было как
ghci> apply2 f x = f (f x)
ghci> :t apply2
apply2 :: (t -> t) -> t -> t

-- правое сечение оператора +, дает функ. `+ 5`
-- двойное применение `+5` к 22 = 32
ghci> apply2 (+ 5) 22
32

-- аналогично с правым сеченим оператора конкатенации
ghci> apply2 (++ "AB") "CD"
"CDABAB"

-- полезная функ. высшего порядка: `flip`
-- переворачивает порядок параметров в применении функ. `f`
flip f x y = f y x

-- пример: перевернуть порядок операндов в делении (оператор вызван как функ., в префиксном виде)
ghci> flip (/) 4 2
0.5
ghci> (/) 4 2
2.0

ghci> flip const 5 True
True
ghci> const 5 True
5

-- принимает функ. двух аргументов, возвращает функцию (двух аргументов в перевернутом порядке)
ghci> :t flip
flip :: (a -> b -> c) -> b -> a -> c

-- получена ф. которая принимает два аргумента, возвращает второй
ghci> :t flip const
flip const :: b -> c -> c
```
repl

```hs
{-- 
В модуле `Data.Function` определена полезная функция высшего порядка
Она принимает четыре аргумента: бинарный оператор с однотипными аргументами b,
функцию f :: a -> b,
и два значения типа a.

Функция on применяет f дважды к двум значениям типа a и передает результат в бинарный оператор.
--} 

-- op: функ. двух аргументов типа б, возвращает тип ц.
-- f: функ. одного аргумента типа а, возвращает тип б.
-- х и у: два аргумента типа а.
-- на выходе значение типа ц.
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
on op f x y = f x `op` f y
-- f(x) op f(y) -- выполняет оператор на результате применения ф. к двум значениям х, у
-- возвращает результат выполнения оператора `op`, type c.
-- e.g. op: (+); f: charToDigit; (x, y): ('1', '3') = charToDigit '1' + charToDigit '3' = 4
-- т.е. операция над двумя преобразованными значениями

-- Используя on можно, например, записать функцию суммирования квадратов аргументов так:
sumSquares = (+) `on` (^2) -- выполнить + на результатах возведения-в-квадрат

-- Функция `multSecond`, перемножающая вторые элементы пар, реализована следующим образом
multSecond = g `on` h -- выполнить * на результатах выбора-второго-элемента-пары
g = undefined
h = undefined

-- Напишите реализацию функций g и h.
GHCi> multSecond ('A',2) ('E',7)
14

-- pointless style
import Data.Function
multSecond = g `on` h
g = (*)
h = snd
```
test

### 2.1.8 анонимные функции, lambda

Лямды, что это, зачем они?
```hs
-- не-замкнутое выражение, имеем свободную переменную х
2 * x + 7
-- чтобы превратить это в валидное выражение, надо абстрагироваться по х, или связать х
let f x = 2 * x + 7

-- можем связать х с помощью лямбда-выражения, которое не связано с именем
ghci> :t \x -> 2 * x + 7
\x -> 2 * x + 7 :: Num a => a -> a -- функция а в а при условии, что а это Num

-- применим лямбда-выражение к числу 10
ghci> (\x -> 2 * x + 7) 10
27

-- определили именованную функцию через лямбда-выражение
ghci> let f = \x -> 2 * x + 7
ghci> :t f
f :: Num a => a -> a
ghci> f 10
27

-- как быть с двумя параметрами?
-- пример, функция двух параметров, как выразить через лямбду?
let lenVec x y = sqrt $ x^2 + y^2
-- вытащим в лямбду один параметр
let lenVec x = \y -> sqrt $ x^2 + y^2
-- вытащили второй параметр (бесплатное каррирование впридачу)
let lenVec = \x -> \y -> sqrt $ x^2 + y^2
-- есть синтаксический сахар для такой записи нескольких лямбд
let lenVec = \x y -> sqrt $ x^2 + y^2 -- подсахаренное определение
ghci> lenVec 3 4
5.0

-- демонстрация удобства лямбд
let p1 = ((1,2),(3,4))
let p2 = ((3,4),(5,6))
-- хотим суммировать первые элементы первых пар
-- доступ к элементу
fst $ fst p1
-- итого
sumFstFst = (+) `on` (\pp -> fst $ fst pp) -- применить + к экстрагированному-первому-элементу-первого-элемента
-- для двух ожидаемых но не указанных явно параметров типа пара пар

-- получилось лаконичнее, чем
sumFstFst = (+) `on` firstFromFirst where firstFromFirst pp = fst $ fst pp

```
repl

Лямбды используются в применениях функ. высших порядков (HOF), где короткое определение функ. через лямбду
удобнее выноса именованной функц. в доступный скоуп.

```hs
{--
Реализуйте функцию `on3`, имеющую семантику, схожую с `on`,
но принимающую в качестве первого аргумента трехместную функцию:
--}
on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = undefined

-- Например, сумма квадратов трех чисел может быть записана с использованием `on3` так
GHCi> let sum3squares = (\x y z -> x+y+z) `on3` (^2)
GHCi> sum3squares 1 2 3
14

on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = op (f x)( f y) (f z)
```
test

## chapter 2.2, параметрический полиморфизм (продолжение)

https://stepik.org/lesson/12398/step/1?unit=2828

### 2.2.2 композиция двух полиморфных функций, оператор (.)

Комбинатор? Оператор композиции функций `.`
```hs
-- хотим ф. высшего порядка, которая берет f, g и возвращает \x -> f $ g x -- f (g x)
-- как это будет по типам?
x :: a
g :: a -> b
f :: b -> c
-- хотим функцию, превращающую `a -> c` с помощью f, g
-- т.е. лямбда по х должна быть такой:
\x -> f (g x) :: a -> c
-- осталось абстрагироваться по f, g
let compose f g = \x -> f (g x)
ghci> :t compose 
compose :: (t1 -> t2) -> (t3 -> t1) -> t3 -> t2

-- dot operator, правая ассоциативность, чуть слабее применения функций
ghci> :i (.)
(.) :: (b -> c) -> (a -> b) -> a -> c   -- Defined in ‘GHC.Base’
infixr 9 .

-- как это можно использовать? Пример:
-- было
sumFstFst = (+) `on` (\pp -> fst $ fst pp) -- применить + к экстрагированному-первому-элементу-первого-элемента
-- стало
sumFstFst = (+) `on` (fst . fst)
-- как выглядит тип экстрактора первого элемента первой пары
ghci> :t (fst . fst)
-- а так это работает
ghci> (fst . fst) ((1, 2), (3, 4))
1

-- забавно, как с помощью оператора . можно сделать определение ф. в pointfree style
foo x = f (g (h x)) = f ((g . h) x) = (f . (g . h)) x
foo = f . (g . h) -- правая ассоциативность?
-- при условии, что типы сочетаются

```
repl

Может так выйти, что программа будет не только лаконичнее, но и эффективнее.
Stay tuned.

```hs
{--
Функция одной переменной `doItYourself` выбирает наибольшее из переданного ей аргумента и числа `42`
затем возводит результат выбора в куб
вычисляет логарифм по основанию `2` от полученного числа `logBase 2 x`
doItYourself = f . g . h

Напишите реализации функций `f`, `g` и `h`
Постарайтесь сделать это в бесточечном стиле
--}

doItYourself 42 -- 16.176952268336283

doItYourself = f . g . h
h = max 42 -- 1) наибольшее из переданного ей аргумента и числа `42`
g = (^ 3) -- 2) затем возводит результат выбора в куб
f = logBase 2 -- 3) вычисляет логарифм по основанию `2` от полученного числа `logBase 2 x`
```
test

### 2.2.4 параметрический полиморфизм кортежей и списков

https://stepik.org/lesson/12398/step/4?unit=2828

Списки полиморфны по типу элементов
```hs
-- полиморфизм списка как типа данных: любой тип даем в конструктор списка, получаем нужный список
-- list of bool values
ghci> :t [True, False]
[True, False] :: [Bool]
-- list of values of other types
ghci> :t ['c', 'h']
['c', 'h'] :: [Char]

-- пустой список это список любого типа (неопределенного)
ghci> :t []
[] :: [a]

-- полиморфизм списков отражается в полиморфизме операций над списками
-- два списка в результ.список
ghci> :t (++)
(++) :: [a] -> [a] -> [a] -- переменная типа `a`, любой тип

-- элем и список в результ. список
ghci> :t (:)
(:) :: a -> [a] -> [a]

-- what about tuples?
-- кортежи имеют более высокую степень полиморфизма чем списки
-- на нам нужен конструктор кортежей, альтернативный
-- смешанный стиль, mixfix
(True, 42)

-- конструктор кортежа из двух элементов: берем два элемента и возвращаем пару
-- префиксный стиль, prefix
ghci> :t (,)
(,) :: a -> b -> (a, b)
-- полиморфен по двум параметрам, степень полиморфизма выше чем у списка

ghci> (,) True 'c'
(True,'c')

-- уменьшение степени полиморфизма, накладывание ограничения
ghci> let dup x = (x, x)
ghci> :t dup
dup :: b -> (b, b)
-- кортеж всегда содержит значения одного типа

-- полиморфизм кортежей отражается в полиморфизме операций с кортежами
ghci> :t fst
fst :: (a, b) -> a
ghci> :t snd
snd :: (a, b) -> b
-- не конкретные типы а переменные типов (любые типы)
```
repl

```hs
-- Сколько разных всегда завершающихся функций с типом
a -> (a, b) -> a -> (b, a, a)
-- можно реализовать?

{--
три стрелочки = три аргумента:
- значение типа а
- пара типов (а, б)
- значение типа а
возвращает пару типов (б, а, а)

на входе три а и один б,
с б проблем нет, он один.
из 3 а можно выбрать x разных пар а:
Две позиции, три варианта для каждой позиции: 3 * 3 (8 бит это 2^8, не так ли?)
--}
9

-- > 'a' в каждом из 3-ех аргументов и в 2-ух местах результата. 'b' в одном аргументе - тут вариантов нет. Итого 3 в степени 2 равно 9
-- > 3 умножил на 3(три аргумента и 3 разных решений)
-- > используем формулу размещений с повторениями: A2/3 = 3^2
```
test

### 2.2.6 curry, uncurry

https://stepik.org/lesson/12398/step/6?unit=2828

Частичное применение функции, пример: ф. двух аргументов примененная к первому аргументу дает ф. одного аргумента.

Ф. с аргуметом типа кортеж: `f (a,b)` выглядит как функция двух аргументов.
Это можно исправить, комбинируя такую ф. с ф. высшего порядка `curry`
```hs
ghci> import Data.Function 
-- оператор on хочет каррированную функцию в первом параметре (выполнить бинарную оп. над результатом преобразований двх аргументов)
ghci> :t on
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c

-- попробуем скормить ему не-каррированную ф.
ghci> :t fst
fst :: (a, b) -> a

-- ошибка, типы не матчатся
ghci> :t fst `on` (^2)
<interactive>:1:1: error:
    • Couldn't match type ‘a’ with ‘(a, b) -> c’

-- каррируем ф. fst (теперь типы матчатся)
ghci> :t curry fst `on` (^2)
curry fst `on` (^2) :: Num c => c -> c -> c

-- другой пример, не-каррированная ф. avg
{ avg :: (Double, Double) -> Double; avg p = (fst p + snd p) / 2 }
ghci> :t curry avg `on` (^2)
curry avg `on` (^2) :: Double -> Double -> Double
-- среднее двух квадратов

-- как реализовать curry?
let curry f x y = f (x, y)
-- карри должен вызвать ф. на паре, поэтому создаем из параметров пару и применяем не-каррированню ф. к паре
-- карри: функция трех аргументов: функция из пары в ц, значения а и б. На выходе ц.
ghci> :t curry
curry :: ((a, b) -> c) -> a -> b -> c
-- можно прочитать так: берет функцию из пары в ц `(a, b) -> c`
-- возвращает каррированную функцию `a -> b -> c`

-- есть обратная ф.: два аргумента: функция двух аргуметов и пара. Возвращает ц.
ghci> :t uncurry
uncurry :: (a -> b -> c) -> (a, b) -> c
-- можно прочитать как: берет функцию двух аргуметов `a -> b -> c`
-- возвращает функцию одного аргумента `(a, b) -> c`
```
repl

```hs
-- Какому известному вам библиотечному оператору, конструктору или функции эквивалентно выражение `curry id`?
(,)
-- почему?
-- посмотрим, что происходит при применении curry к id
ghci> :t id
id :: a -> a
ghci> :t curry
curry :: ((a, b) -> c) -> a -> b -> c
-- первый аргумент карри это функция из пары в ц.
-- id это функция из xz -> xz
-- получается, xz должно быть парой, чтобы матчинг сработал
-- id от пыры это пара, получаем конструктор пары.

-- Какому известному вам библиотечному оператору, конструктору или функции эквивалентно выражение
uncurry (flip const)
-- answer:
snd
{-
Почему?
Посмотрим, что происходит при применении flip const:
конст берет два аргумента и выдает первый.
Флип берет ф. двух аргументов и возвращает ф. двух аргументов (с другим порядком аргументов).
Значит, флип конст вернет функцию конст с переставленными аргументами.
Анкарри к этой функции двух аргументов дает эту ф. но с аргументами завернутыми в пару.
Получаем функцию из пары в ...
-}
ghci> :t const
const :: a -> b -> a

ghci> :t flip
flip :: (a -> b -> c) -> b -> a -> c

ghci> :t uncurry
uncurry :: (a -> b -> c) -> (a, b) -> c

-- В модуле `Data.Tuple` стандартной библиотеки определена функция `swap :: (a,b) -> (b,a)`, переставляющая местами элементы пары:
GHCi> swap (1,'A')
('A',1)
-- Эта функция может быть выражена в виде:
swap = f (g h)
-- т.е. выразим эту функцию в виде трех, f . g . h
-- где f, g и h — некоторые идентификаторы из следующего набора: 
-- curry uncurry flip (,) const
-- Укажите через запятую подходящую тройку f,g,h
uncurry,flip,(,)
{-
Почему?
Чтобы перевернуть пару, очевидно, нужно:
flip, конструктор пары и uncurry.
Хотя, если постараться, можно попробовать через curry, const и flip.
Проблема в определении порядка, что к чему применить, чтобы получить функцию-переворачиватель-пары.
Вот тут надо прочувствовать, как работают функции высших порядков.

Например, аналогия с декораторами:
конструктор ничего декорировать не может, это не ФВП.
В качестве декоратора у нас остаются flip и uncurry.
Если конструктор декорировать uncurry, получим функцию, которая из пары делает пару,
ибо uncurry позволяет передать пару в каррированную функцию - конструктор.
Не совсем то, что надо, но близко.
Получаем заворачивание контруктора в флип и уже это заворачиваем в анкарри: пара проходит через анкарри,
попадает как два аргумента во флип, переворачивается и попадает в конструктор.
-}
```
test

## chapter 2.3, typeclass

https://stepik.org/lesson/8420/step/1?unit=1556

### 2.3.2 ad-hoc polymorphism

Говорили про параметрический полиморфизм, где реализация ф. не зависит от типа параметра.
Теперь рассмотрим "специальный" полиморфизм, где тип параметра должен соответствовать определенному интерфейсу (классу типов).
Т.е. должен быть в наличии (контексте) инстанс (экземпляр) реализации этого интерфейса для данного типа параметра.
```hs
-- как выражается требование наличия инстанса класса типов
ghci> :t 7
7 :: Num a => a
-- => это символ "следования", читать надо как-то так:
-- переменная-типа а при условии, что интерфейс Num (класс типов) применяется к а.
-- а имеет полиморфный тип но для этого типа должен быть в наличии интерфейс Num

-- оператор сложения сделан через специальный полиморфизм,
-- параметры полиморфны и требуют чтобы тип относился к классу типов Num
ghci> :t (+)
(+) :: Num a => a -> a -> a

-- typeclass Ord требуется для оператора сравнения
ghci> :t (>)
(>) :: Ord a => a -> a -> Bool

-- для такого сечения оператора требуется более сложный контекст: 
-- параметр должен иметь тип для которого реализованы два интерфейса
ghci> :t (> 7)
(> 7) :: (Ord a, Num a) => a -> Bool

-- можно сравнивать пары, но для этого надо чтобы для обоих частей пары были реализованы указанные интерфейсы
ghci> :t (> (1, 7))
(> (1, 7)) :: (Ord a, Ord b, Num a, Num b) => (a, b) -> Bool

-- теперь можно понять, что нам говорит текст ошибки: в контексте нет реализации (Num Char), которая требуется для умножения на 3
-- т.е. для Char не определена реализация интерфейса Num
ghci> 3 * 'c'
<interactive>:26:1: error:
    • No instance for (Num Char) arising from the literal ‘3’
```
repl

```hs
-- На нехватку какого представителя какого класса типов пожалуется интерпретатор при попытке вывести тип выражения
True + False * False
-- Запишите ответ в виде Имя_класса_типов Имя_типа. Постарайтесь ответить, не используя GHCi.
Num Bool

<interactive>:27:6: error:
     • No instance for (Num Bool) arising from a use of ‘+’
```
test

### 2.3.4 interface

Класс типов задает интерфейс, который конкретные типы могут реализовать.
Набор функций с общим типовым параметром.
Глядя на контекст ф. можно предполагать какие операции внутри используются.
```hs
-- определение тайпкласса (интерфейса)
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
-- параметр типа `a`, в инстансе (реализации) для конкретного типа вместо а будет этот конкретный тип

-- наличие `Eq a =>` в типе функции и говорит нам о требовании принадлежности а к тайпклассу Eq
ghci> :t (==)
(==) :: Eq a => a -> a -> Bool

-- два разных сечения, в одном полиморфизм сохраняется, во втором нет. Почему?
ghci> :t (== 42)
(== 42) :: (Eq a, Num a) => a -> Bool
-- потому что 42 это полиморфный литерал, а 'c' это мономорфный литерал. Тип однозначно определен.
ghci> :t (== 'c')
(== 'c') :: Char -> Bool

-- a должен реализовывать typeclass Eq (чтобы методом сравнения искать элемент в списке)
ghci> :t elem
elem :: (Foldable t, Eq a) => a -> t a -> Bool
-- `t a` можно читать как конструктор типа t, который должен реализовывать тайпкласс фолдабл (список например).
-- Конструктор типа t примененный к типу a даст тип t a, например [] Char -> [Char]
-- Haskell 2010 Language Report, раздел 4.1.2 Syntax of Types говорит,
-- что имена конструкторов типа начинаются с большой буквы (кроме встроенных, типа списка и кортежа).
-- Так что t здесь именно переменная типа.
-- Применение тИповой переменной t (описывающей однопараметрический конструктор типа) к тИповой переменной a
```
repl

```hs
-- Попробуйте, не используя GHCi или Hoogle, определить, какого контекста не хватает в типе функции
-- сортирующей переданный в нее список.
sort :: ? => [d] -> [d]
-- Напишите выражение, которое должно стоять на месте знака вопроса.
(Ord d)
```
test

### 2.3.6 instance, default method

```hs
-- ф. с одинаковыми сигнатурами можно перечислить через запятую (в декларации)
class Eq a where
    (==), (/=) :: a -> a -> Bool
-- экземпляр (instance) тайпкласса, для типа Bool
-- используем паттерн матчинг для имплементации
instance Eq Bool where
    True    == True     = True -- два случая когда результат тру
    False   == False    = True
    _       == _        = False -- в остальный случаях фолс
    x       /= y        = not (x == y) -- определим неравно через равно.

-- что характерно (почему ad-hoc): реализация интерфейса тайпкласса отделена от определения типа бул.
-- Это значит, что мы можем в любое время и в любом месте добавить реализацию любого тайпкласса к любому типу не меняя код типа.

-- дефолтная реализация
-- можно в определение тайпкласса внести дефолтные реализации, если они полиморфны.
-- можно сделать их циклическими относительно друг-друга, тогда конкретная имплементация должна будет хотя бы один метод переопределить.
class Eq a where
    (==), (/=) :: a -> a -> Bool
    x       /= y        = not (x == y)
    x       == y        = not (x /= y)
instance Eq Bool where
    True    == True     = True
    False   == False    = True
    _       == _        = False

-- Minimal Complete Definiton
-- что надо минимально реализовать для имплементации тайпкласса
```
repl

```hs
{--
Реализуйте класс типов `Printable`, предоставляющий один метод `toString`
функцию одной переменной, которая преобразует значение типа, являющегося представителем `Printable`, в строковое представление
Сделайте типы данных `Bool` и `()` (`()`: пустой кортеж) представителями этого класса типов, обеспечив следующее поведение:
--}
GHCi> toString True
"true"
GHCi> toString False
"false"
GHCi> toString ()
"unit type"

class Printable a where
    toString :: a -> String
instance Printable Bool where
    toString True = "true"
    toString _ = "false"
instance Printable () where  
    toString _ = "unit type"
```
test [test-printable](./chapter-2.3/test-printable.hs)

### 2.3.8 полиморфный тайпкласс

Тайпкласс можно определить для полиморфного типа, определив контекст для этого типа
```hs
-- определим тайпкласс экв. для пары, добавив требование
-- (Eq a, Eq b) => 
instance (Eq a, Eq b) => Eq (a,b) where
    (a1, a2) == (b1, b2) = a1 == b1 && a2 == b2

-- Функциональные (стрелочные) типы сравнивать нельзя.
-- Увы, компилятор не знает, что стандартная ф. айди и `ghci> id = (\x -> x)` равны.
ghci> id == (\x -> x)
<interactive>:52:4: error:
    • No instance for (Eq (p0 -> p0)) arising from a use of ‘==’
```
repl

```hs
-- Сделайте тип пары представителем класса типов Printable, реализованного вами в предыдущей задаче, обеспечив следующее поведение:
GHCi> toString (False,())
"(false,unit type)"
GHCi> toString (True,False)
"(true,false)"
-- Объявление класса типов Printable и представителей этого класса для типов () и  Bool заново реализовывать не надо

instance (Printable a, Printable b) => Printable (a, b) where
    toString (a, b) = '(' : toString a ++ ',' : toString b ++ ")"
```
test [test-printable](./chapter-2.3/test-printable.hs)

## 2.4, Стандартные классы типов (typeclass)

https://stepik.org/lesson/12399/step/1?unit=2829

### 2.4.2 class extension

https://stepik.org/lesson/12399/step/2?unit=2829

Расширение тайпкласса.
По сути, это расширение существующего интерфейса новыми методами.
```hs
-- требование к контексту заявлено уже в определении интерфейса,
-- не при реализации а при декларации тайпкласса.
-- Значит, что тип а для участия в тайпклассе Ord должен участвовать в тайпклассе Eq
-- или, тайпкласс Eq расширен в тайпклассе Ord
class (Eq a) => Ord a where
    (<), (<=), (>=), (>) :: a -> a -> Bool
    max, min :: a -> a -> a
    compare :: a -> a -> Ordering
    -- Minimal Complete Definition: either compare or <=
    -- в стдлиб тайпкласс имеет дефолтные методы и для создания инстанса достаточно определить одну из двух функций.

-- порядок определяет 3 значения: меньше, равно, больше
ghci> :i Ordering
type Ordering :: *
data Ordering = LT | EQ | GT

-- допустимо множественное (наследование) расширение
class (Eq a, Printable a) => MyClass a where
```
repl

```hs
{--
Пусть существуют два класса типов `KnownToGork` и `KnownToMork`
которые предоставляют методы `stomp` (`stab`) и `doesEnrageGork` (`doesEnrageMork`) соответственно:
Класса типов `KnownToGorkAndMork` является расширением обоих этих классов, предоставляя дополнительно метод `stompOrStab`:
Задайте реализацию по умолчанию метода `stompOrStab`
которая вызывает метод `stomp`, если переданное ему значение приводит в ярость Морка
вызывает `stab`, если оно приводит в ярость Горка
вызывает сначала `stab`, а потом `stomp`, если оно приводит в ярость их обоих
Если не происходит ничего из вышеперечисленного, метод должен возвращать переданный ему аргумент
--}
class KnownToGork a where
    stomp :: a -> a
    doesEnrageGork :: a -> Bool
class KnownToMork a where
    stab :: a -> a
    doesEnrageMork :: a -> Bool

class (KnownToGork a, KnownToMork a) => KnownToGorkAndMork a where
    stompOrStab :: a -> a
    stompOrStab x
        | eg && em = stomp $ stab x
        | eg = stab x
        | em = stomp x
        | otherwise = x
     where
       eg = (doesEnrageGork x)
       em = (doesEnrageMork x)
```
test

### 2.4.4 Show, Read (serdes)

https://stepik.org/lesson/12399/step/4?unit=2829

```hs
-- тайпкласс Show содержит ф. a -> String
-- Поэтому можно легко сделать печатаемым любой свой тип, просто реализовать тайпкласс Show для своего типа
ghci> :t show
show :: Show a => a -> String

ghci> show (1, 2.0, 'c', True)
"(1,2.0,'c',True)"

-- ф. read полиморфна по возвращаемому значению
ghci> :t read
read :: Read a => String -> a
-- без указания выходного типа ридер падает: полиморфный результат, недостаточно информации для матчинга в конкретный тип
ghci> read "5" :: Int
5
ghci> read "'c'" :: Char
'c'
ghci> read "[1,2,3]" :: [Float]
[1.0,2.0,3.0]
-- с юнитом проблем нет, тут однозначно
ghci> read "()"
()

-- проблема: ф. read читает весь ввод и парсит его весь,
-- нельзя частично прочитать ввод
-- альтернатива:
ghci> :t reads
reads :: Read a => ReadS a
-- конструктор типа, параметризован а, при условии что а это тайпкласс Read
-- функция тотальная, если что не так, получим пустой список,
-- список может содержать разные варианты разбора если есть неоднозначность парсинга
ghci> reads "5 rings" :: [(Int, String)]
[(5," rings")]
ghci> reads "5 rings"
[]
```
repl

```hs
-- Имея функцию 
ip = show a ++ show b ++ show c ++ show d 
-- определите значения a, b, c, d так, чтобы добиться следующего поведения:
GHCi> ip
"127.224.120.12"

a = 127.2
b = 24.1
c = 20.1
d = 2
```
test

### 2.4.6 Enum, Bounded

Тайпклассы в стандартной библиотеке.

```hs
-- Enum: перечисление значений типа
-- typeclass Enum, интерфейс последовательного перебора
class Enum a where
    succ, pred :: a -> a
    toEnum :: Int -> a
    fromEnum :: a -> Int

ghci> succ 4
5
ghci> pred 4
3

ghci> pred 'z'
'y'
ghci> succ 'z'
'{'

ghci> fromEnum ' '
32

-- ф. полиморфная по выходу, надо уточнить желаемый тип
ghci> toEnum 65 :: Char
'A'

-- Bounded: ограничения диапазона значений
class Bounded a where
    minBound, maxBound :: a

ghci> minBound :: Bool
False
ghci> maxBound :: Bool
True

ghci> minBound :: Char
'\NUL'
ghci> maxBound :: Char
'\1114111'

-- Integer un-bounded
```
repl

```hs
-- Реализуйте класс типов
class (???) => SafeEnum a where
  ssucc :: a -> a
  ssucc = undefined
  spred :: a -> a
  spred = undefined
{--
обе функции которого (ssuc, spred) ведут себя как succ и pred стандартного класса Enum
однако являются тотальными
обеспечивают циклическое поведение
класс должен быть расширением ряда классов типов стандартной библиотеки
чтобы можно было написать реализацию по умолчанию его методов,
позволяющую объявлять его представителей без необходимости писать какой бы то ни было код
Например, для типа Bool должно быть достаточно написать строку
--}
instance SafeEnum Bool
-- и получить возможность вызывать
GHCi> ssucc False
True
GHCi> ssucc True
False

class (Enum a, Bounded a, Eq a) => SafeEnum a where
  ssucc :: a -> a 
  ssucc x
    | x == maxBound = minBound
    | otherwise = succ x
  spred :: a -> a
  spred x
    | x == minBound = maxBound
    | otherwise = pred x
```
test [safe_enum](./chapter-2.4/test-safe_enum.hs)

### 2.4.8 Num

```hs
class Num a where
    -- declaretion
    (+), (-), (*) :: a -> a -> a
    negate :: a -> a
    abs :: a -> a
    signum :: a -> a
    fromInteger :: Integer -> a
    -- LAW: abx x * signum x == x
    -- default implementation
    x - y = x + negate y
    negate x = 0 - x

-- числовые литералы реализованы как Integer с последующим применением fromInteger
-- закон (для проверки в тестах): модуль числа * знак числа == число
-- Операция деления не объявлена для Num, мотив не ясен (типа, реализации разные в интеграл и фракшнл)

-- да, интеграл содержит деление (но наследует не прямо от Num)
-- два разных деления, различие в эффективности и обработке минуса
ghci> :i Integral
type Integral :: * -> Constraint
class (Real a, Enum a) => Integral a where
  quot :: a -> a -> a -- эффективное деление
  rem :: a -> a -> a
  div :: a -> a -> a -- обычное деление
  mod :: a -> a -> a
  quotRem :: a -> a -> (a, a)
  divMod :: a -> a -> (a, a)
  toInteger :: a -> Integer

-- наследует напрямую от Num и деление как инфиксный оператор с приоритетом 7
ghci> :i Fractional
type Fractional :: * -> Constraint
class Num a => Fractional a where
  (/) :: a -> a -> a
  recip :: a -> a
  fromRational :: Rational -> a

ghci> :i (/)
type Fractional :: * -> Constraint
class Num a => Fractional a where
  (/) :: a -> a -> a
  ...
        -- Defined in ‘GHC.Real’
infixl 7 /

-- все стандартные мат.операции определены в тайпклассе Floating, наследующем Fractional
ghci> :i Floating
type Floating :: * -> Constraint
class Fractional a => Floating a where
  pi :: a
  exp :: a -> a
  log :: a -> a
  sqrt :: a -> a
  (**) :: a -> a -> a
  logBase :: a -> a -> a
  sin :: a -> a
  cos :: a -> a
  tan :: a -> a
  asin :: a -> a
  acos :: a -> a
  atan :: a -> a
  sinh :: a -> a
  cosh :: a -> a
  tanh :: a -> a
  asinh :: a -> a
  acosh :: a -> a
  atanh :: a -> a
  GHC.Float.log1p :: a -> a
  GHC.Float.expm1 :: a -> a
  GHC.Float.log1pexp :: a -> a
  GHC.Float.log1mexp :: a -> a

-- операции округления в тайпклассе RealFrac
ghci> :i RealFrac
type RealFrac :: * -> Constraint
class (Real a, Fractional a) => RealFrac a where
  properFraction :: Integral b => a -> (b, a)
  truncate :: Integral b => a -> b
  round :: Integral b => a -> b
  ceiling :: Integral b => a -> b
  floor :: Integral b => a -> b

-- операции связаннаые с кодированием (представлением) чисел с п.точкой в тайпклассе RealFloat
ghci> :i RealFloat 
type RealFloat :: * -> Constraint
class (RealFrac a, Floating a) => RealFloat a where
  floatRadix :: a -> Integer
  floatDigits :: a -> Int
  floatRange :: a -> (Int, Int)
  decodeFloat :: a -> (Integer, Int)
  encodeFloat :: Integer -> Int -> a
  exponent :: a -> Int
  significand :: a -> a
  scaleFloat :: Int -> a -> a
  isNaN :: a -> Bool
  isInfinite :: a -> Bool
  isDenormalized :: a -> Bool
  isNegativeZero :: a -> Bool
  isIEEE :: a -> Bool
  atan2 :: a -> a -> a

```
repl

```hs
-- Напишите функцию с сигнатурой:
avg :: Int -> Int -> Int -> Double
-- вычисляющую среднее значение переданных в нее аргументов
GHCi> avg 3 4 8
5.0

avg :: Int -> Int -> Int -> Double
avg a b c = (/ 3) . sum . map fromIntegral $ [a,b,c]
```
test

## 2.5, Нестрогая семантика, ленивые вычисления

https://stepik.org/lesson/8421/step/1?unit=1557

Последствия ленивости вычислений, строгие / не-строгие функции и возможности оптимизации (скорость, память).
Трюк с форсированием (запуском) вычисления.

### 2.5.2 lazy vs eager

Порядок вычислений, императивные языки: задан порядок; ф.языки: как такогого порядка нет.
Но есть редуцирование выражений по некоторым стратегиям и правилам (плюс правила и способы оптимизации, кэширования).
Вот эти правила в итоге определяют "порядок" вычислений.

Важное свойство ф. языков: независимость результата от выбранной стратегии (lazy vs eager).
Но это если программы "завершающиеся". Если некое под-выражение окажется незавершающимся, свойство не держится.

```hs
-- пусть будет ф. определяющая выражение
sumIt :: Int -> Int -> Int
sumIt x y = x + y
-- применим ф. в выражении
sumIt (1 + 2) 3
6

-- можно увидеть разные способы редукции выражения
sumIt (1 + 2) 3
-- lazy (ленивая стратегия)
x + y = (1 + 2) + 3
-- eager (энергичная стратегия)
sumIt (1 + 2) 3 = sumIt 3 3
x + y = 3 + 3

-- хаскель придерживается ленивой семантики вычисления выражений
-- это дает побочку:
-- многократное вычисление одного и того-же под-выражения, возможность работать с бесконечными последовательностями, жор памяти

-- RedEx: reducible expression
-- выражение которое можно сократить непосредственно (сокращабельное)
2 + 3 -- redex, вычисленное значение
sumIt exp1 exp2 -- redex, подстановка
```
repl

```hs
-- Предположим, что стандартные функции определены следующим образом:
const x y = x
max x y = if x <= y then y else x
f $ x = f x -- infixr 0 $
-- Сколько редексов имеется в следующем выражении
const $ const (4 + 5) $ max 42

-- Мы определили шаг вычислений как подстановку тела функции вместо ее имени с заменой всех ее формальных параметров
-- на фактически переданные ей выражения
-- Редексом при этом мы называем подвыражение, над которым можно осуществить подобный шаг.

max 42 -- нет, только один параметр
(4 + 5) -- да
(const (4 + 5)) $ (max 42) -- да
(const) $ (const (4 + 5) $ max 42) -- да

-- ответ
3
```
test

### 2.5.4 lazy

К чему приводит ленивость:
к возможности не вычислять не используемые ветки выражений, экономить ресурсы.
Но не всегда, иногда наоборот: при использовании одного подвыражения в нескольких местах,
подвыражение будет вычисляться несколько раз, тратить ресурсы.

Для снижения потерь для ленивых (https://wiki.haskell.org/Thunk)
есть механизм "разделения", суть которого в использовании ссылок на под-выражения,
тогда можно вычислять под-выражение один раз и по ссылке подставлять уже вычисленное значение.
Мемоизация, одним словом (кеширование).

```hs
-- возьмем ф. добавления 7, по аналогии с ф const
add7 x y = x + 7
-- второй аргумент не используется
-- lazy, (2 + 3) не вычисляется ибо не используется
add7 1 (2 + 3)
~> 1 + 7
~> 8
-- eager, (2 + 3) вычислися перед применением ф., результат передан в ф. и проигнорирован
add7 1 (2 + 3)
~> add7 1 5
~> 1 + 7
~> 8

-- другой пример, с обратным эффектом
dup x = (x, x)
dup (2 + 3)
-- lazy, подстановка без вычисления, отложенных вычислений будет х2
dup (2 + 3)
~> ((2 + 3), (2 + 3)) -- здесь поможет механизм разделения (подстановка ссылки на под-выражение)
~> (5, (2 + 3))
...
-- eager, под-выражение вычисл. один раз и результат подставляется downstream
dup (2 + 3)
~> dup (5)
~> (5, 5)
```
repl

```hs
-- Сколько шагов редукции потребуется, чтобы вычислить значение функции `value`, 
-- если используется ленивая стратегия вычислений с механизмом разделения?
:set lazy thunk -- pseudo command
-- Подстановку тела функции `value` вместо `value` не считайте
bar x y z = x + y
foo a b = bar a a (a + b)
value = foo (3 * 10) (5 - 2)

foo (3 * 10) (5 - 2)
~> bar (3 * 10) (3 * 10) ((3 * 10) + (5 - 2))
~> (3 * 10) + (3 * 10)
~> (30) + (30) -- тут подставили thunk
~> 60
-- ответ: 4

```
test

### 2.5.6 сокращение неопределенности, нестрогие функции

При ленивой стратегии вычислений сокращается (возможная) неопределенность вычислений.
Если есть в программе подвыражения расходящиеся (undefined, error, infinite-loop, etc), то когда эти выражения
попадают в отбрасываемую ветку вычислений, они не будут выполнены и не сломают программу.
Ф. с таким поведением называется "не-строгой".
```hs
-- имитация функции, которая отбрасывает вычисления по второй ветке
const42 = const 42
ghci> let u = undefined
ghci> const42 u -- ленивые вычисления рулят, u не будет вычислена, только передана в ф.
42

-- const42 это "не-строгая" функция.
-- при наличии расходящегося параметра (аргумента), результат ф. не расходится.
-- строгая ф.: при наличии расходящегося аргумента, результат ф. обязательно расходится.

```
repl

Строгость может зависеть от конкретных значений аргументов.
Ф. двух параметров может быть строгой по одному и нестрогой по другому параметру в зависимости от значения первого.

Про некоторые (встроенные) ф. компайлер знает их строгость и может провести некий анализ отслеживая их вызовы.
Строгая ф. позволяет оптимизировать выполнение, применив "энергичную" стратегию при ее вызове.

> в языках с энергичной моделью вычисления, где все аргументы функций вычисляются перед тем, как функция применяется к ним,
можно просто говорить, что все функции строгие.

```hs
-- Отметьте функции, которые не могут привести к расходимости ни на каком корректном наборе аргументов
-- всегда "завершаются"
-- корректный набор аргументов: выражение, представляющее применение функции к этому набору, пройдет проверку типов.
foo a = a -- нет, можно передать undefined и сломать
bar = const foo -- нет, возвращает foo
baz x = const True -- да, всегда True
quux = let x = x in x -- нет, вообще бесконечный цикл подстановки х вместо х
corge = "Sorry, my value was changed" -- да, константа
grault x 0 = x -- нет, см foo
grault x y = x -- нет, см foo
garply = grault 'q' -- нет, grault это сопоставление с образцом, запускающее вычисление второго аргумента
waldo = foo -- нет, см foo
```
test

### 2.5.8 нормальная форма

Выражение не содержащее редексов: выражение в нормальной форме.

Слабая Головная Нормальная Форма: слегка нормализованное выражение,
до степени, пригодной для использования в паттерн матчинге.

> An expression is in weak head normal form (WHNF), if it is either:
конструктор, билт-ин ф., лямбда абстракция.
Их аргументы не обязаны быть нормализованы.

В основном, при необходимости, хаскель вычисляет выражения до состояния слабой-нормальной... а вовсе не до NF.
Это повышает степень ленивости и снижает неопределенность (шанс выполнить расходящуюся ветку).
```hs
-- WHNF
\x -> x + 2*3 -- не норм.форма но слабая норм. ибо лямбда (за барьером лямбда-абстракции)
(3, 1+5) -- data constructor (tuple)
(,) (4*5) -- constructor, partially applied
(+) (7^2) -- built-in function, partially applied

-- как проверить выражение на WHNF
GHCi> (+) (7^undefined) (4*5) `seq` 42 -- not WHNF
*** Exception: Prelude.undefined
GHCi> (+) (7^undefined) `seq` 42 -- yes WHNF
42
-- см. след. лекцию
```
repl

https://stepik.org/lesson/8421/step/9?discussion=8724096&reply=8728361&unit=1557
```hs
-- Какие из выражений ниже не находятся в нормальной форме, но находятся в слабой головной нормальной форме?
-- WHNF but not NF
-- частично примененные ф. можно рассматривать как сахар для лямбда-выражений, которые внутри могут редуцироваться (или нет)
-- если нет редексов то имеем NF; если есть редексы но они за барьером лямбды или конструктора то имеем WHNF
\x -> x -- нет, NF
3 -- нет, NF

(,) undefined -- да, частично примененный конструктор пары (редекс undefined за барьером лямбды, замаскированной под конструктор)
-- > Выражение НЕ находится в NF, потому, что содержит редекс undefined)
-- Не частичное применение конструктора делает его WHNF, а наличие редекса; без него было бы NF
-- Выражение при этом НАХОДИТСЯ в WHNF, потому, что этот редекс неустраним без подстановки внутри тела функции
-- \y -> (undefined, y)

(+) (2 * 3 * 4) -- да, встроенная ф. частично примененная
[undefined, 4 + 5, -1] -- да конструктор
fst (1,0) -- нет, не норм и не слабая форма

-- https://stepik.org/lesson/8421/step/9?discussion=8724096&reply=8728361&unit=1557
{--
Если нам нужно выражение в NF, мы вычисляем его до тех пор пока нам нечего будет подставлять
5                 -- *
\x -> 1 + x       -- **
\x -> (x + 1) + 1 -- ***
(1, 2)
[5]

* Вообще-то числовые литералы в Haskell полиморфны, и 5 в воспринимается компилятором как применение fromInteger, к значению 5 типа Integer, что вполне себе требует подстановки
** Сложение оно, опять же, в лямбла-исчислении может считаться встроенной функцией, в Haskell у него даже для самых простых типов может быть определение, требующее подстановки
*** Хоть и подразумевается, что операция сложения ассоциативна и коммутативна, компилятор не опирается на это слепо, потому, что это не гарантируется даже для некоторых встроенных типов

Если достаточно WHNF, можем остановиться, когда (лямбда, конструктор, частично-примененная ф.)
- дошли до лямбды или частично примененной (стандартной?) ф. (или конструктора)
\x -> x + (1 + 1)
const (1 + 2)

- видим полностью примененный конструктор (данных?)
(1, 2 + 3)
[x]

насчет не полностью примененных функций/конструкторов (можно считать их сахаром для лямбды)
получается, что это просто частный случай первого правила - мы не полезем под лямбду
(4 + 5,)       =  (\x -> (\y -> (x, y)) (4 + 5)
               ~> \y -> (4 + 5, y)
const (1 + 2)  =  (\x -> (\y -> const x y)) (1 + 2)
               ~> \y -> const (1 + 2) y
--}
```
test

### 2.5.10 seq operator

Ленивая семантика приводит к накоплению отложенных вычислений и пожиранию памяти.
Для ручного запуска отложенных вычислений применяют оператор `seq`
```hs
seq :: a -> b -> b
seq _|_ b = _|_
seq a b = b
-- The value of seq a b is bottom if a is bottom, and otherwise equal to b.
-- In other words, it evaluates the first argument a to weak head normal form (WHNF).
-- seq is usually introduced to improve performance by avoiding unneeded laziness.

-- пат.мат. приводит к вычислению аргументов (до момента возможности сопоставить паттерн)
ghci> seq 1 2
2
ghci> seq undefined 3
*** Exception: Prelude.undefined

-- демонстрация форсирования вычислений до WHNF
-- первое выражение вычисляется, но не конца (NF)
ghci> seq (1,undefined) 42
42
ghci> seq (,undefined) 42
42
ghci> seq ((+) 2) 42
42
ghci> seq (\x -> undefined) 42
42
```
repl

https://stepik.org/lesson/8421/step/11?unit=1557
```hs
-- напомню, оператор `seq` право-ассоциативен с наименьшим приоритетом
ghci> :i seq
seq :: a -> b -> b      -- Defined in ‘GHC.Prim’
infixr 0 `seq`

{--
При вычислении каких из перечисленных ниже функций
использование `seq` предотвратит нарастание количества невычисленных редексов
при увеличении значения первого аргумента
--}
-- другими словами: какие ф. будут оптимизированы?

-- что тут происходит?
-- два аргумента, если первый = 0 то возвращаем второй.
-- иначе: возвращает х', где x' рекурсивно вызывает foo
-- ответ: нет, не оптим.
foo 0 x = x
foo n x = let x' = foo (n - 1) (x + 1)
          in x' `seq` x' -- нет оптимизации, x' по любому будет как есть

-- что здесь?
-- начало как и foo, но: возвращает (f' `seq` (x' `seq` (bar x' f')))
-- где x' рекурсивное выражение; f' лямбда абстракция (WHNF)
-- ответ: нет (пат.мат. не дает проявить оптимизацию от seq), хотя за счет форсирования, x' на каждом шаге будет редуцировать до числа
-- f' `seq` не дает оптимизации ибо f' уже в WHNF; 
bar 0 f = f
bar x f = let f' = \a -> f (x + a)
              x' = x - 1
          in f' `seq` x' `seq` bar x' f'

-- что здесь?
-- два аргумента, второй пара. при первом = 0 дает сумму пары.
-- иначе: (p `seq` (n' `seq` (baz n' p)))
-- где n' рекурсивное выражение; p это конструктор пары из простых арифм.выражений
-- ответ: нет, n' `seq` (baz n' p) оптимизируется за счет форсирования n', редукция в число каждый раз (но пат.мат. не дает этому проявиться)
-- p `seq` (n' `seq` (baz n' p)) -- бесполезно ибо p уже в WHNF
baz 0 (x, y) = x + y
baz n (x, y) = let x' = x + 1
                   y' = y - 1
                   p  = (x', y')
                   n' = n - 1
               in p `seq` n' `seq` baz n' p

-- что здесь?
-- начало как и baz, на выходе
-- (x' `seq` (y' `seq` (n' `seq` (quux n' p))))
-- n' это рекурсивная арифметика, выполняется пат.матом
-- p это конструктор пары (x', y') WHNF и не нормализуется
-- который пойдет в рекурсивный вызов quux если y' и x' вычислимы до WHNF
-- x', y' это рекурсивная арифметика
-- ответ: да, за счет нормализации y', x' в seq
quux 0 (x, y) = x + y
quux n (x, y) = let x' = x + 1
                    y' = y - 1
                    p  = (x', y')
                    n' = n - 1
                in x' `seq` y' `seq` n' `seq` quux n' p

-- не угадал с первого раза
-- почему? Не учел, что пат.мат. редуцирует выражения до WHNF (как и seq) и "маскирует" эффект от seq в некоторых случаях.
{--
https://stepik.org/lesson/8421/step/11?discussion=8727918&reply=8733872
> seq - сугубо магическая функция, ее нельзя выразить в терминах Haskell, но нечто похожее на нее для большинства типов можно описать через сопоставление с образцом. 
...
эффект, который оно (pat.mat.) создает - вычисление аргумента до (как минимум) WHNF трудно получить вручную другими способами
...
стоит понимать, что никакие вычисления не начинаются, пока не будут форсированы (в подавляющем большинстве случаев - с помощью сопоставления с образцом)
...
Попытка форсировать x `seq` x даст нам значение x, вычисленное как минимум до WHNF.
Попытка форсировать x, очевидно, даст нам то же самое.

я: поэтому компайлер заменяет `seq x x` на `x`? Логику такого дизайна я по прежнему не улавливаю.
Вероятно, автор seq хотел просто оперировать двумя ветками кода.
--}
```
test

### 2.5.12 оператор строгого применения ($!)

Оператор "аппликации с вызовом по значению" `$!`
или "оператор применения-с-нормализацией-аргумента"
или "строгий оператор применения"
как удобная замена ф. `seq`; перед вычислением второго параметра нормализует первый до WHNF;
строгий, потому что превращает потенциально нестрогую ф. в строгую (с точностью до WHNF)
```hs
-- бинарный оператор, первый параметр это ф. из а в б, второй параметр это а; возвращает б
-- реализована как: undefined if x is undefined, or f x
-- право-ассоц, низший приоритет
($!) :: (a -> b) -> a -> b
f $! x = x `seq` f x
-- аргумент вычисляется (нормализуется до WHNF) до того, как применяется функция на этом аргументе
ghci> :i ($!)
($!) :: (a -> b) -> a -> b      -- Defined in ‘GHC.Base’
infixr 0 $!

-- сравни с оператором применения (понижает приоритет, удобен для устранения скобок при право-ассоциативном выражении)
ghci> :i ($)
($) :: (a -> b) -> a -> b       -- Defined in ‘GHC.Base’
infixr 0 $

-- чисто напоминание: оператор комбинирования функций
-- комбинирует два шага преобразования (a -> b), (b -> c) в один шаг (a -> c)
ghci> :i (.)
(.) :: (b -> c) -> (a -> b) -> a -> c   -- Defined in ‘GHC.Base’
infixr 9 .

-- examples
ghci> const 42 undefined -- расходимость потеряна по лени
42
ghci> const 42 $ undefined -- аналогично
42
ghci> const 42 $! undefined -- расходимость НЕ потеряна, функция строгая
*** Exception: Prelude.undefined

-- как снизить жор памяти в факториале
factorial n | n >= 0    = helper 1 n
            | otherwise = error "arg must be >= 0" -- helper available here
  where
    helper acc 0 = acc
    helper acc n = helper (acc * n) (n - 1)
-- вызов helper (acc * n)
-- накапливает выражения произведения и может быть оптимизирован
helper acc n = (helper $! (acc * n)) (n - 1)
-- убрали ленивость при вычислении перовго параметра хелпера
```
repl

```hs
-- Ниже определены функции `mySum` и `goSum`
-- Вызов `goSum` может выглядеть, к примеру, так:  `goSum 15`

mySum acc 0 = acc -- два аргумента, возвращает первый если второй = 0; n.b. pattern mathing
mySum (result, ()) n = (mySum $! (result + n, ())) $ n - 1 -- два аргумента,
-- первый это пара из result и юнит. Возвращает результат применения левого-выражения к правому
-- право: `n - 1` как аргумент ф. поставленной слева
-- лево: `mySum $! (result + n, ())` строгое применение себя (рекурсия) к первому аргументу `(result + n, ())`
-- итого: рекурсивно вызываем себя, вычитая счетчик, накапливая результат в паре (result, ())
-- добавляет к резулту число во втором аргументе, убирает лень вычисления аккумулятора (нет, ибо это пара в WHNF)

goSum = mySum (0, ()) -- функция суммирования чисел последовательности

-- Выберите верные утверждения, описывающие процесс вычисления подобного выражения
(нет) В первом аргументе функции mySum не будут накапливаться отложенные вычисления, так как при рекурсивных вызовах используется оператор $!$!.

(нет) В первом аргументе функции mySum не будут накапливаться отложенные вычисления, так как он будет находиться в слабой головной нормальной форме.

(да) В первом аргументе функции mySum будут накапливаться отложенные вычисления.
-- ибо первый параметр оформлен как пара, это WHNF и не редуцируется здесь.

(нет) Во втором аргументе функции mySum будут накапливаться отложенные вычисления из-за того, что его передача при рекурсивном вызове происходит с помощью оператора $$ а не $!$!.

(да) Во втором аргументе функции mySum не будут накапливаться отложенные вычисления, так как при каждом рекурсивном вызове происходит сопоставление с 0.

(нет) Во втором аргументе функции mySum не будут накапливаться отложенные вычисления, так как минус - примитивная операция
```
test

## 2.6, Модули и компиляция

https://stepik.org/lesson/8422/step/1?unit=1558

### 2.6.2 import

Программа это коллекция модулей.
Главный модуль: `Main`. Имена модулей с большой буквы.
Имя файла совпадает с именем модуля.
Модули собираются в иерархию: имена разделяются точкой, на диске это каталоги и файлы
```hs
module Demo where
-- module definitions

import Data.Char -- модуль Char из каталога Data
-- это импорт всех определений Data.Char

import Data.Char (toUpper, toLower) -- импорт только выбранных определений

-- как импортировать все, кроме выбранных?
import Data.Char hiding (toUpper, toLower) -- импорт всего, кроме указанного

-- как назначить алиас при импорте? xz

-- можно использовать полное имя функции, без предварительного импорта
ghci> :t Data.List.union
Data.List.union :: Eq a => [a] -> [a] -> [a]

-- можно потребовать импорт с полными именами
import qualified Data.Set as Set -- определения из этого модуля будут доступны по именам Set.name

-- явный импорт либы Prelude перекрывает неявный импорт.
-- поэтому можно модифицировать импортируемые из Prelude определения (см.выше)

import Dr.A  
-- В директории Dr должен лежать не файл A.hs с модулем A, но
-- файл A.hs c модулем Dr.A
```
repl

https://stepik.org/lesson/8422/step/3?unit=1558
```hs
-- Что произойдет при попытке загрузить данный модуль в GHCi?
module Test where
import Data.List hiding (union)
import Data.Set
myUnion [] ys = ys
myUnion xs ys = union xs ys
-- ответ: реализация функции использует union из модуля Set
ghci> :t myUnion 
myUnion :: Ord a => Set a -> Set a -> Set a
-- что даст ошибку при загрузке
ghci> :l chapter-2.6/test-import.hs 
chapter-2.6/test-import.hs:5:23: error:
    • Couldn't match expected type: Set a2
                  with actual type: [a1]
...
Failed, no modules loaded.
```
test

### 2.6.4 export

Модуляризация, инкапсуляция и сокрытие деталей в Х. доступно только на уровне модулей, иерархических именованных "пакетов".
В модулях могут быть определения типов, классов-типов, констант, функций, операторов (что еще?)

Программа (модуль) может экспортировать имена явно, перечислив их в "шапке" модуля
```hs
-- в модуле Тест имеем две ф.
module Test where
sumIt x y = x + y
const42 = const 42
-- в модуле Демо имеем два выражения, использующих Тест
module Demo where
import Test
f1 = const42 True
f2 = sumIt 3 4

-- чтобы ограничить экспорт из Тест, можно в шапке модуля определить явно, что мы экспортируем
module Test (sumIt) where
-- только самИт можно будет импортировать из модуля Тест, остальные определения будут "приватными"
```
repl

```hs
-- Пусть модуль `Foo` содержит следующий код:
module Foo (a, b) where -- export (a, b)
a = undefined
b = undefined
c = undefined -- private

-- а модуль `Bar` такой:
module Bar (a, d) where -- export (a, d) -- a from Foo
import Foo (a, b)
d = undefined

-- после загрузки в модуле `Baz` со следующим кодом:
module Baz where
import Bar -- a (from Foo), d (from Bar)

-- Отметьте функции, доступные для использования (в Baz?)
a (from Foo), d (from Bar)
```
test

### 2.6.6 этапы компиляции

- синтаксический разбор кода
- все имена квалифицируются (FQN)
- проверяются типы
- рассахаривание, генерация низкоуровнего, более простого кода -- Core
- оптимизация, несколько циклов (переписывание AST)
- кодогенерация, два этпа
- Core -> STG Machine (граф)
- STG -> C-- (Cmm)
- Cmm -> assembly or LLVM

- https://aosabook.org/en/v2/ghc.html#fig.ghc.pipeline
- https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/an-external-representation-for-the-ghc-core-language-for-ghc-6.10.html#introduction
- https://github.com/ghc/ghc
