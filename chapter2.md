# FP Haskell, chapter 2, basics

[Функциональное программирование на языке Haskell / Денис Москвин / stepik](https://stepik.org/course/75/syllabus?next=)

## chapter 2.1, параметрический полиморфизм

https://stepik.org/lesson/8417/step/1?unit=1555

### 2.1.2 полиморфизм функций

Функция полиморфна: если может быть применена к значениям разных типов.
Сложение: полиморфный оператор, может складывать как целые, так и дробные числа.

Два типа полиморфизма функций: параметрический, специальный.
Параметричекий: код функции одинаков для всех подходящих типов.
Специальный: для каждого типа внутри своя реализация.

Оператор сложения: специальный полиморфизм, реализация сложения для разных типов разная.

Примеры параметрически полиморфных функций
```hs
ghci> let id x = x

-- используется "переменная типа": `p`, с маленькой буквы. Хотя типы всегда с большой.
-- означает "любой тип".
ghci> :t id
id :: p -> p

ghci> :t id id 4
id id 4 :: Num t => t

ghci> :t (id id)
(id id) :: p -> p
-- многословное обьяснение: как p -> p, где p = p -> p, т.е. p -> p -> p -> p
-- превратился в p -> p
-- "при применении функции арность уменьшается на единицу" ...
-- (p -> p) -> (p -> p)
-- ~> (p -> p) -> p -> p
-- ~> p -> p
ghci> :t id id 
id id :: p -> p

-- п.п. функция двух аргументов
let k x y = -- мы ничего не знаме про типы аргументов и можем только комбинировать их по разному в выходе:
    x -- или
    y -- или ...
    (x, y)
    (y, x)
    x y
    y x
-- I wonder, term "combinators" have to do smth. with it?
-- комбинаторы: функции без свободных переменных.

ghci> let k x y = x
ghci> :t k
k :: p1 -> p2 -> p1 -- всегда первый параметр, любого типа (переменная типа)

-- стандартная функ. позволяет создавать функции возвращающие заданную константу
ghci> :t const
const :: a -> b -> a

ghci> let constTrue = const True
ghci> :t constTrue 
constTrue :: b -> Bool
ghci> constTrue "foo"
True

-- функция возвращает "любой" тип, поэтому может проходить проверку типов в любом выражении
ghci> :t undefined
undefined :: GHC.Stack.Types.HasCallStack => a
-- константа undefined населяет любой допустимый тип
-- обладает наивысшей степенью полиморфизма
```
repl

```hs
-- Напишите функцию трех аргументов `getSecondFrom`,
-- полиморфную по каждому из них,
-- которая полностью игнорирует первый и третий аргумент, а возвращает второй.
-- Укажите ее тип.

GHCi> getSecondFrom True 'x' "Hello"
'x'
GHCi> getSecondFrom 'x' 42 True 
42

getSecondFrom :: a -> b -> c -> b
getSecondFrom a b c = b

-- Сколько разных всегда завершающихся функций с типом `a -> a -> b -> a -> a` можно реализовать?
-- Две функции одинаковой арности считаются разными,
-- если существует набор значений их аргументов, на котором они дают разные результирующие значения.
3
-- почему? Функция 4 аргументов, три из них а. Возвращает а.
-- Сколько вариантов вернуть а? 3
-- речь про типы, конкретные значения могут быть и одинаковые.
```
test

### 2.1.5 полиморфизм функций

https://stepik.org/lesson/8417/step/5?unit=1555

Указывая конкретный тип мы ограничиваем полиморфизм
```hs
-- мономорфная функ. - только один тип, в отличие от полиморфной `id` с такой же реализацией
mono :: Char -> Char
mono x = x

-- частично ограниченнй полиморфизм
-- функ. полиморфна по второму аргументу, мономорфна по первому
semiMono :: Char -> a -> Char
semiMono x y = x

-- при выводе типов Хаскел выводит наиболее общий тип из возможных.
ghci> semiMono x y = x
ghci> :t semiMono 
semiMono :: p1 -> p2 -> p1 -- переменные типа: любые типы
```
repl

Аппликативная структура в правой части (определения функ.) дает набор уравнений.
Любое применение `x -> y` говорит о том, что справа тип любой а слева стрелочный.

> A Hindley–Milner (HM) type system is a classical type system for the lambda calculus with parametric polymorphism.
It is also known as Damas–Milner or Damas–Hindley–Milner.
https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
https://web.cecs.pdx.edu/~mpj/thih/

### 2.1.6 функции высших порядков

https://stepik.org/lesson/8417/step/6?unit=1555

Функ. высшего порядка: аргумент это функция.
Например: оператор `$`
```hs
-- принимает функцию одного аргумента, возвращает функ. одного аргумента
-- читается как: оператор это функция двух аргументов (две стрелочки в определении),
-- под капотом применяет первый аргумент ко второму
-- можно прочитать так: принимает функ. одного аргумента, возвращает функ. одного аргумента
ghci> :i ($)
($) :: (a -> b) -> a -> b       -- Defined in ‘GHC.Base’
infixr 0 $

-- другой интересный пример функ. высшего порядка, требует совпадения типа у входа и выхода функц. f
-- ибо f применяется к результату своего применения
ghci> apply2 f x = f $ f x
ghci> :t apply2
-- принимает функ. одного аргумента, возвращает функ. одного аргумента (полученная ф. реализует двойной апплай)
-- т.е. мы модифицировали поведение принятой ф.
apply2 :: (a -> a) -> a -> a
ghci>
-- что в оригинале было как
ghci> apply2 f x = f (f x)
ghci> :t apply2
apply2 :: (t -> t) -> t -> t

-- правое сечение оператора +, дает функ. `+ 5`
-- двойное применение `+5` к 22 = 32
ghci> apply2 (+ 5) 22
32

-- аналогично с правым сеченим оператора конкатенации
ghci> apply2 (++ "AB") "CD"
"CDABAB"

-- полезная функ. высшего порядка: `flip`
-- переворачивает порядок параметров в применении функ. `f`
flip f x y = f y x

-- пример: перевернуть порядок операндов в делении (оператор вызван как функ., в префиксном виде)
ghci> flip (/) 4 2
0.5
ghci> (/) 4 2
2.0

ghci> flip const 5 True
True
ghci> const 5 True
5

-- принимает функ. двух аргументов, возвращает функцию (двух аргументов в перевернутом порядке)
ghci> :t flip
flip :: (a -> b -> c) -> b -> a -> c

-- получена ф. которая принимает два аргумента, возвращает второй
ghci> :t flip const
flip const :: b -> c -> c
```
repl

```hs
{-- 
В модуле `Data.Function` определена полезная функция высшего порядка
Она принимает четыре аргумента: бинарный оператор с однотипными аргументами b,
функцию f :: a -> b,
и два значения типа a.

Функция on применяет f дважды к двум значениям типа a и передает результат в бинарный оператор.
--} 

-- op: функ. двух аргументов типа б, возвращает тип ц.
-- f: функ. одного аргумента типа а, возвращает тип б.
-- х и у: два аргумента типа а.
-- на выходе значение типа ц.
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
on op f x y = f x `op` f y
-- f(x) op f(y) -- выполняет оператор на результате применения ф. к двум значениям х, у
-- возвращает результат выполнения оператора `op`, type c.
-- e.g. op: (+); f: charToDigit; (x, y): ('1', '3') = charToDigit '1' + charToDigit '3' = 4
-- т.е. операция над двумя преобразованными значениями

-- Используя on можно, например, записать функцию суммирования квадратов аргументов так:
sumSquares = (+) `on` (^2) -- выполнить + на результатах возведения-в-квадрат

-- Функция `multSecond`, перемножающая вторые элементы пар, реализована следующим образом
multSecond = g `on` h -- выполнить * на результатах выбора-второго-элемента-пары
g = undefined
h = undefined

-- Напишите реализацию функций g и h.
GHCi> multSecond ('A',2) ('E',7)
14

-- pointless style
import Data.Function
multSecond = g `on` h
g = (*)
h = snd
```
test

### 2.1.8 анонимные функции, lambda

Лямды, что это, зачем они?
```hs
-- не-замкнутое выражение, имеем свободную переменную х
2 * x + 7
-- чтобы превратить это в валидное выражение, надо абстрагироваться по х, или связать х
let f x = 2 * x + 7

-- можем связать х с помощью лямбда-выражения, которое не связано с именем
ghci> :t \x -> 2 * x + 7
\x -> 2 * x + 7 :: Num a => a -> a -- функция а в а при условии, что а это Num

-- применим лямбда-выражение к числу 10
ghci> (\x -> 2 * x + 7) 10
27

-- определили именованную функцию через лямбда-выражение
ghci> let f = \x -> 2 * x + 7
ghci> :t f
f :: Num a => a -> a
ghci> f 10
27

-- как быть с двумя параметрами?
-- пример, функция двух параметров, как выразить через лямбду?
let lenVec x y = sqrt $ x^2 + y^2
-- вытащим в лямбду один параметр
let lenVec x = \y -> sqrt $ x^2 + y^2
-- вытащили второй параметр (бесплатное каррирование впридачу)
let lenVec = \x -> \y -> sqrt $ x^2 + y^2
-- есть синтаксический сахар для такой записи нескольких лямбд
let lenVec = \x y -> sqrt $ x^2 + y^2 -- подсахаренное определение
ghci> lenVec 3 4
5.0

-- демонстрация удобства лямбд
let p1 = ((1,2),(3,4))
let p2 = ((3,4),(5,6))
-- хотим суммировать первые элементы первых пар
-- доступ к элементу
fst $ fst p1
-- итого
sumFstFst = (+) `on` (\pp -> fst $ fst pp) -- применить + к экстрагированному-первому-элементу-первого-элемента
-- для двух ожидаемых но не указанных явно параметров типа пара пар

-- получилось лаконичнее, чем
sumFstFst = (+) `on` firstFromFirst where firstFromFirst pp = fst $ fst pp

```
repl

Лямбды используются в применениях функ. высших порядков (HOF), где короткое определение функ. через лямбду
удобнее выноса именованной функц. в доступный скоуп.

```hs
{--
Реализуйте функцию `on3`, имеющую семантику, схожую с `on`,
но принимающую в качестве первого аргумента трехместную функцию:
--}
on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = undefined

-- Например, сумма квадратов трех чисел может быть записана с использованием `on3` так
GHCi> let sum3squares = (\x y z -> x+y+z) `on3` (^2)
GHCi> sum3squares 1 2 3
14

on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = op (f x)( f y) (f z)
```
test

## chapter 2.2, параметрический полиморфизм (продолжение)

https://stepik.org/lesson/12398/step/1?unit=2828

### 2.2.2 композиция двух полиморфных функций, оператор (.)

Комбинатор? Оператор композиции функций `.`
```hs
-- хотим ф. высшего порядка, которая берет f, g и возвращает \x -> f $ g x -- f (g x)
-- как это будет по типам?
x :: a
g :: a -> b
f :: b -> c
-- хотим функцию, превращающую `a -> c` с помощью f, g
-- т.е. лямбда по х должна быть такой:
\x -> f (g x) :: a -> c
-- осталось абстрагироваться по f, g
let compose f g = \x -> f (g x)
ghci> :t compose 
compose :: (t1 -> t2) -> (t3 -> t1) -> t3 -> t2

-- dot operator, правая ассоциативность, чуть слабее применения функций
ghci> :i (.)
(.) :: (b -> c) -> (a -> b) -> a -> c   -- Defined in ‘GHC.Base’
infixr 9 .

-- как это можно использовать? Пример:
-- было
sumFstFst = (+) `on` (\pp -> fst $ fst pp) -- применить + к экстрагированному-первому-элементу-первого-элемента
-- стало
sumFstFst = (+) `on` (fst . fst)
-- как выглядит тип экстрактора первого элемента первой пары
ghci> :t (fst . fst)
-- а так это работает
ghci> (fst . fst) ((1, 2), (3, 4))
1

-- забавно, как с помощью оператора . можно сделать определение ф. в pointfree style
foo x = f (g (h x)) = f ((g . h) x) = (f . (g . h)) x
foo = f . (g . h) -- правая ассоциативность?
-- при условии, что типы сочетаются

```
repl

Может так выйти, что программа будет не только лаконичнее, но и эффективнее.
Stay tuned.

```hs
{--
Функция одной переменной `doItYourself` выбирает наибольшее из переданного ей аргумента и числа `42`
затем возводит результат выбора в куб
вычисляет логарифм по основанию `2` от полученного числа `logBase 2 x`
doItYourself = f . g . h

Напишите реализации функций `f`, `g` и `h`
Постарайтесь сделать это в бесточечном стиле
--}

doItYourself 42 -- 16.176952268336283

doItYourself = f . g . h
h = max 42 -- 1) наибольшее из переданного ей аргумента и числа `42`
g = (^ 3) -- 2) затем возводит результат выбора в куб
f = logBase 2 -- 3) вычисляет логарифм по основанию `2` от полученного числа `logBase 2 x`
```
test

### 2.2.4 параметрический полиморфизм кортежей и списков

https://stepik.org/lesson/12398/step/4?unit=2828

Списки полиморфны по типу элементов
```hs
-- полиморфизм списка как типа данных: любой тип даем в конструктор списка, получаем нужный список
-- list of bool values
ghci> :t [True, False]
[True, False] :: [Bool]
-- list of values of other types
ghci> :t ['c', 'h']
['c', 'h'] :: [Char]

-- пустой список это список любого типа (неопределенного)
ghci> :t []
[] :: [a]

-- полиморфизм списков отражается в полиморфизме операций над списками
-- два списка в результ.список
ghci> :t (++)
(++) :: [a] -> [a] -> [a] -- переменная типа `a`, любой тип

-- элем и список в результ. список
ghci> :t (:)
(:) :: a -> [a] -> [a]

-- what about tuples?
-- кортежи имеют более высокую степень полиморфизма чем списки
-- на нам нужен конструктор кортежей, альтернативный
-- смешанный стиль, mixfix
(True, 42)

-- конструктор кортежа из двух элементов: берем два элемента и возвращаем пару
-- префиксный стиль, prefix
ghci> :t (,)
(,) :: a -> b -> (a, b)
-- полиморфен по двум параметрам, степень полиморфизма выше чем у списка

ghci> (,) True 'c'
(True,'c')

-- уменьшение степени полиморфизма, накладывание ограничения
ghci> let dup x = (x, x)
ghci> :t dup
dup :: b -> (b, b)
-- кортеж всегда содержит значения одного типа

-- полиморфизм кортежей отражается в полиморфизме операций с кортежами
ghci> :t fst
fst :: (a, b) -> a
ghci> :t snd
snd :: (a, b) -> b
-- не конкретные типы а переменные типов (любые типы)
```
repl

```hs
-- Сколько разных всегда завершающихся функций с типом
a -> (a, b) -> a -> (b, a, a)
-- можно реализовать?

{--
три стрелочки = три аргумента:
- значение типа а
- пара типов (а, б)
- значение типа а
возвращает пару типов (б, а, а)

на входе три а и один б,
с б проблем нет, он один.
из 3 а можно выбрать 3 разных пары а,
и каждая пара может иметь 2 варианта порядка,
итого 6 комбинаций а на выхоже при 3 а на входе.
Но выходные значения а могут повторяться.
Руками перебрал все варианты:
123:
    11
    12
    13
    22
    21
    23
    33
    31
    32
--}
9

-- 'a' в каждом из 3-ех аргументов и в 2-ух местах результата. 'b' в одном аргументе - тут вариантов нет. Итого 3 в степени 2 равно 9
-- 3 умножил на 3(три аргумента и 3 разных решений)
-- используем формулу размещений с повторениями: A2/3 = 3^2
```
test

### 2.2.6

https://stepik.org/lesson/12398/step/6?unit=2828
