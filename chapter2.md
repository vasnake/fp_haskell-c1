# FP Haskell, chapter 2, basics

[Функциональное программирование на языке Haskell / Денис Москвин / stepik](https://stepik.org/course/75/syllabus?next=)

## chapter 2.1, параметрический полиморфизм

https://stepik.org/lesson/8417/step/1?unit=1555

### 2.1.2 полиморфизм функций

Функция полиморфна: если может быть применена к значениям разных типов.
Сложение: полиморфный оператор, может складывать как целые, так и дробные числа.

Два типа полиморфизма функций: параметрический, специальный.
Параметричекий: код функции одинаков для всех подходящих типов.
Специальный: для каждого типа внутри своя реализация.

Оператор сложения: специальный полиморфизм, реализация сложения для разных типов разная.

Примеры параметрически полиморфных функций
```hs
ghci> let id x = x

-- используется "переменная типа": `p`, с маленькой буквы. Хотя типы всегда с большой.
-- означает "любой тип".
ghci> :t id
id :: p -> p

ghci> :t id id 4
id id 4 :: Num t => t

ghci> :t (id id)
(id id) :: p -> p
-- многословное обьяснение: как p -> p, где p = p -> p, т.е. p -> p -> p -> p
-- превратился в p -> p
-- "при применении функции арность уменьшается на единицу" ...
-- (p -> p) -> (p -> p)
-- ~> (p -> p) -> p -> p
-- ~> p -> p
ghci> :t id id 
id id :: p -> p

-- п.п. функция двух аргументов
let k x y = -- мы ничего не знаме про типы аргументов и можем только комбинировать их по разному в выходе:
    x -- или
    y -- или ...
    (x, y)
    (y, x)
    x y
    y x
-- I wonder, term "combinators" have to do smth. with it?
-- комбинаторы: функции без свободных переменных.

ghci> let k x y = x
ghci> :t k
k :: p1 -> p2 -> p1 -- всегда первый параметр, любого типа (переменная типа)

-- стандартная функ. позволяет создавать функции возвращающие заданную константу
ghci> :t const
const :: a -> b -> a

ghci> let constTrue = const True
ghci> :t constTrue 
constTrue :: b -> Bool
ghci> constTrue "foo"
True

-- функция возвращает "любой" тип, поэтому может проходить проверку типов в любом выражении
ghci> :t undefined
undefined :: GHC.Stack.Types.HasCallStack => a
-- константа undefined населяет любой допустимый тип
-- обладает наивысшей степенью полиморфизма
```
repl

```hs
-- Напишите функцию трех аргументов `getSecondFrom`,
-- полиморфную по каждому из них,
-- которая полностью игнорирует первый и третий аргумент, а возвращает второй.
-- Укажите ее тип.

GHCi> getSecondFrom True 'x' "Hello"
'x'
GHCi> getSecondFrom 'x' 42 True 
42

getSecondFrom :: a -> b -> c -> b
getSecondFrom a b c = b

-- Сколько разных всегда завершающихся функций с типом `a -> a -> b -> a -> a` можно реализовать?
-- Две функции одинаковой арности считаются разными,
-- если существует набор значений их аргументов, на котором они дают разные результирующие значения.
3
-- почему? Функция 4 аргументов, три из них а. Возвращает а.
-- Сколько вариантов вернуть а? 3
-- речь про типы, конкретные значения могут быть и одинаковые.
```
test

### 2.1.5 полиморфизм функций

https://stepik.org/lesson/8417/step/5?unit=1555

Указывая конкретный тип мы ограничиваем полиморфизм
```hs
-- мономорфная функ. - только один тип, в отличие от полиморфной `id` с такой же реализацией
mono :: Char -> Char
mono x = x

-- частично ограниченнй полиморфизм
-- функ. полиморфна по второму аргументу, мономорфна по первому
semiMono :: Char -> a -> Char
semiMono x y = x

-- при выводе типов Хаскел выводит наиболее общий тип из возможных.
ghci> semiMono x y = x
ghci> :t semiMono 
semiMono :: p1 -> p2 -> p1 -- переменные типа: любые типы
```
repl

Аппликативная структура в правой части (определения функ.) дает набор уравнений.
Любое применение `x -> y` говорит о том, что справа тип любой а слева стрелочный.

> A Hindley–Milner (HM) type system is a classical type system for the lambda calculus with parametric polymorphism.
It is also known as Damas–Milner or Damas–Hindley–Milner.
https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
https://web.cecs.pdx.edu/~mpj/thih/

### 2.1.6 функции высших порядков

https://stepik.org/lesson/8417/step/6?unit=1555

Функ. высшего порядка: аргумент это функция.
Например: оператор `$`
```hs
-- принимает функцию одного аргумента, возвращает функ. одного аргумента
-- читается как: оператор это функция двух аргументов (две стрелочки в определении),
-- под капотом применяет первый аргумент ко второму
-- можно прочитать так: принимает функ. одного аргумента, возвращает функ. одного аргумента
ghci> :i ($)
($) :: (a -> b) -> a -> b       -- Defined in ‘GHC.Base’
infixr 0 $

-- другой интересный пример функ. высшего порядка, требует совпадения типа у входа и выхода функц. f
-- ибо f применяется к результату своего применения
ghci> apply2 f x = f $ f x
ghci> :t apply2
-- принимает функ. одного аргумента, возвращает функ. одного аргумента (полученная ф. реализует двойной апплай)
-- т.е. мы модифицировали поведение принятой ф.
apply2 :: (a -> a) -> a -> a
ghci>
-- что в оригинале было как
ghci> apply2 f x = f (f x)
ghci> :t apply2
apply2 :: (t -> t) -> t -> t

-- правое сечение оператора +, дает функ. `+ 5`
-- двойное применение `+5` к 22 = 32
ghci> apply2 (+ 5) 22
32

-- аналогично с правым сеченим оператора конкатенации
ghci> apply2 (++ "AB") "CD"
"CDABAB"

-- полезная функ. высшего порядка: `flip`
-- переворачивает порядок параметров в применении функ. `f`
flip f x y = f y x

-- пример: перевернуть порядок операндов в делении (оператор вызван как функ., в префиксном виде)
ghci> flip (/) 4 2
0.5
ghci> (/) 4 2
2.0

ghci> flip const 5 True
True
ghci> const 5 True
5

-- принимает функ. двух аргументов, возвращает функцию (двух аргументов в перевернутом порядке)
ghci> :t flip
flip :: (a -> b -> c) -> b -> a -> c

-- получена ф. которая принимает два аргумента, возвращает второй
ghci> :t flip const
flip const :: b -> c -> c
```
repl

```hs
{-- 
В модуле `Data.Function` определена полезная функция высшего порядка
Она принимает четыре аргумента: бинарный оператор с однотипными аргументами b,
функцию f :: a -> b,
и два значения типа a.

Функция on применяет f дважды к двум значениям типа a и передает результат в бинарный оператор.
--} 

-- op: функ. двух аргументов типа б, возвращает тип ц.
-- f: функ. одного аргумента типа а, возвращает тип б.
-- х и у: два аргумента типа а.
-- на выходе значение типа ц.
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
on op f x y = f x `op` f y
-- f(x) op f(y) -- выполняет оператор на результате применения ф. к двум значениям х, у
-- возвращает результат выполнения оператора `op`, type c.
-- e.g. op: (+); f: charToDigit; (x, y): ('1', '3') = charToDigit '1' + charToDigit '3' = 4
-- т.е. операция над двумя преобразованными значениями

-- Используя on можно, например, записать функцию суммирования квадратов аргументов так:
sumSquares = (+) `on` (^2) -- выполнить + на результатах возведения-в-квадрат

-- Функция `multSecond`, перемножающая вторые элементы пар, реализована следующим образом
multSecond = g `on` h -- выполнить * на результатах выбора-второго-элемента-пары
g = undefined
h = undefined

-- Напишите реализацию функций g и h.
GHCi> multSecond ('A',2) ('E',7)
14

-- pointless style
import Data.Function
multSecond = g `on` h
g = (*)
h = snd
```
test

### 2.1.8 анонимные функции, lambda

Лямды, что это, зачем они?
```hs
-- не-замкнутое выражение, имеем свободную переменную х
2 * x + 7
-- чтобы превратить это в валидное выражение, надо абстрагироваться по х, или связать х
let f x = 2 * x + 7

-- можем связать х с помощью лямбда-выражения, которое не связано с именем
ghci> :t \x -> 2 * x + 7
\x -> 2 * x + 7 :: Num a => a -> a -- функция а в а при условии, что а это Num

-- применим лямбда-выражение к числу 10
ghci> (\x -> 2 * x + 7) 10
27

-- определили именованную функцию через лямбда-выражение
ghci> let f = \x -> 2 * x + 7
ghci> :t f
f :: Num a => a -> a
ghci> f 10
27

-- как быть с двумя параметрами?
-- пример, функция двух параметров, как выразить через лямбду?
let lenVec x y = sqrt $ x^2 + y^2
-- вытащим в лямбду один параметр
let lenVec x = \y -> sqrt $ x^2 + y^2
-- вытащили второй параметр (бесплатное каррирование впридачу)
let lenVec = \x -> \y -> sqrt $ x^2 + y^2
-- есть синтаксический сахар для такой записи нескольких лямбд
let lenVec = \x y -> sqrt $ x^2 + y^2 -- подсахаренное определение
ghci> lenVec 3 4
5.0

-- демонстрация удобства лямбд
let p1 = ((1,2),(3,4))
let p2 = ((3,4),(5,6))
-- хотим суммировать первые элементы первых пар
-- доступ к элементу
fst $ fst p1
-- итого
sumFstFst = (+) `on` (\pp -> fst $ fst pp) -- применить + к экстрагированному-первому-элементу-первого-элемента
-- для двух ожидаемых но не указанных явно параметров типа пара пар

-- получилось лаконичнее, чем
sumFstFst = (+) `on` firstFromFirst where firstFromFirst pp = fst $ fst pp

```
repl

Лямбды используются в применениях функ. высших порядков (HOF), где короткое определение функ. через лямбду
удобнее выноса именованной функц. в доступный скоуп.

```hs
{--
Реализуйте функцию `on3`, имеющую семантику, схожую с `on`,
но принимающую в качестве первого аргумента трехместную функцию:
--}
on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = undefined

-- Например, сумма квадратов трех чисел может быть записана с использованием `on3` так
GHCi> let sum3squares = (\x y z -> x+y+z) `on3` (^2)
GHCi> sum3squares 1 2 3
14

on3 :: (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
on3 op f x y z = op (f x)( f y) (f z)
```
test

## chapter 2.2, параметрический полиморфизм (продолжение)

https://stepik.org/lesson/12398/step/1?unit=2828

### 2.2.2 композиция двух полиморфных функций, оператор (.)

Комбинатор? Оператор композиции функций `.`
```hs
-- хотим ф. высшего порядка, которая берет f, g и возвращает \x -> f $ g x -- f (g x)
-- как это будет по типам?
x :: a
g :: a -> b
f :: b -> c
-- хотим функцию, превращающую `a -> c` с помощью f, g
-- т.е. лямбда по х должна быть такой:
\x -> f (g x) :: a -> c
-- осталось абстрагироваться по f, g
let compose f g = \x -> f (g x)
ghci> :t compose 
compose :: (t1 -> t2) -> (t3 -> t1) -> t3 -> t2

-- dot operator, правая ассоциативность, чуть слабее применения функций
ghci> :i (.)
(.) :: (b -> c) -> (a -> b) -> a -> c   -- Defined in ‘GHC.Base’
infixr 9 .

-- как это можно использовать? Пример:
-- было
sumFstFst = (+) `on` (\pp -> fst $ fst pp) -- применить + к экстрагированному-первому-элементу-первого-элемента
-- стало
sumFstFst = (+) `on` (fst . fst)
-- как выглядит тип экстрактора первого элемента первой пары
ghci> :t (fst . fst)
-- а так это работает
ghci> (fst . fst) ((1, 2), (3, 4))
1

-- забавно, как с помощью оператора . можно сделать определение ф. в pointfree style
foo x = f (g (h x)) = f ((g . h) x) = (f . (g . h)) x
foo = f . (g . h) -- правая ассоциативность?
-- при условии, что типы сочетаются

```
repl

Может так выйти, что программа будет не только лаконичнее, но и эффективнее.
Stay tuned.

```hs
{--
Функция одной переменной `doItYourself` выбирает наибольшее из переданного ей аргумента и числа `42`
затем возводит результат выбора в куб
вычисляет логарифм по основанию `2` от полученного числа `logBase 2 x`
doItYourself = f . g . h

Напишите реализации функций `f`, `g` и `h`
Постарайтесь сделать это в бесточечном стиле
--}

doItYourself 42 -- 16.176952268336283

doItYourself = f . g . h
h = max 42 -- 1) наибольшее из переданного ей аргумента и числа `42`
g = (^ 3) -- 2) затем возводит результат выбора в куб
f = logBase 2 -- 3) вычисляет логарифм по основанию `2` от полученного числа `logBase 2 x`
```
test

### 2.2.4 параметрический полиморфизм кортежей и списков

https://stepik.org/lesson/12398/step/4?unit=2828

Списки полиморфны по типу элементов
```hs
-- полиморфизм списка как типа данных: любой тип даем в конструктор списка, получаем нужный список
-- list of bool values
ghci> :t [True, False]
[True, False] :: [Bool]
-- list of values of other types
ghci> :t ['c', 'h']
['c', 'h'] :: [Char]

-- пустой список это список любого типа (неопределенного)
ghci> :t []
[] :: [a]

-- полиморфизм списков отражается в полиморфизме операций над списками
-- два списка в результ.список
ghci> :t (++)
(++) :: [a] -> [a] -> [a] -- переменная типа `a`, любой тип

-- элем и список в результ. список
ghci> :t (:)
(:) :: a -> [a] -> [a]

-- what about tuples?
-- кортежи имеют более высокую степень полиморфизма чем списки
-- на нам нужен конструктор кортежей, альтернативный
-- смешанный стиль, mixfix
(True, 42)

-- конструктор кортежа из двух элементов: берем два элемента и возвращаем пару
-- префиксный стиль, prefix
ghci> :t (,)
(,) :: a -> b -> (a, b)
-- полиморфен по двум параметрам, степень полиморфизма выше чем у списка

ghci> (,) True 'c'
(True,'c')

-- уменьшение степени полиморфизма, накладывание ограничения
ghci> let dup x = (x, x)
ghci> :t dup
dup :: b -> (b, b)
-- кортеж всегда содержит значения одного типа

-- полиморфизм кортежей отражается в полиморфизме операций с кортежами
ghci> :t fst
fst :: (a, b) -> a
ghci> :t snd
snd :: (a, b) -> b
-- не конкретные типы а переменные типов (любые типы)
```
repl

```hs
-- Сколько разных всегда завершающихся функций с типом
a -> (a, b) -> a -> (b, a, a)
-- можно реализовать?

{--
три стрелочки = три аргумента:
- значение типа а
- пара типов (а, б)
- значение типа а
возвращает пару типов (б, а, а)

на входе три а и один б,
с б проблем нет, он один.
из 3 а можно выбрать x разных пар а:
Две позиции, три варианта для каждой позиции: 3 * 3 (8 бит это 2^8, не так ли?)
--}
9

-- > 'a' в каждом из 3-ех аргументов и в 2-ух местах результата. 'b' в одном аргументе - тут вариантов нет. Итого 3 в степени 2 равно 9
-- > 3 умножил на 3(три аргумента и 3 разных решений)
-- > используем формулу размещений с повторениями: A2/3 = 3^2
```
test

### 2.2.6 curry, uncurry

https://stepik.org/lesson/12398/step/6?unit=2828

Частичное применение функции, пример: ф. двух аргументов примененная к первому аргументу дает ф. одного аргумента.

Ф. с аргуметом типа кортеж: `f (a,b)` выглядит как функция двух аргументов.
Это можно исправить, комбинируя такую ф. с ф. высшего порядка `curry`
```hs
ghci> import Data.Function 
-- оператор on хочет каррированную функцию в первом параметре (выполнить бинарную оп. над результатом преобразований двх аргументов)
ghci> :t on
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c

-- попробуем скормить ему не-каррированную ф.
ghci> :t fst
fst :: (a, b) -> a

-- ошибка, типы не матчатся
ghci> :t fst `on` (^2)
<interactive>:1:1: error:
    • Couldn't match type ‘a’ with ‘(a, b) -> c’

-- каррируем ф. fst (теперь типы матчатся)
ghci> :t curry fst `on` (^2)
curry fst `on` (^2) :: Num c => c -> c -> c

-- другой пример, не-каррированная ф. avg
{ avg :: (Double, Double) -> Double; avg p = (fst p + snd p) / 2 }
ghci> :t curry avg `on` (^2)
curry avg `on` (^2) :: Double -> Double -> Double
-- среднее двух квадратов

-- как реализовать curry?
let curry f x y = f (x, y)
-- карри должен вызвать ф. на паре, поэтому создаем из параметров пару и применяем не-каррированню ф. к паре
-- карри: функция трех аргументов: функция из пары в ц, значения а и б. На выходе ц.
ghci> :t curry
curry :: ((a, b) -> c) -> a -> b -> c
-- можно прочитать так: берет функцию из пары в ц `(a, b) -> c`
-- возвращает каррированную функцию `a -> b -> c`

-- есть обратная ф.: два аргумента: функция двух аргуметов и пара. Возвращает ц.
ghci> :t uncurry
uncurry :: (a -> b -> c) -> (a, b) -> c
-- можно прочитать как: берет функцию двух аргуметов `a -> b -> c`
-- возвращает функцию одного аргумента `(a, b) -> c`
```
repl

```hs
-- Какому известному вам библиотечному оператору, конструктору или функции эквивалентно выражение `curry id`?
(,)
-- почему?
-- посмотрим, что происходит при применении curry к id
ghci> :t id
id :: a -> a
ghci> :t curry
curry :: ((a, b) -> c) -> a -> b -> c
-- первый аргумент карри это функция из пары в ц.
-- id это функция из xz -> xz
-- получается, xz должно быть парой, чтобы матчинг сработал
-- id от пыры это пара, получаем конструктор пары.

-- Какому известному вам библиотечному оператору, конструктору или функции эквивалентно выражение
uncurry (flip const)
-- answer:
snd
{-
Почему?
Посмотрим, что происходит при применении flip const:
конст берет два аргумента и выдает первый.
Флип берет ф. двух аргументов и возвращает ф. двух аргументов (с другим порядком аргументов).
Значит, флип конст вернет функцию конст с переставленными аргументами.
Анкарри к этой функции двух аргументов дает эту ф. но с аргументами завернутыми в пару.
Получаем функцию из пары в ...
-}
ghci> :t const
const :: a -> b -> a

ghci> :t flip
flip :: (a -> b -> c) -> b -> a -> c

ghci> :t uncurry
uncurry :: (a -> b -> c) -> (a, b) -> c

-- В модуле `Data.Tuple` стандартной библиотеки определена функция `swap :: (a,b) -> (b,a)`, переставляющая местами элементы пары:
GHCi> swap (1,'A')
('A',1)
-- Эта функция может быть выражена в виде:
swap = f (g h)
-- т.е. выразим эту функцию в виде трех, f . g . h
-- где f, g и h — некоторые идентификаторы из следующего набора: 
-- curry uncurry flip (,) const
-- Укажите через запятую подходящую тройку f,g,h
uncurry,flip,(,)
{-
Почему?
Чтобы перевернуть пару, очевидно, нужно:
flip, конструктор пары и uncurry.
Хотя, если постараться, можно попробовать через curry, const и flip.
Проблема в определении порядка, что к чему применить, чтобы получить функцию-переворачиватель-пары.
Вот тут надо прочувствовать, как работают функции высших порядков.

Например, аналогия с декораторами:
конструктор ничего декорировать не может, это не ФВП.
В качестве декоратора у нас остаются flip и uncurry.
Если конструктор декорировать uncurry, получим функцию, которая из пары делает пару,
ибо uncurry позволяет передать пару в каррированную функцию - конструктор.
Не совсем то, что надо, но близко.
Получаем заворачивание контруктора в флип и уже это заворачиваем в анкарри: пара проходит через анкарри,
попадает как два аргумента во флип, переворачивается и попадает в конструктор.
-}
```
test

## chapter 2.3, typeclass

https://stepik.org/lesson/8420/step/1?unit=1556

### 2.3.2 ad-hoc polymorphism

Говорили про параметрический полиморфизм, где реализация ф. не зависит от типа параметра.
Теперь рассмотрим "специальный" полиморфизм, где тип параметра должен соответствовать определенному интерфейсу (классу типов).
Т.е. должен быть в наличии (контексте) инстанс (экземпляр) реализации этого интерфейса для данного типа параметра.
```hs
-- как выражается требование наличия инстанса класса типов
ghci> :t 7
7 :: Num a => a
-- => это символ "следования", читать надо как-то так:
-- переменная-типа а при условии, что интерфейс Num (класс типов) применяется к а.
-- а имеет полиморфный тип но для этого типа должен быть в наличии интерфейс Num

-- оператор сложения сделан через специальный полиморфизм,
-- параметры полиморфны и требуют чтобы тип относился к классу типов Num
ghci> :t (+)
(+) :: Num a => a -> a -> a

-- typeclass Ord требуется для оператора сравнения
ghci> :t (>)
(>) :: Ord a => a -> a -> Bool

-- для такого сечения оператора требуется более сложный контекст: 
-- параметр должен иметь тип для которого реализованы два интерфейса
ghci> :t (> 7)
(> 7) :: (Ord a, Num a) => a -> Bool

-- можно сравнивать пары, но для этого надо чтобы для обоих частей пары были реализованы указанные интерфейсы
ghci> :t (> (1, 7))
(> (1, 7)) :: (Ord a, Ord b, Num a, Num b) => (a, b) -> Bool

-- теперь можно понять, что нам говорит текст ошибки: в контексте нет реализации (Num Char), которая требуется для умножения на 3
-- т.е. для Char не определена реализация интерфейса Num
ghci> 3 * 'c'
<interactive>:26:1: error:
    • No instance for (Num Char) arising from the literal ‘3’
```
repl

```hs
-- На нехватку какого представителя какого класса типов пожалуется интерпретатор при попытке вывести тип выражения
True + False * False
-- Запишите ответ в виде Имя_класса_типов Имя_типа. Постарайтесь ответить, не используя GHCi.
Num Bool

<interactive>:27:6: error:
     • No instance for (Num Bool) arising from a use of ‘+’
```
test

### 2.3.4 interface

Класс типов задает интерфейс, который конкретные типы могут реализовать.
Набор функций с общим типовым параметром.
Глядя на контекст ф. можно предполагать какие операции внутри используются.
```hs
-- определение тайпкласса (интерфейса)
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
-- параметр типа `a`, в инстансе (реализации) для конкретного типа вместо а будет этот конкретный тип

-- наличие `Eq a =>` в типе функции и говорит нам о требовании принадлежности а к тайпклассу Eq
ghci> :t (==)
(==) :: Eq a => a -> a -> Bool

-- два разных сечения, в одном полиморфизм сохраняется, во втором нет. Почему?
ghci> :t (== 42)
(== 42) :: (Eq a, Num a) => a -> Bool
-- потому что 42 это полиморфный литерал, а 'c' это мономорфный литерал. Тип однозначно определен.
ghci> :t (== 'c')
(== 'c') :: Char -> Bool

-- a должен реализовывать typeclass Eq (чтобы методом сравнения искать элемент в списке)
ghci> :t elem
elem :: (Foldable t, Eq a) => a -> t a -> Bool
-- `t a` можно читать как конструктор типа t, который должен реализовывать тайпкласс фолдабл (список например).
-- Конструктор типа t примененный к типу a даст тип t a, например [] Char -> [Char]
-- Haskell 2010 Language Report, раздел 4.1.2 Syntax of Types говорит,
-- что имена конструкторов типа начинаются с большой буквы (кроме встроенных, типа списка и кортежа).
-- Так что t здесь именно переменная типа.
-- Применение тИповой переменной t (описывающей однопараметрический конструктор типа) к тИповой переменной a
```
repl

```hs
-- Попробуйте, не используя GHCi или Hoogle, определить, какого контекста не хватает в типе функции
-- сортирующей переданный в нее список.
sort :: ? => [d] -> [d]
-- Напишите выражение, которое должно стоять на месте знака вопроса.
(Ord d)
```
test

### 2.3.6 instance, default method

```hs
-- ф. с одинаковыми сигнатурами можно перечислить через запятую (в декларации)
class Eq a where
    (==), (/=) :: a -> a -> Bool
-- экземпляр (instance) тайпкласса, для типа Bool
-- используем паттерн матчинг для имплементации
instance Eq Bool where
    True    == True     = True -- два случая когда результат тру
    False   == False    = True
    _       == _        = False -- в остальный случаях фолс
    x       /= y        = not (x == y) -- определим неравно через равно.

-- что характерно (почему ad-hoc): реализация интерфейса тайпкласса отделена от определения типа бул.
-- Это значит, что мы можем в любое время и в любом месте добавить реализацию любого тайпкласса к любому типу не меняя код типа.

-- дефолтная реализация
-- можно в определение тайпкласса внести дефолтные реализации, если они полиморфны.
-- можно сделать их циклическими относительно друг-друга, тогда конкретная имплементация должна будет хотя бы один метод переопределить.
class Eq a where
    (==), (/=) :: a -> a -> Bool
    x       /= y        = not (x == y)
    x       == y        = not (x /= y)
instance Eq Bool where
    True    == True     = True
    False   == False    = True
    _       == _        = False

-- Minimal Complete Definiton
-- что надо минимально реализовать для имплементации тайпкласса
```
repl

```hs
{--
Реализуйте класс типов `Printable`, предоставляющий один метод `toString`
функцию одной переменной, которая преобразует значение типа, являющегося представителем `Printable`, в строковое представление
Сделайте типы данных `Bool` и `()` (`()`: пустой кортеж) представителями этого класса типов, обеспечив следующее поведение:
--}
GHCi> toString True
"true"
GHCi> toString False
"false"
GHCi> toString ()
"unit type"

class Printable a where
    toString :: a -> String
instance Printable Bool where
    toString True = "true"
    toString _ = "false"
instance Printable () where  
    toString _ = "unit type"
```
test [test-printable](./chapter-2.3/test-printable.hs)

### 2.3.8 полиморфный тайпкласс

Тайпкласс можно определить для полиморфного типа, определив контекст для этого типа
```hs
-- определим тайпкласс экв. для пары, добавив требование
-- (Eq a, Eq b) => 
instance (Eq a, Eq b) => Eq (a,b) where
    (a1, a2) == (b1, b2) = a1 == b1 && a2 == b2

-- Функциональные (стрелочные) типы сравнивать нельзя.
-- Увы, компилятор не знает, что стандартная ф. айди и `ghci> id = (\x -> x)` равны.
ghci> id == (\x -> x)
<interactive>:52:4: error:
    • No instance for (Eq (p0 -> p0)) arising from a use of ‘==’
```
repl

```hs
-- Сделайте тип пары представителем класса типов Printable, реализованного вами в предыдущей задаче, обеспечив следующее поведение:
GHCi> toString (False,())
"(false,unit type)"
GHCi> toString (True,False)
"(true,false)"
-- Объявление класса типов Printable и представителей этого класса для типов () и  Bool заново реализовывать не надо

instance (Printable a, Printable b) => Printable (a, b) where
    toString (a, b) = '(' : toString a ++ ',' : toString b ++ ")"
```
test [test-printable](./chapter-2.3/test-printable.hs)

## 2.4, Стандартные классы типов (typeclass)

https://stepik.org/lesson/12399/step/1?unit=2829

### 2.4.2 class extension

https://stepik.org/lesson/12399/step/2?unit=2829

Расширение тайпкласса.
По сути, это расширение существующего интерфейса новыми методами.
```hs
-- требование к контексту заявлено уже в определении интерфейса,
-- не при реализации а при декларации тайпкласса.
-- Значит, что тип а для участия в тайпклассе Ord должен участвовать в тайпклассе Eq
-- или, тайпкласс Eq расширен в тайпклассе Ord
class (Eq a) => Ord a where
    (<), (<=), (>=), (>) :: a -> a -> Bool
    max, min :: a -> a -> a
    compare :: a -> a -> Ordering
    -- Minimal Complete Definition: either compare or <=
    -- в стдлиб тайпкласс имеет дефолтные методы и для создания инстанса достаточно определить одну из двух функций.

-- порядок определяет 3 значения: меньше, равно, больше
ghci> :i Ordering
type Ordering :: *
data Ordering = LT | EQ | GT

-- допустимо множественное (наследование) расширение
class (Eq a, Printable a) => MyClass a where
```
repl

```hs
{--
Пусть существуют два класса типов `KnownToGork` и `KnownToMork`
которые предоставляют методы `stomp` (`stab`) и `doesEnrageGork` (`doesEnrageMork`) соответственно:
Класса типов `KnownToGorkAndMork` является расширением обоих этих классов, предоставляя дополнительно метод `stompOrStab`:
Задайте реализацию по умолчанию метода `stompOrStab`
которая вызывает метод `stomp`, если переданное ему значение приводит в ярость Морка
вызывает `stab`, если оно приводит в ярость Горка
вызывает сначала `stab`, а потом `stomp`, если оно приводит в ярость их обоих
Если не происходит ничего из вышеперечисленного, метод должен возвращать переданный ему аргумент
--}
class KnownToGork a where
    stomp :: a -> a
    doesEnrageGork :: a -> Bool
class KnownToMork a where
    stab :: a -> a
    doesEnrageMork :: a -> Bool

class (KnownToGork a, KnownToMork a) => KnownToGorkAndMork a where
    stompOrStab :: a -> a
    stompOrStab x
        | eg && em = stomp $ stab x
        | eg = stab x
        | em = stomp x
        | otherwise = x
     where
       eg = (doesEnrageGork x)
       em = (doesEnrageMork x)
```
test

### 2.4.4 Show, Read (serdes)

https://stepik.org/lesson/12399/step/4?unit=2829

```hs
-- тайпкласс Show содержит ф. a -> String
-- Поэтому можно легко сделать печатаемым любой свой тип, просто реализовать тайпкласс Show для своего типа
ghci> :t show
show :: Show a => a -> String

ghci> show (1, 2.0, 'c', True)
"(1,2.0,'c',True)"

-- ф. read полиморфна по возвращаемому значению
ghci> :t read
read :: Read a => String -> a
-- без указания выходного типа ридер падает: полиморфный результат, недостаточно информации для матчинга в конкретный тип
ghci> read "5" :: Int
5
ghci> read "'c'" :: Char
'c'
ghci> read "[1,2,3]" :: [Float]
[1.0,2.0,3.0]
-- с юнитом проблем нет, тут однозначно
ghci> read "()"
()

-- проблема: ф. read читает весь ввод и парсит его весь,
-- нельзя частично прочитать ввод
-- альтернатива:
ghci> :t reads
reads :: Read a => ReadS a
-- конструктор типа, параметризован а, при условии что а это тайпкласс Read
-- функция тотальная, если что не так, получим пустой список,
-- список может содержать разные варианты разбора если есть неоднозначность парсинга
ghci> reads "5 rings" :: [(Int, String)]
[(5," rings")]
ghci> reads "5 rings"
[]
```
repl

```hs
-- Имея функцию 
ip = show a ++ show b ++ show c ++ show d 
-- определите значения a, b, c, d так, чтобы добиться следующего поведения:
GHCi> ip
"127.224.120.12"

a = 127.2
b = 24.1
c = 20.1
d = 2
```
test

### 2.4.6

https://stepik.org/lesson/12399/step/6?unit=2829
