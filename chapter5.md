# FP Haskell, chapter 5, monads

[Функциональное программирование на языке Haskell / Денис Москвин / stepik](https://stepik.org/course/75/syllabus?next=)

[code sandbox](./chapter-5/test-monads.hs)

Мотивация: абстракция и композиция вычислений с эффектами.
Мы хотим тотальные чистые функции и мы хотим модульность и композиционность (собирать сложные решения из простых компонент).
Для обработки эффектов придумали Стрелку Клейсли `a -> m a` и монады (композиция вычислений с контекстом).

definitions
- Functor: тайпкласс с методом `fmap :: (a -> b) -> f a -> f b`
поднимает ф. в контекст, оператор "применения" `<$>`. Структура "контейнера" не меняется.
Законы функтор: 1) `fmap id = id`; 2) `fmap (f . g) = (fmap f) . (fmap g)`

- Monad: тайпкласс с двумя методами
`return :: a -> m a` aka `pure` поднимает значение в монаду, позволяет любую стрелку сделать стрелкой Клейсли `k`.
`bind :: m a -> (a -> m b) -> m b` aka `>>=` оператор монадического связывания вычислений.
Законы монад: 1) левая "единица" pure `(return a) >>= k = k a`; 2) правая "единица" pure `m >>= return = m`; 3) ассоциативность bind `(m >>= k1) >>= k2 = m >>= (\ x -> k1 x >>= k2)`

> (Монад это) Моноид в категории эндофункторов (моноид это бинарная операция и нейтральный элемент, (эндо)функтор это стрелка в контексте).
Т.е. монада композирует (складывает) стрелки в контексте.

> мы используем термин "контейнер" в более широком ... смысле, и можно заменить его на более точный термин - "вычислительный контекст"
> правильней о функторах думать как о естественных конструкциях над типами. Контейнер -- это только пример естественной конструкции

## chapter 5.1, Класс типов (type-class) Functor и законы для него

https://stepik.org/lesson/8432/step/1?unit=2743

- Класс типов Functor
- Представитель класса типов Functor для бинарного дерева
- Представители Functor для двухпараметрических типов
- Законы для функторов

### 5.1.2 тайп-классы для конструкторов типов, Functor, fmap

Если тайп-класс для типа с кайндом `*` осознать довольно легко,
то тайп-класс для "конструктора типов", с кайндом `* -> *`
это абстракция более высокого порядка и 
задает API для (потенциально бесконечного) множества компонент, реализующих этот интерфейс.

Суть такого кайнда в том, что это параметризованный (одним параметром) конструктор типов.
К примеру, список - это конструктор типов, параметризованный типом значений в списке.
Типов списков может быть бесконечно много, если у нас бесконечное количество типов значений.
Но любой список имеет один и тот-же интерфейс, определенный в его классе и его тайп-классах.

Рассмотрим тайп-класс Functor
```hs
-- type-class, полностью полиморфный, без ограничений на типы (переменные типов) a, b, f
-- класс типов параметризован переменной (типа) `f`
class Functor f where
    -- fmap "поднимает" функцию `a -> b` в "контекст" `f`: принимает значение `f a`, на выходе значение `f b`
    -- где `f a`, `f b` это два типа (конструктора), параметризованных а и бе, соответственно.
    -- при этом сам контекст не меняется, нет "эффекта"
    fmap :: (a -> b) -> f a -> f b -- видно, что эф это конструктор типов, ибо "применяется" к а и к бе
-- переменная `f` используется как функция над типами, у нее должен быть "стрелочный кайнд": `* -> *`
-- <$> -- infix synonim for fmap

-- реализация тайп-класса Функтор для списков: очевидная
instance Functor [] where
    fmap = map

ghci> map succ [1,2,3]
[2,3,4]
ghci> fmap succ [1,2,3]
[2,3,4]

ghci> :i fmap
type Functor :: (* -> *) -> Constraint
class Functor f where
  fmap :: (a -> b) -> f a -> f b -- Defined in ‘GHC.Base’

-- правая ассоциативность скобок для стрелочных типов, позволяет сказать:
-- fmap берет функцию над элементами и возвращает функцию над "контейнерами" элементов
(a -> b) -> f a -> f b -- эквивалентно
(a -> b) -> (f a -> f b)
-- demo
ghci> let fs = fmap succ
ghci> :t fs
fs :: (Functor f, Enum b) => f b -> f b
ghci> fs [1,2,3]
[2,3,4]

ghci> fs $ Just 42
Just 43
-- вы чувствуете мощь концепции тайпклассов? До тех пока тип реализует интерфейс, мы можем его использовать в большом наборе операций,
-- понятия не имеющих о конкретике контекста

instance Functor Maybe where -- два конструктора у Maybe, сигнатуры однозначно определяют реализацию
    -- (a -> b) -> f a -> f b
    fmap _ Nothing = Nothing
    fmap f (Just a) = Just (f a)
```
repl

```hs
{--
Определите представителя класса `Functor`
для следующего типа данных
представляющего точку в трёхмерном пространстве

data Point3D a = Point3D a a a deriving Show

GHCi> fmap (+ 1) (Point3D 5 6 7)
Point3D 6 7 8
--}
instance Functor Point3D where
    fmap = undefined

-- solution

instance Functor Point3D where
    -- fmap :: (a -> b) -> f a -> f b
    fmap f (Point3D x y z) = Point3D (f x) (f y) (f z)

-- reference

-- type-class, полностью полиморфный, без ограничений на типы (переменные типов) a, b, f
-- класс типов параметризован переменной (типа) `f`
class Functor f where
    -- fmap "поднимает" функцию `a -> b` в "контекст" `f`: принимает значение `f a`, на выходе значение `f b`
    -- где `f a`, `f b` это два типа (конструктора), параметризованных а и бе, соответственно.
    -- при этом сам контекст не меняется, нет "эффекта"
    fmap :: (a -> b) -> f a -> f b -- видно, что эф это конструктор типов, ибо "применяется" к а и к бе
-- переменная `f` используется как функция над типами, у нее должен быть "стрелочный кайнд": `* -> *`
```
test

```hs
{--
Определите представителя класса `Functor`
для типа данных `GeomPrimitive`

data GeomPrimitive a = Point (Point3D a) | LineSegment (Point3D a) (Point3D a)

При определении, воспользуйтесь тем, что `Point3D` уже является представителем класса `Functor`

GHCi> fmap (+ 1) $ Point (Point3D 0 0 0)
Point (Point3D 1 1 1)

GHCi> fmap (+ 1) $ LineSegment (Point3D 0 0 0) (Point3D 1 1 1)
LineSegment (Point3D 1 1 1) (Point3D 2 2 2)
--}
instance Functor GeomPrimitive where
    fmap = undefined

-- solution

-- data GeomPrimitive a = Point (Point3D a) | LineSegment (Point3D a) (Point3D a) deriving Show
instance Functor GeomPrimitive where
    -- fmap :: (a -> b) -> f a -> f b
    fmap f (Point p) = Point (fmap f p)
    fmap f (LineSegment p1 p2) = LineSegment (fmap f p1) (fmap f p2)

-- reference

-- type-class, полностью полиморфный, без ограничений на типы (переменные типов) a, b, f
-- класс типов параметризован переменной (типа) `f`
class Functor f where
    -- fmap "поднимает" функцию `a -> b` в "контекст" `f`: принимает значение `f a`, на выходе значение `f b`
    -- где `f a`, `f b` это два типа (конструктора), параметризованных а и бе, соответственно.
    -- при этом сам контекст не меняется, нет "эффекта"
    fmap :: (a -> b) -> f a -> f b -- видно, что эф это конструктор типов, ибо "применяется" к а и к бе
-- переменная `f` используется как функция над типами, у нее должен быть "стрелочный кайнд": `* -> *`
-- <$> -- infix synonim for fmap

test = (+ 1) <$> Point3D 5 6 7 -- Point3D 6 7 8
test2 = (+ 1) <$> Point (Point3D 0 0 0) -- Point (Point3D 1 1 1)
test3 = (+ 1) <$> LineSegment (Point3D 0 0 0) (Point3D 1 1 1) -- LineSegment (Point3D 1 1 1) (Point3D 2 2 2)
```
test

### 5.1.5 Functor Tree

Пример: определим функтор для бинарного дерева
```hs
-- дерево: одно-параметрический тип, только такой можно сделать функтором
-- два конструктора (сумма): лист-со-значением, ветвление-со-значением-и-левой-правой-ветками
-- думается, правильнее было бы не Branch а Node
data Tree a = Leaf a | Branch (Tree a) a (Tree a)
    deriving Show
-- `Branch (Tree a) a (Tree a)` это конструктор данных, принимающий три значения левое-дерево, значение-в-узле, правое-дерево

instance Functor Tree where
    -- (a -> b) -> f a -> f b
    fmap fn (Leaf x) = Leaf $ fn x
    fmap fn (Branch left x right) = Branch (fmap fn left) (fn x) (fmap fn right)
-- рекурсивно проходим дерево, сигнатуры однозначно определяют реализацию

testTree = Branch (Leaf 2) 3 (Leaf 4)
ghci> fmap (^2) testTree -- поднимем возведение в квадрат в дерево
Branch (Leaf 4) 9 (Leaf 16)

-- важно: структура "контейнера" не меняется (нет "эффекта"?). Про законы функтора чуть позже ...

-- оператор - синоним fmap
(^2) `fmap` testTree
ghci> (^2) <$> testTree -- лево-ассоциативный, приоритет 4
Branch (Leaf 4) 9 (Leaf 16)

ghci> :i <$>
(<$>) :: Functor f => (a -> b) -> f a -> f b -- Defined in ‘Data.Functor’
infixl 4 <$>

-- левая ассоциативность "применения": +5 применяется к результату ^2
ghci> (+5) <$> (^2) <$> testTree
Branch (Leaf 9) 14 (Leaf 21)

42 <$ testTree -- что-то вроде `const`
Branch (Leaf 42) 42 (Leaf 42) -- сохраняется структура, значение заменяется на переданное
-- поднимает значение (не функцию) в контекст
ghci> :i <$
type Functor :: (* -> *) -> Constraint
class Functor f where
  ...
  (<$) :: a -> f b -> f a -- Defined in ‘GHC.Base’
infixl 4 <$
```
repl

```hs
{--
Определите представителя класса `Functor` для бинарного дерева,
в каждом узле которого хранятся элементы типа `Maybe`

data Tree a = Leaf (Maybe a) | Branch (Tree a) (Maybe a) (Tree a) deriving Show

GHCi> words <$> Leaf Nothing
Leaf Nothing

GHCi> words <$> Leaf (Just "a b")
Leaf (Just ["a","b"])
--}
instance Functor Tree where
    fmap = undefined

-- solution

-- data Tree a = Leaf (Maybe a) | Branch (Tree a) (Maybe a) (Tree a) deriving Show
import Data.Functor
instance Functor Tree where
    -- fmap :: (a -> b) -> f a -> f b
    fmap f (Leaf maybeA) = Leaf (f <$> maybeA)
    fmap f (Branch left maybeA right) = Branch (f <$> left) (f <$> maybeA) (f <$> right)

-- reference

-- type-class, полностью полиморфный, без ограничений на типы (переменные типов) a, b, f
-- класс типов параметризован переменной (типа) `f`
class Functor f where
    -- fmap "поднимает" функцию `a -> b` в "контекст" `f`: принимает значение `f a`, на выходе значение `f b`
    -- где `f a`, `f b` это два типа (конструктора), параметризованных а и бе, соответственно.
    -- при этом сам контекст не меняется, нет "эффекта"
    fmap :: (a -> b) -> f a -> f b -- видно, что эф это конструктор типов, ибо "применяется" к а и к бе
-- переменная `f` используется как функция над типами, у нее должен быть "стрелочный кайнд": `* -> *`
-- <$> -- infix synonim for fmap (Data.Functor)
```
test

### 5.1.7 Функтор для двух-параметрических типов

Как быть с двух-параметрическими типами, вроде `Either` или `(,)` или `->`?
Мы не можем определить одно-параметрический функтор для кайнда `* -> * -> *`, конструктора типов с двумя параметрами.
Надо связать первый параметр
```hs
-- как это сделать для типа Пара (тип-произведение)
instance Functor ((,) s) where
    fmap fn (x, y) = (x, fn y) -- первый элемент пары не трогаем, ко второму применяем функцию
-- связываем первый параметр пары с переменной s, тогда работать функтор будет с вторым значением пары

-- вот так выглядит механика снижения арности у конструктора типов
ghci> :k (,) -- кайнд пары
(,) :: * -> * -> * -- это три звезды: два параметра
ghci> :k (,) Char -- свяжем первый параметр пары с типом Чар
(,) Char :: * -> * -- получим кайнд одно-параметрического конструктора типа

-- посмотрим на тип fmap
(a -> b) -> f a -> f b -- подставим конструктор пары из определения функтора пары
(a -> b) -> (,) s a -> (,) s b -- перепишем префиксный стиль в инфиксном виде
(a -> b) -> (s, a) -> (s, b) -- вот такой результ. тип у fmap для пары со связанным первым параметром

-- пример
ghci> fmap succ (1, 'a')
(1,'b')

-- похожим образом для Either (тип-сумма)
instance Functor (Either e) where
    fmap _ (Left x) = Left x -- левую часть не трогаем, она связана
    fmap fn (Right x) = Right $ fn x -- работаем с правой частью

ghci> :k Either
Either :: * -> * -> *
ghci> :k Either Char
Either Char :: * -> *

-- тип fmap
(a -> b) -> f a -> f b
(a -> b) -> Either e a -> Either e b

-- пример
ghci> fmap (+3) $ Right 39
Right 42
ghci> fmap (+3) $ Left "oops"
Left "oops"

-- функтор для одно-параметрической функции, аналогично
-- но надо определиться с семантикой, что значит "поднять функцию в контекст функции
ghci> :k (->)
(->) :: * -> * -> *

ghci> :k (->) Char
(->) Char :: * -> *

instance Functor ((->) inp) where
    fmap fn inpTo = (\ x -> fn (inpTo x)) -- применим ф. из первого аргумента к результату ф. второго аргумента
    -- контекст: функция-как-функтор, результат ее работы
    fmap f g = f . g -- то есть, сконструированная по сигнатуре функция это просто композиция функций
    fmap = (.)      -- (декорирование) контекста функцией, поднимаемой в контекст
-- т.е. сначала нечто из связанного параметра маппится на "входной параметр функции",
-- потом выполняется функция на этом полученном из контекста параметре
-- где-то здесь рядом ходит монада Read

-- выведем тип фмап для функции-функтора
(a -> b) -> f a -> f b
(a -> b) -> (->) inp a -> (->) inp b
(a -> b) -> (inp -> a) -> (inp -> b)
-- на выходе нужно получить ф. из связанного входа в бэ
-- трансформация `x -> a -> b` при помощи функтора `x -> a` и функции `a -> b`

instance Functor ((->) e) where -- e это environment
    fmap :: (a -> b) -> (e -> a) -> (e -> b)
    fmap = (.)
-- поднимаем ф. a -> b в контекст, где из енва читается а; получаем функцию, где из енва читается бэ

-- пример, поднимем ф. length в контекст "получить-список-из-списка"
ghci> fmap length tail "abc"
2
-- эквивалентно композиции
ghci> length . tail $ "abc"
2

ghci> :t fmap length tail -- результатом должен быть функтор от стрелки (так и есть, функция из списка это функтор)
fmap length tail :: [a] -> Int

-- про наростание арности функции при использовании полиморфизма
fmap :: (a -> b) -> (e -> a) -> (e -> b) -- arity 2
fmap :: (a -> b) -> (e -> a) -> e -> b -- arity 3
-- парамушта внутрениий тип это стрелка, вот она и проявилась
```
repl

```hs
{--
Определите представителя класса `Functor`
для типов данных `Entry` и `Map`

data Entry k1 k2 v = Entry (k1, k2) v  deriving Show
data Map k1 k2 v = Map [Entry k1 k2 v]  deriving Show

Тип Map представляет словарь, ключами которого являются пары

В результате должно обеспечиваться следующее поведение:
`fmap` применяет функцию к значениям в словаре, не изменяя при этом ключи

GHCi> fmap (map toUpper) $ Map []
Map []

GHCi> fmap (map toUpper) $ Map [Entry (0, 0) "origin", Entry (800, 0) "right corner"]
Map [Entry (0,0) "ORIGIN",Entry (800,0) "RIGHT CORNER"]
--}
instance Functor (Entry k1 k2) where
    fmap = undefined

instance Functor (Map k1 k2) where
    fmap = undefined

-- solution

-- data Entry k1 k2 v = Entry (k1, k2) v  deriving Show
-- data Map k1 k2 v = Map [Entry k1 k2 v]  deriving Show
instance Functor (Entry k1 k2) where
    -- fmap :: (a -> b) -> f a -> f b
    fmap f (Entry k v) = Entry k $ f v

instance Functor (Map k1 k2) where
    -- fmap :: (a -> b) -> f a -> f b
    fmap f (Map lst) = Map $ fmap (fmap f) lst

-- reference

-- type-class, полностью полиморфный, без ограничений на типы (переменные типов) a, b, f
-- класс типов параметризован переменной (типа) `f`
class Functor f where
    -- fmap "поднимает" функцию `a -> b` в "контекст" `f`: принимает значение `f a`, на выходе значение `f b`
    -- где `f a`, `f b` это два типа (конструктора), параметризованных а и бе, соответственно.
    -- при этом сам контекст не меняется, нет "эффекта"
    fmap :: (a -> b) -> f a -> f b -- видно, что эф это конструктор типов, ибо "применяется" к а и к бе
-- переменная `f` используется как функция над типами, у нее должен быть "стрелочный кайнд": `* -> *`
-- <$> -- infix synonim for fmap
```
test

### 5.1.9 functor laws

Чтобы функтор был функтором, должны выполняться два закона:
гарантия неизменности "структуры контейнера" или "отсутствия эффектов".
```hs
-- 1) fmap id x = id x
-- 2) fmap (f . g) x = (fmap f . fmap g) x

-- или, в pointfree стиле
-- 1) fmap id = id
-- 2) fmap (f . g) = (fmap f) . (fmap g) -- композиция лифтов заменяется на 1 лифт композиции функций, типа оптимизация

ghci> fmap (+1) . fmap (^2) $ [1,2,3]
[2,5,10]

ghci> fmap ((+1) . (^2)) $ [1,2,3]
[2,5,10]

-- пример реализации с нарушением законов
instance Functor [] where
    fmap _ [] = []
    fmap g (x:xs) = g x : g x : fmap g xs
-- на каждом применении fmap длина списка удваивается
```
repl

> Второй закон можно не проверять, он следует из первого.
Для функторов в общем виде это неверно, но в Haskell это работает из-за полиморфности Functor
https://www.schoolofhaskell.com/user/edwardk/snippets/fmap

## chapter 5.2, Определение монады

https://stepik.org/lesson/8437/step/1?unit=1572

- Стрелка Клейсли
- Класс типов Monad
- Оператор монадического связывания
- Полное определение класса Monad

### 5.2.2 Стрелка Клейсли, вычислительный контекст, вычисления с эффектами (монадические вычисления)

Присоединение к вычислениям полезных эффектов.

Говоря про контейнеры мы будем иметь в виду вычислительные контексты,
где, кроме вычисления результата функции,
возможны "эффекты", т.е. некое "дополнительное значение" (или said-effect) как результат работы функции.
Или, как некий набор данных, сопровождающий вычисление чистых функций.
Или просто (не)мутабельный контекст вычисления функции.
Примеры контекстов: ввод-вывод, ошибки, конфигурация, стейт (состояние), ...
```hs
-- мы знаем про фунцию, что она либо вычисляется, либо ломает программу (не сходится)
f :: a -> b -- стрелочный тип, абстрактная функция из а в бэ, чистая математика

-- добавим ограничение: пусть бэ будет упаковано в "одно-параметрический контейнер"
-- тогда мы можем добавить некоторую семантику к таким функциям
f :: a -> Maybe b       -- возможен фейл, вычислительный эффект: вероятна ошибка и отсутствие значения бэ
f :: a -> [b]           -- возможно разное количество результатов: [0 ..] значений, семантика зависит от домена, не-детерминированные вычисления
f :: a -> (Either s) b  -- возможна типизированная ошибка: расширенный Maybe
f :: a -> (s, b)        -- возможна запись в лог (s это лог)
f :: a -> ((->) e) b    -- возможно чтение из окружения (конфигурации, е это енвайронмент)
f :: a -> (State s) b   -- возможен (как бы) мутабельный стейт
f :: a -> IO b          -- возможен выход во внешний мир, файлы (консоль, сеть, ...)

-- Этот подход к поддержке вычислений с эффектами можно обобщить, абстрагировать.
-- Монадическое вычисление.
-- Получившаяся абстаркция имеет название Стрелка Клейсли, где результат функции это
-- результат работы одно-параметрического конструктора (контейнера) над собственно значением
f :: a -> m b
-- Чтобы этим пользоваться, нам нужен интерфейс, API работы с монадическими вычислениями.
-- Входит Монада ...

f :: a -> m b -- Примеры монад:
f :: a -> Maybe b            -- m = Maybe
f :: a -> [] b               -- m = []
f :: a -> (Either s) b       -- m = Either s
f :: a -> ((,) s) b          -- m = ((,) s)
f :: a -> ((->) e) b         -- m = ((->) e)
f :: a -> (State s) b        -- m = State s
f :: a -> IO b               -- m = IO
```
repl

```hs
{--
Введём следующий тип:

data Log a = Log [String] a

Реализуйте вычисление с логированием, используя `Log`

Для начала определите функцию `toLogger`
которая превращает обычную функцию, в функцию с логированием

toLogger :: (a -> b) -> String -> (a -> Log b)

GHCi> let add1Log = toLogger (+1) "added one"
GHCi> add1Log 3
Log ["added one"] 4

GHCi> let mult2Log = toLogger (* 2) "multiplied by 2"
GHCi> mult2Log 3
Log ["multiplied by 2"] 6

Далее, определите функцию `execLoggers`
Которая принимает некоторый элемент и две функции с логированием
`execLoggers` возвращает результат последовательного применения функций к элементу и
список сообщений, которые были выданы при применении каждой из функций

execLoggers :: a -> (a -> Log b) -> (b -> Log c) -> Log c

GHCi> execLoggers 3 add1Log mult2Log
Log ["added one","multiplied by 2"] 8
--}
toLogger :: (a -> b) -> String -> (a -> Log b)
toLogger f msg = undefined

execLoggers :: a -> (a -> Log b) -> (b -> Log c) -> Log c
execLoggers x f g = undefined

-- solution

-- data Log a = Log [String] a deriving Show
toLogger :: (a -> b) -> String -> (a -> Log b)
toLogger f msg a = Log [msg] (f a)

execLoggers :: a -> (a -> Log b) -> (b -> Log c) -> Log c
execLoggers x f g = Log (lst1 ++ lst2) c where
    Log lst1 b = f x
    Log lst2 c = g b

-- alternative

instance Functor Log where
  fmap f (Log lst_str x) = Log lst_str (f x)

toLogger :: (a -> b) -> String -> (a -> Log b)
toLogger f msg = \x -> fmap f (Log [msg] x)

execLoggers :: a -> (a -> Log b) -> (b -> Log c) -> Log c
execLoggers x f g = case f x of
    Log lst1 b -> case g b of 
        Log lst2 c -> Log (concat [lst1, lst2]) c
```
test

### 5.2.4 тайпкласс Monad, toKleisli func

```hs
class Monad m where -- переменная эм это одно-параметрический (кайнд * -> *) конструктор типов
    return :: a -> m a -- одно-параметричность видно из сигнатур методов интерфейса
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind (flatMap in Scala)

-- ретурн: поднимает значение в монаду, тривиальным образом, что важно!
-- позволяет любую стрелку a -> b превратить в стрелку Клейсли

-- байнд: применяет стрелку-клейсли в контексте монады (поднимает стрелку в монаду)
-- байнд построен так, чтобы контекст не терялся в процессе выполнения операций

-- bind: лево-ассоциативный с низким приоритетом
ghci> :i >>=
type Monad :: (* -> *) -> Constraint
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b -- Defined in ‘GHC.Base’
infixl 1 >>=

-- позже рассмотрим законы для монад, законы определяют возможные реализации для разных типов контекста с разной семантикой

-- посмотрим на реализации return

-- вывод типов говорит нам, что на выходе будет некая монада содержащая булево значение
ghci> :t return True
return True :: Monad m => m Bool -- выражение полиморфно по "контейнеру"

-- укажем список как тип монады, получим результат ретурна для монады-списка
ghci> return True :: [] Bool
[True]

-- для опции ретурн работает вот так:
ghci> return True :: Maybe Bool
Just True

-- как с помощью return получить стрелку Клейсли
toKleisli :: (Monad m) => (a -> b) -> (a -> m b) -- на входе просто стрелка, на выходе уже Клейсли
toKleisli f = return . f -- результат работы a -> b заворачиваем в ретурн: композиция двух функций
-- toKleisli f = (\ x -> return (f x)) -- вот так это записывается в развернутом виде
-- альтернативная запись:
-- можно убрать правые скобки в сигнатуре (это эквивалентно, каррирование бесплатно)
toKleisli :: (Monad m) => (a -> b) -> a -> m b -- функция двух аргументов, возвращает монаду-бе
toKleisli f x = return (f x)
-- вот совсем пойнтфри вариант записи
toKleisli :: (Monad m) => (a -> b) -> a -> m b
toKleisli = (return .)

-- стрелка К. на выходе
ghci> :t toKleisli cos
toKleisli cos :: (Monad m, Floating b) => b -> m b

ghci> toKleisli cos 0 :: [Double] -- укажем тип монады список
[1.0]
ghci> toKleisli cos 0 :: Maybe Float -- тип монады опция
Just 1.0

-- ghci работает в контексте монады IO, поэтому вывод видно сразу в репл
ghci> toKleisli cos 0 :: IO Double
1.0
ghci> :t toKleisli cos 0 :: IO Double
toKleisli cos 0 :: IO Double :: IO Double
```
repl

```hs
{--
Функции с логированием из предыдущего задания возвращают в качестве результата
значение с некоторой дополнительной информацией в виде списка сообщений
Этот список является контекстом.

Реализуйте функцию `returnLog`
которая является аналогом функции `return` для контекста `Log`
Данная функция должна возвращать переданное ей значение с пустым контекстом

returnLog :: a -> Log a
--}
returnLog :: a -> Log a
returnLog = undefined

-- solution

-- data Log a = Log [String] a deriving Show
-- типа, сделали стрелку Клейсли
returnLog :: a -> Log a
returnLog = Log []

-- alternative

instance Monad Log where
    return a = Log [] a

returnLog :: a -> Log a
returnLog = return
```
test

### 5.2.6 operator bind

Первый аргумент это монада-а, второй аргумент это стрелка Клейсли из-а-в-монаду-б.
Оператор монадического связывания нужен для связывания монадических вычислений (в цепочку).
Таким образом, эффекты переходят (с накоплением) по цепочке.
```hs
class Monad m where -- переменная эм это одно-параметрический (кайнд * -> *) конструктор типов
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind
-- сигнатура байнда говорит нам о доступности контекста на каждом шаге обработки, через это
-- оператор обеспечивает выполнение эффекта при отображении м-а в -м-б.
-- т.е. байнд может менять структуру "контейнера"

-- bind: лево-ассоциативный с низким приоритетом
ghci> :i >>=
type Monad :: (* -> *) -> Constraint
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b -- Defined in ‘GHC.Base’
infixl 1 >>=

-- другие операторы применения функции, ($), (&)
ghci> :i $
($) :: (a -> b) -> a -> b       -- Defined in ‘GHC.Base’
infixr 0 $
-- право-ассоциативный и аргументы флипнуты (относительно байнд)

-- оператор амперсанд (евро) очень похож на монадический байнд
-- лево-ассоциативный и порядок аргументов такой же
ghci> import Data.Function
ghci> :i &
(&) :: a -> (a -> b) -> b       -- Defined in ‘Data.Function’
infixl 1 &

-- (+1 (*3 (+2 5)))
ghci> (+1) $ (*3) $ (+2) $ 5 -- function application
22

-- (((5 +2) *3) +1)
ghci> 5 & (+2) & (*3) & (+1) -- pipeline, left-to-right
22
-- монадический bind вот таким образом и работает, как пайплайн, слева-направо

-- сравним bind с fmap: порядок аргументов обратный (к bind), аналогичен оператору `$`
ghci> :i fmap
type Functor :: (* -> *) -> Constraint
class Functor f where
  fmap :: (a -> b) -> f a -> f b -- Defined in ‘GHC.Base’

-- вот теперь уже ближе к bind, но стрелочка не-Клейсли, поэтому цепочка эффектов прерывается
-- структура "контейнера" не меняется, но bind может менять структуру контейнера (для того и сделан)
ghci> :t flip fmap
flip fmap :: Functor f => f a -> (a -> b) -> f b
```
repl

```hs
{--
Реализуйте фукцию `bindLog`
которая работает подобно оператору `>>=` для контекста `Log`

bindLog :: Log a -> (a -> Log b) -> Log b

GHCi> Log ["nothing done yet"] 0 `bindLog` add1Log
Log ["nothing done yet","added one"] 1

GHCi> Log ["nothing done yet"] 3 `bindLog` add1Log `bindLog` mult2Log
Log ["nothing done yet","added one","multiplied by 2"] 8
--}
bindLog :: Log a -> (a -> Log b) -> Log b
bindLog = undefined

-- тема: bind (>>=) infixl и его свойства
-- data Log a = Log [String] a deriving Show
bindLog :: Log a -> (a -> Log b) -> Log b
bindLog (Log lstA a) f = Log (lstA ++ lstB) b where
    Log lstB b = f a

-- надо иначе: форсировать вычисление лога а, потом выполнять стрелку К.
```
test

```hs
{--
Реализованные ранее `returnLog` и `bindLog` позволяют объявить тип `Log` представителем класса `Monad`

instance Monad Log where
    return = returnLog
    (>>=) = bindLog

Используя `return` и `>>=`, определите функцию `execLoggersList`
которая принимает некоторый элемент, 
список функций с логированием и 
возвращает результат последовательного применения всех функций в списке к переданному элементу 
вместе со списком сообщений, которые возвращались данными функциями

execLoggersList :: a -> [a -> Log a] -> Log a

GHCi> execLoggersList 3 [add1Log, mult2Log, \x -> Log ["multiplied by 100"] (x * 100)]
Log ["added one","multiplied by 2","multiplied by 100"] 800
--}
execLoggersList :: a -> [a -> Log a] -> Log a
execLoggersList = undefined

-- solution
-- поднять первый элемент в монаду и сделать свертку стрелок Клейсли (monad bind)

execLoggersList :: a -> [a -> Log a] -> Log a
execLoggersList x = foldl (>>=) (return x) 
-- execLoggersList = foldl (>>=) . return

-- reference

foldl :: (b -> a -> b) -> b -> [a] -> b
data Log a = Log [String] a deriving Show
instance Functor Log where
  fmap = liftM
instance Applicative Log where
  pure = return
  (<*>) = ap
instance Monad Log where
    -- return :: a -> m a -- pure
    return = returnLog
    -- (>>=) :: m a -> (a -> m b) -> m b --  bind, infixl
    (>>=) = bindLog
```
test

### 5.2.9 дополнительные методы монад (`>>` `=<<` `<=<` `fail`)

У дополнительных операторов есть дефолтная реализация, переписывать их необязательно
```hs
class Monad m where -- переменная эм это одно-параметрический (кайнд * -> *) конструктор типов
    return :: a -> m a -- pure
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind

-- "облегченная версия" bind, поднимает в первый аргумент вычисление-пустышку, возвращает второй аргумент
-- зачем так? чтобы продемонстрировать, что нас интересует только эффект (подробнее позже)
    (>>) :: m a -> m b -> m b -- operator "then" or "sequence"
    mx >> my = mx >>= (\ _ -> my) -- связываем два монадических вычисления, второе-пустышка

-- дефолтная реализация прерывает программу, конкретная реализация монады может переопределить это поведение (Maybe, Either, ...)
    fail :: String -> m a
    fail s = error s

-- пайплайн развернут в обратную сторону (работает как $, справа-налево, право-ассоциативное применение функций)
(=<<) :: Monad m => (a -> m b) -> m a -> m b
(=<<) = flip (>>=)

-- оператор `рыбка`, композиция стрелок Клейсли (аналогично композиции функций `.`)
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
f <=< g = (\ x -> g x) >>= f -- а-в-бэ и связываем с бэ-в-це, получаем а-в-це но в контексте монады
-- это композиция двух монадических вычислений, наподобие оператора `.`
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c -- можно записать более внятным способом
(<=<) f g x = (g x) >>= f -- эф и же это две стрелки Клейсли, выполняем же и заворачиваем в эф.

-- reference
ghci> :i .
(.) :: (b -> c) -> (a -> b) -> a -> c   -- Defined in ‘GHC.Base’
infixr 9 .
```
repl

## chapter 5.3, Монада Identity

https://stepik.org/lesson/8438/step/1?unit=1573

- Identity как монада
- Первый и второй законы для монад
- Третий закон для монад
- От законов монад к императивному программированию
- do нотация

Разберем реализацию некоторых монад, начнем с Identity

### 5.3.2 Monad Identity

Самый простой монадический контекст, ничего не делает
```hs
class Monad m where -- переменная эм это одно-параметрический (кайнд * -> *) конструктор типов
    return :: a -> m a -- тривиальная стрелка Клейсли --  ‘return = pure’
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind

newtype Identity a = Identity { runIdentity :: a } -- (дезайн-тайм) конструктор типа = конструктор данных { метка-доступа-к-значению }
    deriving (Eq, Show) -- авто-вывод тайпклассов

-- Update lesson materials: для реализации монады нужно реализовать функтор и аппликатив
instance Functor Identity where
  fmap  f (Identity x) = Identity (f x) -- fmap :: (a -> b) -> f a -> f b
instance Applicative Identity where
  pure x = Identity x -- Monad return  
  (Identity f) <*> (Identity v) = Identity (f v) -- "applied over", infixl 4 <*>, <*> :: f (a -> b) -> f a -> f b
-- End Of Update

instance Monad Identity where
    return x = Identity x -- однопараметрический конструктор, тривиальная стрелка Клейсли
    (Identity x) >>= k = k x -- никаких эффектов, прозрачное выполнение стрелки Клейсли
    -- вынуть значение из контекста, применить стрелку К., вернуть результат
    -- вынули через пат.мат, тривиально вернули результат применения стрелки К.

-- для изучения, примеров и иллюстраций: создадим не-тривиальную стрелку Клейсли
wrap'n'succ :: Integer -> Identity Integer
wrap'n'succ = Identity . succ -- комбинация ф.: след. число, завернуть в монаду

-- типично для монадических вычислений: (паттерн использования) вычисляем, потом вызываем геттер
-- с учетом ленивости тут намек на то, что в монаде реально вычисления происходят только в момент вызова `run...`
ghci> runIdentity $ wrap'n'succ 3
4

-- оператор bind: слева монада, справа стрелка Клейсли, результат: монада
ghci> runIdentity $ (wrap'n'succ 3) >>= wrap'n'succ -- цепочка двух вычислений
5
-- связываем (bind) цепочку из трех вычислений (монадических)
ghci> runIdentity $ (wrap'n'succ 3) >>= wrap'n'succ >>= wrap'n'succ 
6

-- без контекста (монады) это выглядит так
ghci> succ 3 & succ & succ
6
-- что можно записать даже так
ghci> 3 & succ & succ & succ -- лево-ассоц. оператор `Data.Function.&`
6
-- видно, что форма вызова (монадической цепочки) идентичная второму варианту без монад
ghci> runIdentity $ (return 3) >>= wrap'n'succ >>= wrap'n'succ >>= wrap'n'succ
6
-- обратите внимание, как `wrap'n'succ 3` был убран в пользу затаскивания стрелок в монаду, созданную в самом начале пайплайна
```
repl

Обратите внимание, как через оператор `bind` монады мы получаем "пайплайн" вычислений-в-контексте.

```hs
{--
Если некоторый тип является представителем класса `Monad`
то его можно сделать представителем класса `Functor`
используя функцию `return` и оператор `>>=`
Причём, это можно сделать даже не зная, как данный тип устроен

Пусть вам дан тип 
и он является представителем класса `Monad`

data SomeType a = ...

Сделайте его представителем класса `Functor`
--}
instance Functor SomeType where
    fmap f x = undefined

-- solution: задачка на toKleisli
-- Есть монада, есть стрелка. Нужно из стрелки получить стрелку Клейсли (toKleisli)

-- data SomeType a = SomeType (a, Int) deriving (Show, Monad)
instance Functor SomeType where
    -- fmap :: (a -> b) -> f a -> f b
    fmap f x = x >>= (return . f) -- (монада x) bind (стрелка Клейсли), x = f a; f = a -> b

-- reference

class Functor f where
    -- fmap "поднимает" функцию `a -> b` в "контекст" `f`: принимает значение `f a`, на выходе значение `f b`
    fmap :: (a -> b) -> f a -> f b -- видно, что эф это конструктор типов, ибо "применяется" к а и к бе
-- переменная `f` используется как функция над типами, у нее должен быть "стрелочный кайнд": `* -> *`
-- <$> synonim for fmap, infixl 4 <$>

class Monad m where
    return :: a -> m a -- pure
    (>>=) :: m a -> (a -> m b) -> m b --  bind

-- как с помощью return получить стрелку Клейсли
toKleisli :: (Monad m) => (a -> b) -> (a -> m b) -- на входе просто стрелка, на выходе уже Клейсли
toKleisli f = return . f -- результат работы a -> b заворачиваем в ретурн: композиция двух функций
toKleisli f = (\ x -> return (f x)) -- вот так это записывается в развернутом виде
-- альтернативная запись: можно убрать правые скобки в сигнатуре (это эквивалентно, каррирование бесплатно)
toKleisli :: (Monad m) => (a -> b) -> a -> m b -- функция двух аргументов, возвращает монаду-бе
toKleisli f x = return (f x)
-- pointfree
toKleisli :: (Monad m) => (a -> b) -> a -> m b
toKleisli = (return .)
```
test

### 5.3.4 первые два закона монад

Законы монад, первые два (из трех)
```hs
-- reference
class Monad m where
    return :: a -> m a -- pure
    (>>=) :: m a -> (a -> m b) -> m b -- bind
newtype Identity a = Identity { runIdentity :: a } deriving (Eq, Show)
instance Functor Identity where
    fmap  f (Identity x) = Identity (f x)
instance Applicative Identity where
  pure x = Identity x -- Monad return
  Identity f <*> Identity v = Identity (f v)  -- applied over
instance Monad Identity where
    return = Identity
    (Identity x) >>= k = k x
wrap'n'succ :: Integer -> Identity Integer
wrap'n'succ = Identity . succ

-- мы запускали цепочку двумя разными способами
ghci> runIdentity $ (wrap'n'succ 3) >>= wrap'n'succ >>= wrap'n'succ
ghci> runIdentity $ (return 3) >>= wrap'n'succ >>= wrap'n'succ >>= wrap'n'succ
-- т.е. вот эти две формы эквивалентны
wrap'n'succ 3
(return 3) >>= wrap'n'succ
-- это иллюстрация к первому закону монад

-- первый закон (левый pure)
(return a) >>= k    =    k a
-- применение стрелки Клейсли к значению х эквивалентно 
-- применению оператора bind к значению завернутому в return (pure) и стрелке К.

-- иллюстрация ко второму закону
ghci> (wrap'n'succ 3) >>= return    -- Identity {runIdentity = 4}
ghci> (wrap'n'succ 3)               -- Identity {runIdentity = 4}
-- return это стрелка К., связав ее байндом с монадой мы не меняем ничего

-- второй закон (правый pure)
m >>= return    =    m

-- первый и второй законы отражают "тривиальную" природу оператора `return`
-- он не выполняет эффектов и не меняет значение

-- extra
-- язык, в котором законы монад выглядят как законы моноидов, оперирует композицией стрелок Клейсли
-- если
return :: (Monad m) => a -> m a
f :: (Monad m) => a -> m b
g :: (Monad m) => b -> m c
h :: (Monad m) => c -> m d
(>=>) :: (Monad m) => (a -> m b) -> (b -> m c) -> (a -> m c)
-- то
-- Левая единица
return >=> f    === f
-- Правая единица
f >=> return    === f
-- Ассоциативность
f >=> (g >=> h) === (f >=> g) >=> h
```
repl

Похоже на законы для моноида (правая и левая единица).
Т.е. (в категории эндофункторов) bind (не совсем) это бинарная операция, return это нейтральное значеие (единица).

### 5.3.5 третий закон монад, ассоциативность

Третий закон должен постулировать ассоциативность (как у моноид).
Как бы да, но реализуется это через фокус с добавлением лямбды (ленивости) и честной ассоциативности тут нет
```hs
-- reference
-- (a -> m b) это Стрелка Клейсли
class Monad m where
    return :: a -> m a -- pure
    (>>=) :: m a -> (a -> m b) -> m b -- bind
-- первый закон (левый pure)
(return a) >>= k    =    k a
-- второй закон (правый pure)
m >>= return        =    m

-- думаете (ассоциативность выглядит) так?:
(m >>= k) >>= k'    =   m >>= (k >>= k')
-- нет, не так. По типам нет соответствия
-- левая часть рабоатает, правая часть не работает, (монада байнд монада) не соответствует сигнатуре bind

-- хакнем чутка, добавим свободный х :: a
(m >>= k) >>= k'  =   m >>= ((\ x -> k x) >>= k')
-- (\ x -> k x) вот эта лямбда приводит к подгонке типов выражений под сигнатуру bind
-- ((\ x -> k x) >>= k') это стрелка Клейсли, которая по факту есть ленивый враппер над двумя внутренними стрелками.
-- мы лениво ждем в стрелке к, пока нам подадут на вход значение из монады м. (левый операнд).
-- после этого можем запускать вычисление в стрелке к.
-- IMHO Так что это не "честная" ассоциативность, это фокус для имитации ассоциативности.
-- Правда, если подумать, то очередность соблюдается только для порядка операций, для "накопления" эффектов очередность меняется.

-- идея третьего закона:
-- мы можем лево-ассоциативные байнды заменить на право-ассоциативные,
-- но для этого мы должны завернуть стрелки К. в лямбды, ждущие значения из предыдущего шага пайплайна.
-- при этом реализация "накопления" эффектов должна быть ассоциативной,

-- третий закон, ассоциативность bind (скобки опциональны, и без них корректно)
(m >>= k) >>= k'  =   m >>= (\ x -> k x >>= k')

-- иллюстрация

-- левая ассоциативность
ghci> runIdentity $ (wrap'n'succ 3) >>= wrap'n'succ >>= wrap'n'succ
6
ghci> runIdentity $ ((wrap'n'succ 3) >>= wrap'n'succ) >>= wrap'n'succ
6

-- правая ассоциативность
ghci> runIdentity $ (wrap'n'succ 3) >>= (\ x -> wrap'n'succ x >>= wrap'n'succ)
6

-- затравка к теме "do нотация", явное выражение параметров для каждой стрелки Клейсли
ghci> runIdentity $ (wrap'n'succ 3) >>= (\ x -> wrap'n'succ x >>= (\ y -> wrap'n'succ y))
6
```
repl

```hs
{--
Вспомним тип `Log`
который мы сделали монадой в предыдущем модуле

data Log a = Log [String] a

Функция `return` для `Log` оборачивает переданное значение в лог с пустым списком сообщений. 
Оператор `>>=` возвращает лог с модифицированным значением и новым списком сообщений, 
который состоит из прежнего списка и добавленного в конец списка сообщений, полученных при модификации значения

Пусть теперь функция `return` будет оборачивать переданное значение в список
содержащий одно стандартное сообщение "Log start"

Выберите верные утверждения относительно выполнения законов для монады с новым поведением функции `return`
--}
- Не выполняется первый закон -- да
- Не выполняется второй закон -- да
- Не выполняется третий закон -- нет
- Все законы выполняются -- нет

-- solution

-- первый закон (левый pure): не выполняется, ретурн добавляет строку в эффект, которой нет в правой части уравнения
(return a) >>= k    =    k a
(Log ["Log start"] 2) >>= (\ x -> Log ["some msg"] x + 40)
    ->
    Log ["Log start", "some msg"] 42
== (нет)
(\ x -> Log ["some msg"] x + 40) 2
    -> Log ["some msg"] 42

-- второй закон (правый pure): не выполняется, левая часть добавляет строку в эффект, которой нет в правой части
m >>= return        =    m

-- третий закон, ассоциативность: выполняется, тут нет ретурна "только слева" или "только справа"
(m >>= k) >>= k'    =   m >>= (\ x -> k x >>= k')

-- reference

data Log a = Log [String] a

-- первый закон (левый pure)
(return a) >>= k    =    k a
-- второй закон (правый pure)
m >>= return        =    m
-- третий закон, ассоциативность bind (скобки опциональны, и без них корректно)
(m >>= k) >>= k'    =   m >>= (\ x -> k x >>= k')
```
test

```hs
{--
родолжим обсуждать монаду для `Log`
Пусть теперь у нас будет новая версия оператора `>>=`
которая будет добавлять сообщения не в конец результирующего списка, а в начало
(при этом функция `return` предполагается возвращенной к исходной реализации, т.е. корректной)

Выберите верные утверждения относительно выполнения законов для монады с новым поведением оператора `>>=`
--}
- Не выполняется первый закон -- нет
- Не выполняется второй закон -- нет
- Не выполняется третий закон -- нет
- Все законы выполняются -- да

-- solution

-- первый и второй законы: выполняются, ибо куда не добавляй пустую строку, разницы нет.

-- третий закон, ассоциативность: выполняется, ибо правая часть эффекта дописывается к левой части (в конец),
-- что не меняет эффекта при смене ассоциативности (а значение по любому считается слева-направо)
(m >>= k) >>= k' -- ("1" >>= "2") >>= "3" ~> [1, 2] >>= 3 ~> [1,2,3]
===
m >>= (\ x -> k x >>= k') -- "1" >>= (\ x -> "2" >>= "3") ~> [1,2,3]

-- reference

-- bind: добавлять сообщения не в конец результирующего списка, а в начало

data Log a = Log [String] a

-- первый закон (левый pure)
(return a) >>= k    =    k a
-- второй закон (правый pure)
m >>= return        =    m
-- третий закон, ассоциативность bind (скобки опциональны, и без них корректно)
(m >>= k) >>= k'    =   m >>= (\ x -> k x >>= k')
```
test

```hs
{--
И снова монада `Log`
Пусть теперь оператор `>>=` будет добавлять сообщения как в начало списка, так и в конец

Выберите верные утверждения относительно выполнения законов для монады с новым поведением оператора `>>=`
--}
- Не выполняется 1-й закон -- да
- Не выполняется 2-й закон -- нет
- Не выполняется 3-й закон -- да
- Все законы выполняются -- нет

-- solution

-- первый закон: не выполняется, бинд слева добавит список-к два раза
(return a) >>= k    =    k a -- "" >>= "1" === "1" ~> 11 === 1

-- второй закон (правый pure): выполняется, добавление пустого списка два раза (слева) не меняет эффекта
m >>= return        =    m

-- третий закон, ассоциативность: не выполняется, лямбда откладывает выполение (накопление) эффекта в первом бинд правой части
-- конкатенация списков перестает быть ассоциативной
(m >>= k) >>= k' -- ("1" >>= "2") >>= "3" ~> 212 >>= 3 ~> 32123
===
m >>= (\ x -> k x >>= k') -- "1" >>= (\ x -> "2" >>= "3") ~> 1 ++ (2 ++ 3) ~> 1 ++ 323 ~> 3231323

-- reference

-- bind: добавлять сообщения как в начало списка, так и в конец (конкатенация списков)
-- предположим, это значит, что бинд добавляет свою строку к логу два раза: в начало И в конец

data Log a = Log [String] a

bindLog :: Log a -> (a -> Log b) -> Log b
bindLog (Log lstA a) f = Log (lstA ++ lstB) b where
    Log lstB b = f a

-- первый закон (левый pure)
(return a) >>= k    =    k a
-- второй закон (правый pure)
m >>= return        =    m
-- третий закон, ассоциативность bind (скобки опциональны, и без них корректно)
(m >>= k) >>= k'    =   m >>= (\ x -> k x >>= k')
```
test

### 5.3.9 подходим к do-нотации

Упражнения с цепочками монадических вычислений
```hs
-- reference
class Monad m where
    return :: a -> m a -- pure
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind
-- первый закон (левый pure)
(return a) >>= k    =    k a
-- второй закон (правый pure)
m >>= return    =    m
-- ассоциативность bind (ассоциативность накопления эффектов)
(m >>= k1) >>= k2 = m >>= (\ x -> k1 x >>= k2)

-- сделаем небольшой массаж нашему выражению
runIdentity $ (wrap'n'succ 3) >>= wrap'n'succ >>= wrap'n'succ

goWrap0 = 
    wrap'n'succ 3 >>=
    wrap'n'succ >>=
    wrap'n'succ >>=
    return -- по второму закону этот ретурн ничего не меняет

ghci> :t goWrap0 
goWrap0 :: Identity Integer
ghci> goWrap0
Identity {runIdentity = 6}
ghci> runIdentity goWrap0 
6

-- перепишем по третьему закону, сменим ассоциативность на правую
-- через заворачивание в лямбды и ввод в скоуп переменных x, y, z
-- x, y, z это значения вынутые из монадических оберток
-- n.b. что порядок вычислений и порождения эффектов в каждом вычислении идет слева-направо,
-- но меняется порядок "накопления" эффектов, "конкатенация" начинается с хвоста и заканчивается "добавлением" первого эффекта
-- т.е. накопление эффектов теперь ассоциировано вправо
goWrap1 = 
    wrap'n'succ 3   >>= (\ x ->
    wrap'n'succ x   >>= (\ y ->
    wrap'n'succ y   >>= (\ z ->
    return      z)))

ghci> :t goWrap1 
goWrap1 :: Identity Integer
ghci> goWrap1
Identity {runIdentity = 6}
ghci> runIdentity goWrap1
6

-- иллюстрация скоупа переменных: в последнем вычислении доступны все три
goWrap2 = 
    wrap'n'succ 3   >>= (\ x ->
    wrap'n'succ x   >>= (\ y ->
    wrap'n'succ y   >>= (\ z ->
    return (x, y, z)    )))

ghci> :t goWrap2
goWrap2 :: Identity (Integer, Integer, Integer)
ghci> goWrap2
Identity {runIdentity = (4,5,6)}
ghci> runIdentity goWrap2
(4,5,6)

-- ой, мы изобрели императивное кодирование, смотрите:
wrap'n'succ 3   >>= (\ x ->     -- x = succ 3;
wrap'n'succ x   >>= (\ y ->     -- y = succ x;
wrap'n'succ y   >>= (\ z ->     -- z = succ y;
return (x, y, z)    )))         -- return (x, y, z)
-- оператор байнд можно рассматривать как оператор `;` из императивных языков
-- здесь мы нагружаем оператор `;` таким смыслом:
-- этот оператор выполняет те эффекты, для которых данная монада создана.
-- т.е. в хаскель мы сами определяем семантику оператора `;` (в отличие от не ФП языков)

-- иллюстрация оператора `>>` aka `then` aka `sequence`
goWrap3 = 
    wrap'n'succ 3   >>= (\ x ->
    wrap'n'succ x   >>= (\ y ->
    wrap'n'succ y   >>          -- облегченный bind, игнорирует результат `succ y`, хотя и выполняет его
    return (x + y)      ))
-- облегченный байнд нужен для протаскивания эффектов по цепочке, когда значение вычисления не требуется (ф. возвращает юнит)
ghci> :t (>>)
(>>) :: Prelude.Monad m => m a -> m b -> m b
```
repl

### 5.3.10 do-нотация, `fail` function

Синтаксический сахар для цепочки монадических вычислений
```hs
-- reference
import Prelude hiding (Monad, (>>=), (>>), return)
class Monad m where
    return :: a -> m a -- pure
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind
    (>>) :: m a -> m b -> m b -- then, sequence
    mx >> my = mx >>= (\ _ -> my) -- облегченный bind, выполняет эффект но игнорирует значение
newtype Identity a = Identity { runIdentity :: a } deriving (Eq, Show)
instance Functor Identity where
    fmap  f (Identity x) = Identity (f x)
instance Applicative Identity where
  pure = Identity -- Monad return
  Identity f <*> Identity v = Identity (f v) -- applied over
instance Monad Identity where
    return = Identity
    (Identity x) >>= k = k x
wrap'n'succ :: Integer -> Identity Integer
wrap'n'succ = Identity . succ
-- End Of Reference

-- do-нотация: цепочка м.вычислений записывается как последовательность строк в блоке `do { ... }`
-- правила трансляции сахара в монадические цепочки
do { e1; e2 } = e1 >> e2 -- облегченный байнд (then, sequence)
do { p <- e1; e2 } = e1 >>= (\ p -> e2) -- байнд со связыванием значения из первого маонадического выражения
do { let v = e1; e2 } = let v = e1 in do e2 -- не-монадические вычисления `v = e1` внутри ду-блока

-- правило немного сложнее чем это
do { p <- e1; e2 } = (e1 >>= \ p -> e2)
-- тут в лямбде возможно применение пат.мат. и пат.мат. может быть неудачен
do { (Just p) <- e1; e2 } = e1 >>= (\ (Just p) -> e2)
-- тогда в монаде будет вызван метод `fail`
-- этот метод `fail` в каждой монаде реализован по-совему.

-- пример
goWrap4 =
    let i = 3 in
    wrap'n'succ i   >>= \ x ->
    wrap'n'succ x   >>= \ y ->
    wrap'n'succ y   >>
    return          (i, x + y)

import Control.Monad.Identity
goWrap5 = do
    let i = 3
    x <- wrap'n'succ i
    y <- wrap'n'succ x
    wrap'n'succ y
    return (i, x + y)

ghci> goWrap4
Identity {runIdentity = (3,9)}
ghci> :t goWrap4
goWrap4 :: Num a => Identity (a, Integer)

ghci> goWrap5 
Identity (3,9)
ghci> :t goWrap5 
goWrap5 :: Identity (Integer, Integer) -- тип контейнера (Identity) один для всего блока do. Типы значений внутри могут быть разные

-- надо понимать, что оператор bind требует одинаковых типов (монад) слева и справа,
-- поэтому мы не можем внутри одного блока do оперировать разными монадами, по типам не будет сочетаться.
-- Каждые две строчки это левый и правый операнды для bind (с учетом лямбды)
```
repl

## chapter 5.4, Список и Maybe как монады

https://stepik.org/lesson/8439/step/1?unit=1574

- Монада Maybe
- Пример использования монады Maybe
- Монада списка
- Условные вычисления в монадах

### 5.4.2 Monad Maybe

Maybe: Эффект вычисления с возможной ошибкой, незавершающееся вычисление, опциональный результат.
Семантика: если ошибки нет, то поведение как у Identity;
если сломалось вычисление, то остаток пайплайна не выполняется.
```hs
-- reminder, reference
class Monad m where
    return :: a -> m a -- pure
    (>>=) :: m a -> (a -> m b) -> m b -- bind
    (>>) :: m a -> m b -> m b -- then, sequence: -- mx >> my = mx >>= (\ _ -> my)
    fail :: String -> m a

-- Option, sum-type
data Maybe a = Nothing | Just a -- одно-параметрический тип, с двумя конструкторами (сумма)
    deriving (Show, Eq, Ord)

instance Monad Maybe where
    -- pure
    return = Just -- тривиальная упаковка значения в монаду
    -- bind
    Nothing  >>= _  = Nothing -- bind с уже выстрелившим эффектом
    (Just x) >>= k  = k x -- happy path
    -- then, sequence
    Nothing  >> _   = Nothing
    (Just _) >> m   = m
    -- облом
    fail _ = Nothing -- на тот случай, если внутри монады вычисление сломалось
    -- например, при упавшем пат.мат. в поднятой лямбде

-- сопоставление с образцом транслируется в case of, который имеет ветку fail
```
repl

### 5.4.3 Использование монад Maybe

Будем имитировать базу данных
```hs
type Name = String
type DataBase = [(Name, Name)] -- ассоциативный список child -> parent

fathers, mothers :: DataBase 
fathers = [ ("Bill", "John")
          , ("Ann", "John")
          , ("John", "Peter")] 
mothers = [ ("Bill", "Jane")
          , ("Ann", "Jane")
          , ("John", "Alice")
          , ("Jane", "Dorothy")
          , ("Alice", "Mary")]

-- стрелки Клейсли, достать маму, достать папу
getM, getF :: Name -> Maybe Name
getM person = lookup person mothers
getF person = lookup person fathers

ghci> :i lookup 
lookup :: Eq a => a -> [(a, b)] -> Maybe b -- Defined in ‘GHC.List’

-- папа билла, мама папы билла, мама мамы папы билла (папа, бабушка, прабабушка по папе)
getF "Bill" >>= getM >>= getM -- три стрелки К, связанные в монаде Maybe
do { fb <- getF "Bill"; mfb <- getM fb; mmfb <- getM mfb; return mmfb }
do { fb <- getF "Bill"; mfb <- getM fb; getM mfb } -- последняя операция это `>> 	then, sequence`
-- правый pure ничего не меняет

-- поиск бабушек (бабушка по маме, бабушка по папе)
granmas :: Name -> Maybe (Name, Name)
granmas person = do
  m   <- getM person
  gmm <- getM m
  f   <- getF person
  gmf <- getM f
  return (gmm, gmf)

ghci> granmas "Ann"
Just ("Dorothy","Alice")

-- одна бабушка есть в БД, но кумулятивный результат пустой, одна цепочка в рамках одного Maybe только так работает
ghci> granmas "John"
Nothing
-- облом любого вычисления в цепочке дает Nothing

-- как видно, программа пишется как бы без учета эффектов, эффекты за кадром.
-- К тому же, благодаря общему интерфейсу монад, такие вычисления композибельны

-- extra
import Data.Maybe (fromMaybe)
import Text.Printf (printf)
main :: IO ()
main = do
    print $ getF "Bill" >>= getM >>= getM
    let 
        (gmmA, gmfA) = fromMaybe ("NA", "NA") (granmas "Ann")
        (gmmJ, gmfJ) = fromMaybe ("NA", "NA") (granmas "John")
    printf "Ann's mothers mother: %s, fathers mother: %s\n" gmmA gmfA
    printf "John's mothers mother: %s, fathers mother: %s\n" gmmJ gmfJ
```
repl

```hs
{--
Рассмотрим язык арифметических выражений, которые состоят из чисел, скобок, операций сложения и вычитания
Конструкции данного языка можно представить следующим типом данных

data Token = Number Int | Plus | Minus | LeftBrace | RightBrace 
    deriving (Eq, Show)

Реализуйте лексер арифметических выражений.

Для начала реализуйте функцию `asToken`:
Она проверяет, является ли переданная строка числом (используйте функцию `isDigit` из модуля `Data.Char`), 
знаком "+" или "-", открывающейся или закрывающейся скобкой. 
Если является, то она возвращает нужное значение обёрнутое в `Just`, в противном случае - `Nothing`

asToken :: String -> Maybe Token

GHCi> asToken "123"
Just (Number 123)
GHCi> asToken "abc"
Nothing

Далее, реализуйте функцию `tokenize`
Функция принимает на вход строку и если каждое слово является корректным токеном, 
то она возвращает список этих токенов, завёрнутый в `Just`. 
В противном случае возвращается `Nothing`
Функция должна разбивать входную строку на отдельные слова по пробелам (используйте библиотечную функцию `words`). 
Далее, полученный список строк должен быть свёрнут с использованием функции `asToken` и свойств монады `Maybe`

tokenize :: String -> Maybe [Token]

GHCi> tokenize "1 + 2"
Just [Number 1,Plus,Number 2]
GHCi> tokenize "1 + ( 7 - 2 )" -- Обратите внимание, что скобки отделяются пробелами от остальных выражений!
Just [Number 1,Plus,LeftBrace,Number 7,Minus,Number 2,RightBrace]
GHCi> tokenize "1 + abc"
Nothing
--}

-- data Token = Number Int | Plus | Minus | LeftBrace | RightBrace deriving (Eq, Show)
-- Тип Token уже объявлен, его писать не нужно

asToken :: String -> Maybe Token
asToken = undefined

tokenize :: String -> Maybe [Token]
tokenize input = undefined

-- solution

data Token = Number Int | Plus | Minus | LeftBrace | RightBrace
    deriving (Eq, Show)
-- Тип Token уже объявлен, его писать не нужно

import Text.Read (readMaybe)
asToken :: String -> Maybe Token
asToken "+" = Just Plus
asToken "-" = Just Minus
asToken "(" = Just LeftBrace
asToken ")" = Just RightBrace
asToken x = readMaybe x >>= (Just . Number) 
-- asToken x = if all Data.Char.isDigit x then Just $ Number (read x) else Nothing
-- readMaybe :: Read a => String -> Maybe a        -- Defined in ‘Text.Read’

tokenize :: String -> Maybe [Token]
tokenize str = sequence listMaybeTokens where
    wordList = words str
    listMaybeTokens = map asToken wordList
-- sequence :: Monad m => [m a] -> m [a] -- Defined in ‘Data.Traversable’

-- alternative

import qualified Text.Read as T
asToken :: String -> Maybe Token
asToken str = case str of
    "+" -> Just Plus
    "-" -> Just Minus
    "(" -> Just LeftBrace
    ")" -> Just RightBrace
    _   -> fmap Number $ T.readMaybe str
tokenize :: String -> Maybe [Token]
tokenize = mapM asToken . words

asToken :: String -> Maybe Token
asToken s
    | all isDigit s = Just $ Number $ read s
    | otherwise = lookup s tokForStr
    where tokForStr = [("+", Plus), ("-", Minus), ("(", LeftBrace), (")", RightBrace)]
tokenize :: String -> Maybe [Token]
tokenize = tokWrds . words
    where
        tokWrds [] = return []
        tokWrds (wrd:wrds) = do
            tok <- asToken wrd
            toks <- tokWrds wrds
            return (tok:toks)
```
test

### 5.4.5 Монад списка

Сложная (удивительная) монада.
Эффект: у вычисления много значений,
цепочка расходится по результатам предыдущего шага. Дерево вычислений, конкатенируется в конце в список.
Каждое вычисление в цепочке можно рассматривать как очередной вложенный цикл, запускаемый для каждого элемента левого операнда bind.

Недетерминированное вычисление.
У списка эффект это структура списка (количество элементов).
```hs
class Monad m where
    return :: a -> m a -- pure
    (>>=) :: m a -> (a -> m b) -> m b -- bind
    (>>) :: m a -> m b -> m b -- `>> 	then, sequence`, выполняет эффект левого операнда но игнорирует его значение
    fail :: String -> m a -- для списка: пустой список (все downstream вычисления останавливаются в этом узле дерева)

-- работа pure: упаковка значения в список
ghci> return 4 :: [Int]
[4]

-- работа bind: для каждого элемента слева выполняется операция справа (вложенные циклы)
ghci> [1, 2] >>= (\ x -> [x, x, x])
[1,1,1, 2,2,2]

-- результатов вычисления нет, эффект пустого списка результатов, аналог Nothing
ghci> [1, 2] >>= (\ x -> [])
[]
-- с точки зрения дерева вычислений: пустой список дает "засохшую" ветку, от которой ничего уже не вырастет
ghci> [1, 2] >>= (\ x -> []) >>= (\ y -> [y, y])
[]

-- применим стрелку К. к каждому элементу списка
ghci> map (\ x -> [x, x, x]) [1, 2]
[[1,1,1], [2,2,2]]
-- структура контейнера не изменилась (а должна), как было два элемента так и осталось

-- вот это ожидаемое поведение bind
ghci> concat $ map (\ x -> [x, x, x]) [1, 2]
[1,1,1, 2,2,2]

instance Monad [] where
    return x = [x] -- pure
    xs >>= k = concat (map k xs) -- bind (генерирует список списков и склеивает их)
    fail _ = [] -- как у Maybe; ветка сломалась, в конкатенацию вклада не будет

-- иллюстрация связи монады списка и list comprehension
ghci> [(x, y) | x <- [1,2,3], y <- [4,5,6]] -- правый цикл - внутренний
[(1,4),(1,5),(1,6), (2,4),(2,5),(2,6), (3,4),(3,5),(3,6)]
-- транслируется в
ghci> do { x <- [1,2,3]; y <- [4,5,6]; return (x, y) }
[(1,4),(1,5),(1,6), (2,4),(2,5),(2,6), (3,4),(3,5),(3,6)]
-- транслируется в
ghci> [1, 2, 3] >>= (\ x -> [4, 5, 6] >>= (\ y -> return (x, y)))
[(1,4),(1,5),(1,6), (2,4),(2,5),(2,6), (3,4),(3,5),(3,6)]

-- extra
import Control.Monad (guard)
list = do
  x <- [1, 2, 3]
  y <- [2, 3, 4]
  guard $ x == y
  return (x, y)
```
repl

```hs
{--
Пусть имеется тип данных, который описывает конфигурацию шахматной доски

data Board = ...

Кроме того, пусть задана функция `nextPositions`
которая получает на вход некоторую конфигурацию доски и 
возвращает все возможные конфигурации, которые могут получиться, если какая-либо фигура сделает один ход

nextPositions :: Board -> [Board]

Напишите функцию `nextPositionsN`
которая принимает конфигурацию доски, число ходов `n`, предикат `p` и 
возвращает все возможные конфигурации досок, которые могут получиться, 
если фигуры сделают `n` ходов и которые удовлетворяют заданному предикату. 
При `n < 0` функция возвращает пустой список. 

nextPositionsN :: Board -> Int -> (Board -> Bool) -> [Board]
--}

--Тип Board и функция nextPositions заданы, реализовывать их не нужно
nextPositionsN :: Board -> Int -> (Board -> Bool) -> [Board]
nextPositionsN b n pred = do undefined

-- solution

nextPositionsN :: Board -> Int -> (Board -> Bool) -> [Board]
nextPositionsN b n pred
    | n < 0 = []
    | n == 0 = [b | pred b] -- терминальное условие рекурсии, эти значения пойдут в результат
    | otherwise = do
        board <- nextPositions b -- first loop
        nextPositionsN board (n - 1) pred -- inner loop, рекурсия

-- Задание сформулировано под предполагаемое решение, это подстава.
```
test

### 5.4.7 ветвления по условию в монадической цепочке

n.b. конкретные примеры работают только для монады списка
```hs
-- без условия
ghci> [(x, y) | x <- [1, 2, 3], y <- [1, 2]]
[(1,1),(1,2), (2,1),(2,2), (3,1),(3,2)]
-- с условием
ghci> [(x, y) | x <- [1,2,3], y <- [1,2], x /= y]
[(1,2), (2,1), (3,1),(3,2)]
-- пропали (1,1) (2,2)

-- условие в do-нотации можно выразить так (для списка)
do
    x <- [1, 2, 3]
    y <- [1, 2]
    True <- return (x /= y) -- упаковка условия в монаду и распаковка результата в пат.мат.
    -- пат.мат. в левой части замаскированной лямбды,
    -- неуспешный пат.мат. дергает fail и он дает пустой список для данной пары
    -- пустой список "убиват" эту ветку дерева вычислений
    return (x, y)
-- т.е. здесь мы наблюдаем проявление эффекта монады списка, эффект влияет на результат

-- под капотом это как-то так будет
[1, 2, 3]         >>= (\ x ->
[1, 2]            >>= (\ y ->
return (x /= y)   >>= (\ b ->
case b of True -> return (x, y)
          _    -> fail "..." ))) -- fail для списка дает пустой список

-- иногда удобнее выразить условие через if then else
do
    x <- [1, 2, 3]
    y <- [1, 2]
    if x /= y then [42] else [] -- тут работает `>> then aka sequence`, IMHO
    -- значение игнорируется, структура (эффект, список из одного элемента) используется downstream
    return (x, y)
```
repl

```hs
{--
Используя монаду списка и do-нотацию, реализуйте функцию `pythagoreanTriple`
которая принимает на вход некоторое число `x` и возвращает список троек `(a,b,c)`
таких что

a^2 + b^2 = c^2,
a > 0,  b > 0,  c > 0,  c ≤ x,  a < b

pythagoreanTriple :: Int -> [(Int, Int, Int)]

Число `x` может быть `≤ 0` , на таком входе должен возвращаться пустой список

GHCi> pythagoreanTriple 5
[(3,4,5)]

GHCi> pythagoreanTriple 0
[]

GHCi> pythagoreanTriple 10
[(3,4,5),(6,8,10)]
--}
pythagoreanTriple :: Int -> [(Int, Int, Int)]
pythagoreanTriple x = do undefined

-- solution
-- задачка на предыдущую тему "if then else внутри цепочки монад.вычислений"

pythagoreanTriple :: Int -> [(Int, Int, Int)]
pythagoreanTriple x = do
    c <- allC
    b <- allB
    a <- allA
    [42 | x > 0 && allConditionsTrue a b c]
    return (a, b, c) where
        allA = [1 .. x] -- условия на относительные размеры abc можно сделать по месту
        allB = [1 .. x]
        allC = [1 .. x]
        allConditionsTrue a b c = a < b && b < c && (a^2 + b^2) == c^2

-- alternative

pythagoreanTriple :: Int -> [(Int, Int, Int)]
pythagoreanTriple x = do 
    c <- [1 .. x]
    b <- [1 .. c]
    a <- [1 .. b]
    if c^2 == a^2 + b^2 then [42] else []
    return (a, b, c)
```
test

## chapter 5.5, Монада IO

https://stepik.org/lesson/8443/step/1?unit=1578

- Ввод-вывод
- Тип IO
- Монада IO
- Устройство getLine и putStr
- Полезные вспомогательные функции

### 5.5.2 IO, Monad

В Хаскел ввод-вывод реализован через монаду IO, эффекты этой монады и есть IO
```hs
module Main where
main = do
    putStrLn "What's your nme?" -- operator `>>` aka `then` aka `sequence`
    name <- getLine -- bind
    putStrLn $ "Nice to meet you, " ++ name ++ "!"

ghci> :t main
main :: IO () -- IO unit
-- IO монада над типом "юнит"

-- юнит можно рассматривать как пустой тупл, маркер того, что значение нас не интересует
ghci> :t ()
() :: ()
ghci> :k ()
() :: *

-- на выходе `main` у нас тип последней операции пайплайна
ghci> :t putStrLn 
putStrLn :: String -> IO () -- стрелка Клейсли

ghci> :t getLine 
getLine :: IO String -- строка завернутая в монаду IO (вырожденная стрелка Клейсли)
```
repl

> любое монадическое значение можно интерпретировать как (вырожденную) стрелку Клейсли

```hs
{--
На этом шаге вы будете работать с монадой `IO`
значит, ваша программа будет взаимодействовать с операционной системой.
Чтобы тестирующая система смогла оценить вашу программу, пожалуйста, 
используйте только функции, осуществляющие ввод/вывод на терминал

getChar, putChar, putStr, putStrLn, getLine

Все эти функции уже будут находиться в области видимости, так что вам не следует их импортировать.

По той же причине, главная функция вашей программы будет называться не `main`, а `main'` (со штрихом)

Напишите программу, которая будет спрашивать имя пользователя
а затем приветствовать его по имени
если пользователь не ввёл имя, программа должна спросить его повторно, и 
продолжать спрашивать, до тех пор, пока пользователь не представится

Итак, первым делом, программа спрашивает имя:

What is your name?
Name: 

Пользователь вводит имя и программа приветствует его:

What is your name?
Name: Valera
Hi, Valera!

Если же пользователь не ввёл имя, необходимо отобразить точно такое же приглашение ещё раз:

What is your name?
Name: 
What is your name?
Name: 
What is your name?
Name: Valera
Hi, Valera!

строго соблюдайте приведенный в примере формат вывода. 
Особое внимание уделите пробелам и переводам строк! 
Не забудьте про пробел после `Name:`, а также про перевод строки в самом конце 
ожидается, что вы будете использовать `putStrLn` для вывода приветствия пользователя
--}
main' :: IO ()
main' = ?

-- solution

main' :: IO ()
main' = do
    putStrLn "What is your name?"
    putStr "Name: "
    name <- getLine
    if null name then main' else putStrLn $ "Hi, " ++ name ++ "!"

-- alternative

main' = do
  name <- getName  
  putStrLn $ "Hi, " ++ name ++ "!"

getName :: IO String
getName = do
  putStr "What is your name?\nName: "
  name <- getLine
  if name == "" then getName else return name
```
test

### 5.5.4 устройство IO

А почему непременно монада IO? Почему не обычные функции?
```hs
-- посмотрим на функцию чтения с консоли
-- по законам ФП это должна быть константа, но с консоли мы можем получить любой символ (или прерывание программы)
getCharFromConsole :: Char

-- вот так уже похоже на правду, значение полученного символа определяет "окружение", state, енв., мир, контекст, whatchamacallit
getCharFromConsole :: RealWorld -> (RealWorld, Char)

-- можно считать, что реализация монады IO опирается на такой тип
newtype IO a = IO (RealWorld -> (RealWorld, a))
-- где RealWorld это -- RealWorld is deeply magical

-- на самом деле, про айо мы гарантированно знаем только его кайнд
ghci> :k IO
IO :: * -> * -- однопараметрический конструктор типов, что позволяет сделать его монадой
-- интерфейс https://hackage.haskell.org/package/base-4.19.0.0/docs/GHC-IO.html#t:IO
-- There is really only one way to "perform" an I/O action: bind it to Main.main in your program
```
repl

### 5.5.5 реализация Monad IO

Сделаем упражнение: напишем реализацию монады IO
(спойлер) монада над стрелочным типом
```hs
class Monad m where
    return :: a -> m a -- pure
    (>>=) :: m a -> (a -> m b) -> m b -- bind
    (>>) :: m a -> m b -> m b -- `>> 	then, sequence`, выполняет эффект левого операнда но игнорирует его значение
    fail :: String -> m a

-- сигнатуры для нашего IO
newtype IO a = IO (RealWorld -> (RealWorld, a))
return :: a -> IO a
(>>=) :: IO a -> (a -> IO b) -> IO b
-- мы могли бы развернуть сигнатуры, через подстановку, но ...

-- для упрощения и снижения шума (постоянных пат.мат.) запишем тип чуть иначе
-- убрав из правой части конструктор данных IO
type IO a = RealWorld -> (RealWorld, a) -- инстанс тайпкласса для такой записи не будет валидным, но для целей упражнения это не важно

return :: a -> IO a -- превращается в
return :: a -> RealWorld -> (RealWorld, a) -- сделали подстановку, для наглядности. арность функции = 2
-- кроме значения, требует еще один параметр: RealWorld

(>>=) :: IO a -> (a -> IO b) -> IO b -- превращается в
(>>=) :: (RealWorld -> (RealWorld, a)) -- первое взаимодействие с миром, левый аргумент бинда
    -> (a -> (RealWorld -> (RealWorld, b))) -- второе взаимодействие с миром, стрелка К., второй аргумент бинда
    -> RealWorld -> (RealWorld, b) -- возвращаемая монада
-- сделали подстановку (IMHO зря, за деталями теряется мысль)

instance Monad IO where
    return :: a -> IO a -- как для любого стрелочного типа, используем лямбду
    return a = (\ w -> (w, a))
    return a w = (w, a) -- альтернативная запись
    -- pure это ф. возвращающая функцию из "мира" в пару (мир. а)
    -- обратите внимание: мир не меняется, это просто упаковка значения в монаду

    (>>=) :: IO a -> (a -> IO b) -> IO b
    (>>=) m k = -- m :: (RealWorld -> (RealWorld, a)); k :: (a -> (RealWorld -> (RealWorld, b)))
        (\ w1 -> -- w1 :: RealWorld левый, параметр лямбды, при запуске монады мы должны скормить ей мир1
            case m w1 of -- скармливаем левой монаде мир1,
                (w2, a) -> -- запускается пат.мат, что приводит к проявлению эффектов левой операции
                    k a w2) -- применяется правая операция, которая должна привести к эффектам правого операнда bind
    -- получаем левую монаду и стрелку К., получаем мир1, применяем левую монаду к этому мир1,
    -- получаем мир2 и значение из первой монады,
    -- применяем стрелку К. к значению и скармливаем туда мир2

-- эффекты выполняются один раз и в правильном порядке (благодаря лямбде и пат.мат.)
-- порядок выполнения эффектов (левый, правый) гарантируется наличием пат.мат. (форсирование левого вычисления)
-- и зависимостью правого вычисления от левого.
```
repl

> Это не столько рассказ об IO, сколько описание хитрого шаблона, когда `case of` служит для форсирования последовательности вычислений

упражнение
```hs
-- Попробуйте предсказать (или по крайней мере проанализировать) его результат
ghci> mapM show "123"
["'''","''3","'''","'2'","'23","'2'","'''","''3","'''","1''","1'3","1''","12'","123","12'","1''","1'3","1''","'''","''3","'''","'2'","'23","'2'","'''","''3","'''"]

-- где реализация mapM может быть такой
mapM :: Monad m => (a -> m b) -> [a] -> m [b] -- (sequence .map)
mapM _ []     = return []
mapM f (x:xs) = do
  x' <- f x
  xs' <- mapM f xs
  return (x' : xs')
```
extra

### 5.5.6 использование Monad IO

Как можно реализовать `getLine`, `putLine`
спойлер: рекурсивно
```hs
getLine :: IO String -- хотим реализовать это

-- будем использовать готовую getChar
ghci> :i getChar
getChar :: IO Char      -- Defined in ‘System.IO’

getLine :: IO String
getLine = do
    c <- getChar
    if c == '\n' then return []
    else do -- рекурсивно запускаем еще одно монадическое вычисление
        cs <-getLine
        return (c : cs)

-- теперь обратная задача, печать строки с использованием
ghci> :i putChar -- возвращает "единичный тип" юнит, завернутый в монаду IO
putChar :: Char -> IO ()        -- Defined in ‘System.IO’

putStr :: String -> IO ()
putStr [] = return ()
putStr (x : xs) = (putChar x) >> (putStr xs) -- рекурсивно связываем через `then, sequence` с выводом хвоста
-- оператор `then` по причине ненужности юнита `()`
```
repl

### 5.5.7 функции sequence, mapM, sequence_, mapM_

Для упрощения работы с монадами есть набор хелперов
```hs
import Control.Monad
-- функции с подчеркиванием (sequence_, mapM_, ...)
-- проводят монадические вычисления через оператор `>> then, sequence`
-- что означает, что работают с эффектами а не значениями (типа "запись в ...", в отличие от "чтения из ...")

ghci> :i Control.Monad.sequence_ -- работает с эффектами, игнорирует значения
sequence_ :: (Foldable t, Monad m) => t (m a) -> m () -- Defined in ‘Data.Foldable’

-- берет список монад, выполняет `>> then, sequence` над ними в правой свертке
sequence_ = foldr (>>) (return ()) -- foldr binop ini

ghci> sequence_ [Just 1, Just 2]
Just ()
ghci> sequence_ [Just 1, Nothing, Just 3]
Nothing -- поймали эффект

ghci> sequence_ ["12", "3456"]
[(),(), (),(), (),(), (),()] -- эффект это структура монады списка, размер 2*4=8

-- предыдущая реализация
putStr :: String -> IO ()
putStr [] = return ()
putStr (x : xs) = (putChar x) >> (putStr xs) -- рекурсивно связываем через `then, sequence` с выводом хвоста

-- может быть записана как
putStr :: String -> IO ()
putStr = sequence_ . map putChar -- делаем из строки список монад и его секвенсируем (производим эффекты)

-- demo
ghci> sequence_ $ map putChar "abc\n"
abc
abghci> sequence_ [putChar 'a', putChar 'b', putChar '\n']
ab
ghci> :t (sequence_ [putChar 'a', putChar 'b', putChar '\n'])
(sequence_ [putChar 'a', putChar 'b', putChar '\n']) :: IO ()

-- есть обобщение для `sequence_ . map`
ghci> :i Control.Monad.mapM_
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m () -- Defined in ‘Data.Foldable’
mapM_ k = sequence_ . map k -- применить стрелку К. ко всем элементам и потом секвенсировать (накопить эффекты)

-- вывод строки используя хелперы
putStr :: String -> IO ()
putStr = mapM_ putChar -- делаем из строки список монад и его секвенсируем (производим эффекты)

ghci> mapM_ putChar "abc\n"
abc

-- эффекты монады списка, демо

-- почему 8 а не 6? WTF?
ghci> mapM_ (\ x -> [x, x]) "ABC" -- сначала делает map, получает список из трех двух-элементных списков
[(),(),(),(), (),(),(),()] -- секвенс делает эффект списка: вложенные циклы, матрешка из трех циклов, по две итерации в каждом

-- первая часть для каждой буквы дала удвоение буквы, три списка по два элемента внутри списка на три элемента
ghci> map (\ x -> [x,x]) "ABC"
["AA","BB","CC"]
-- sequence_ по каждому из трех списков разветвляется: два раза на первом, два на втором и два на третьем: 2*2*2=8

-- 3*2*2=12
ghci> length $ sequence_ ["abc", "bc", "cd"]
12
-- 3*3*2=18
ghci> length $ sequence_ ["abc", "bcd", "cd"]
18

-- полноценные версии sequence, mapM
-- используется bind, производятся эффекты и вычисляются значения (в список значений)

ghci> :i sequence
type Traversable :: (* -> *) -> Constraint
class (Functor t, Foldable t) => Traversable t where
  ...
  sequence :: Monad m => t (m a) -> m (t a) -- Defined in ‘Data.Traversable’

-- список монад трансформировать в монаду над списком значений
sequence ms = foldr k (return []) ms where
    k :: Monad m => m a -> m [a] -> m [a] -- operator Cons for list inside monad
    k mx mxs = do
        x <- mx
        xs <- mxs
        return (x : xs)

ghci> :i Control.Monad.mapM
type Traversable :: (* -> *) -> Constraint
class (Functor t, Foldable t) => Traversable t where
  Prelude.mapM :: Monad m => (a -> m b) -> t a -> m (t b) -- Defined in ‘Data.Traversable’

-- стрелку К. применить к списку, секвенсировать список монад
mapM k = sequence . map k

-- demo

ghci> sequence [Just 1, Just 2]
Just [1,2]
ghci> sequence [Just 1, Nothing, Just 2]
Nothing

ghci> sequence ["ab", "cd", "ef"] -- 2*2*2
["ace","acf","ade","adf", "bce","bcf","bde","bdf"]

ghci> sequence [getLine, getLine]
foo
bar
["foo","bar"]

ghci> sequence [putChar 'a', putChar '\n']
a
[(),()]

ghci> mapM putChar "ab\n"
ab
[(),(),()]

-- extra

-- почему вывод `ab` а не `ba`?
putChar 'a' >> (putChar 'b' >> return ()) -- ассоциативность правая генерирует лямбды, которые срабатывают слева-направо
~>   putChar 'a' >>= \_ -> putChar 'b' >> return () 
~>   \w -> case putChar 'a' w of (w',a) -> (\_ -> putChar 'b' >> return ()) a w'
... -- на пат.мат. в case of срабатывает форсирование вычислений
-- вычисления и производство эффектов не зависит от записи (право лево-ассоциативной) и всегда слева-направо.
-- от смены ассоциативности зависит смена ассоциативности "накопления" эффектов, но реализация монады должна соблюдать третий закон
```
repl

```hs
{--
На этом шаге вы будете работать с монадой IO, а значит, ваша программа будет взаимодействовать с операционной системой
Чтобы тестирующая система смогла оценить вашу программу, пожалуйста, используйте только функции, 
работающие с файлами и директориями

getDirectoryContents, removeFile

Все эти функции уже будут находиться в области видимости,
так что вам не следует их импортировать. 
По той же причине, главная функция вашей программы будет называться не `main`, а `main'` (со штрихом).

В этом задании ваша программа должна попросить пользователя ввести любую строку, 
а затем удалить все файлы в текущей директории, в именах которых содержится эта строка,
выдавая при этом соответствующие сообщения

Substring: 

Пользователь вводит любую строку:

Substring: hell

Затем программа удаляет из текущей директории файлы с введенной подстрокой в названии.

К примеру, если в текущей директории находились файлы 
thesis.txt, kitten.jpg, hello.world, linux_in_nutshell.pdf, 
то вывод будет таким:

Substring: hell
Removing file: hello.world
Removing file: linux_in_nutshell.pdf

Если же пользователь ничего не ввёл (просто нажал Enter), следует ничего не удалять и сообщить об этом

Substring: 
Canceled

Для получения списка файлов в текущей директории используйте функцию `getDirectoryContents`
https://hackage.haskell.org/package/directory-1.2.3.1/docs/System-Directory.html#v:getDirectoryContents
передавая ей в качестве аргумента строку, состоящую из одной точки  ("."), что означает «текущая директория»

Для удаления файлов используйте функцию `removeFile`
https://hackage.haskell.org/package/directory-1.2.3.1/docs/System-Directory.html#v:removeFile
считайте, что в текущей директории нет поддиректорий — только простые файлы

В выводимых сообщениях удаленные файлы должны быть перечислены в том же порядке, в котором их возвращает функция `getDirectoryContents`

Пожалуйста, строго соблюдайте приведенный в примере формат вывода.
Особое внимание уделите пробелам и переводам строк!
Не забудьте про пробел после Substring:, а также про перевод строки в конце.
ожидается, что вы будете использовать putStrLn для вывода сообщений об удалении
--}
main' :: IO ()
main' = ?

-- solution

main' :: IO ()
main' = do
    putStr "Substring: "
    substr <- getLine
    if null substr then putStrLn "Canceled" else removeFiles substr

removeFiles substr = do
    names <- getFiles
    mapM_ (removeMatchingFile substr) names

getFiles =
    -- return ["thesis.txt", "kitten.jpg", "hello.world", "linux_in_nutshell.pdf"]
    getDirectoryContents "."

removeMatchingFile substr fileName = do
    if fileName `contains` substr then doRemoveFile else skipRemoval where
        skipRemoval = return ()
        doRemoveFile = do
            putStrLn $ "Removing file: " ++ fileName
            -- return () 
            removeFile fileName

contains fileName substr = substr `L.isInfixOf` fileName

-- alternative

import Data.List
main' :: IO ()
main' = do
  putStr "Substring: "
  substr <- getLine
  if substr == ""
    then putStrLn "Canceled"
    else do
      files <- getDirectoryContents "."
      let files' = filter (isInfixOf substr) files
      mapM_ (\x -> putStrLn ("Removing file: " ++ x) >> removeFile x) files'
```
test

## chapter 5.6, Монада Reader

https://stepik.org/lesson/8441/step/1?unit=1576

- Простейший Reader
- Универсальный Reader 1
- Универсальный Reader 2

### 5.6.2 Reader `((->) e)`

Идея заключается в том, что в процессе монадических вычислений мы можем что-то брать из общего для всей цепочки "окружения".
Читать конфиг, контекст (e - environment, r - read).
Простейший ридер: функциональная стрелка со связанным первым аргументом.
Т.е. опять возвращаемся к монаде над стрелочным типом.
```hs
-- напомним, как выглядел функтор на стрелке
instance Functor ((->) e) where
    fmap :: (a -> b) -> f a -> f b -- где `f a = e -> a`; `f b = e -> b`
    fmap g h = g . h

(a -> b) -> f a -> f b
~>
(a -> b) -> (e -> a) -> (e -> b) -- два параметра для fmap: стрелка-из-а-в-бе, стрелка-из-е-в-а. На выходе стрелка из-е-в-бе
-- очевидно, что fmap это композиция функций (применяем а-в-бэ над результатом в-в-а)

-- пример

-- возведение в квадрат это функция `a -> a`
-- length это `[a] -> Int`, где `[a]` это `e`-nvironment: енв. это список (в данном случае)
-- два аргумента скормили в fmap
-- на выходе стрелка из списка в бе: список это env.
ghci> :t fmap (^2) length
fmap (^2) length :: Foldable t => t a -> Int
-- как это читать: fmap это метод функтора, первый аргумент - функция, второй - функтор (над функцией [a] -> Int), ридер
-- т.е. читаем длину и применяем функцию (в-квадрат)

ghci> fmap (^2) length "abc" -- енв: список из трех элементов
9

-- перейдем к монаде Reader

instance Monad ((->) e) where
    return :: a -> (e -> a) -- pure, уже подставили сигнатуру типа монады
    return x = \ _ -> x -- тривиальная упаковка значения в стрелку, первый параметр нас тут не интересует

    (>>=) :: m a -> (a -> m b) -> m b -- bind, каноническая сигнатура
    (>>=) :: (e -> a) -> (a -> e -> b) -> (e -> b) -- после подстановки сигнатуры монады
    -- реализация вытекает из сигнатуры: в монаду-слева скармливается енв,
    -- к полученному значению применяется стрелка Клейсли. с доп. параметром енв.
    m (>>=) k =
        \ e -> k (m e) e -- m :: e -> a; k :: a -> e -> b
    -- m, k, e: три параметра в bind
-- видно, что енв. протаскивается через всю цепочку монадических вычислений

-- примеры использования

-- безопасная голова на енв-списке, возвращает опциональную голову списка
safeHead = do -- pointfree
    b <- null -- is empty?
    if b then return Nothing
    else do
        h <- head
        return $ Just h

safeHead xs = do -- not pointfree
    b <- null xs -- is empty? -- обращение к окружению
    if b then return Nothing
    else do
        h <- head xs -- обращение к окружению
        return $ Just h

-- альтернативная запись, в левой части bind нам нужна стрелка, используем `id`
safeHead = do
    e <- id -- обращаемся к енв
    if null e
        then return Nothing
        else return $ Just (head e)
```
repl

```hs
{--
Не используя интерпретатор, вычислите значение следующего выражения:

return 2 >>= (+) >>= (*) $ 4
--}

-- solution
24
-- почему?
Монадическая цепочка вычислений на монаде-стрелке (ридер), где environment протаскивается в каждое вычисление, см. реализацию bind.
т.е. тут `4` это environment: `(2 + 4) * 4`
```
test

```hs
{--
При работе с монадой Reader, каков смысл оператора `(>>)`?

- (нет) Этот оператор позволяет передать одно и то же значение (окружение) в качестве аргумента нескольким функциям в цепочке композиций
- (нет) Этот оператор позволяет изменить окружение
- (нет) Этот оператор позволяет вычислить произвольную функцию от окружения
- (да) В сочетании с монадой Reader этот оператор бесполезен
--}

-- solution
Оператор `>>` aka `then` aka `sequence` выполняет и протаскивает эффекты но игнорирует результат левого вычисления.
У монады "ридер" эффект это "environment", который протаскивается во все вычисления.

ghci> (2+) >> (3*) $ 4
12
-- `2+4` выполняется (из-за лени: нет), но игнорируется, `3*4` выполняется и возвращается

Бесполезен: да, все вычисления кроме последнего игнорируются.
Позволяет передать ... композиций: формально да, позволяет и передает. Но что такое "цепочка композиций"?
Позволяет изменить ...: нет, такого нет вовсе.
Позволяет вычислить произвольную ...: формально нет, только `e -> a, e -> b`.

instance Monad ((->) e) where
    return :: a -> (e -> a) -- pure, уже подставили сигнатуру типа монады
    return x = \ _ -> x -- тривиальная упаковка значения в стрелку, первый параметр нас тут не интересует

    (>>=) :: m a -> (a -> m b) -> m b -- bind, каноническая сигнатура
    (>>=) :: (e -> a) -> (a -> e -> b) -> (e -> b) -- после подстановки сигнатуры монады
    -- реализация вытекает из сигнатуры: в монаду-слева скармливается енв,
    -- к полученному значению применяется стрелка Клейсли. с доп. параметром енв.
    m (>>=) k =
        \ e -> k (m e) e -- m :: e -> a; k :: a -> e -> b
    -- m, k, e: три параметра в bind

    (>>) :: m a -> m b -> m b -- operator "then" or "sequence"
    (>>) :: (e -> a) -> (e -> b) -> (e -> b)
    mx >> my = mx >>= (\ _ -> my) -- связываем два монадических вычисления, второе-пустышка
```
test

### 5.6.5 newtype Reader, ask

Для большего удобства завернем стрелку (доступа к енв.) в некий тип
```hs
newtype Reader r a = Reader { runReader :: (r -> a) } -- завернули стрелку в тип `Reader r a`, двухпараметрический

-- new ghc fix
import Control.Applicative
import Control.Monad (liftM, ap)
instance Functor (Reader r) where
    fmap = liftM
instance Applicative (Reader r) where
    pure  = return
    (<*>) = ap
-- end of fix

:t runReader
runReader :: Reader r a -> r -> a

-- для создания монады надо связать первый параметр (окружение)

instance Monad (Reader r) where
    return x = Reader (\ e -> x)
    m >>= k  = Reader (\ e ->
        let x = runReader m e -- лениво, левое вычисление
        in runReader (k x) e) -- правое вычисление
-- та же история, протаскивает енв. через оба вычисления в bind

-- внутри монадических вычислений мы применяли ф. `id` для вытаскивания енв. в левой части bind
-- сделаем более семантически корректный враппер для этого
ask :: Reader r r -- `r -> r`, фактически и есть `id`
ask = Reader id

runReader ask 42
42

-- пример использования

type User = String
type Password = String
type UserTable = [(User, Password)]
pwds :: UserTable
pwds = [("Bill", "123"), ("Ann", "qwerty"), ("John", "pG3-")]

firstUser :: Reader UserTable User -- чтение из таблицы, таблица=енв, юзер=тип ридера: `UserTable -> User`
firstUser = do
    e <- ask -- получили таблицу
    return $ fst (head e) -- первая строчка, первый элемент

runReader firstUser pwds
"Bill"
```
repl

### 5.6.6 функции asks, local, reader

Бывает удобно получать не полный ридер а его часть (или трансформированный ридер).
Для этого в либе есть удобные хелперы
```hs
-- рассмотрим пример

asks :: (r -> a) -> Reader r a
asks = Reader -- конструктор ридера из аргумента-функции
-- параметр: функция чтения элемента из енва

ask = asks id -- частный случай

-- ридер пароля первой записи
firstUserPwd :: Reader UserTable Password
firstUserPwd = do
    pwd <- asks (snd . head) -- применили ф. к енв. и получили ридер
    return pwd

runReader firstUserPwd pwds
"123"

-- а теперь упростим: по законам монад, правый return не влияет на результат
firstUserPwd :: Reader UserTable Password
firstUserPwd = do
    asks (snd . head)
-- не нужен bind, вот так хорошо:
firstUserPwd :: Reader UserTable Password
firstUserPwd = asks (snd . head)

-- продолжим иллюстрации

usersCount :: Reader UserTable Int
usersCount = asks length

-- локальная трансформация енв, функция `local`:
-- берет трансформер и старый ридер, возвращает новый ридер

local :: (r -> r) -> Reader r a -> Reader r a
local f mr = Reader (\ e -> runReader mr (f e)) -- runReader :: Reader r a -> r -> a
-- r это таблица pwds в данных примерах
-- стрелка r -> r это трансформер таблицы
-- енв оторван, абстрагирован через лямбду, придет потом, при использовании
-- Reader это функция над енв. поэтому модификация енва в Reader это композиция функций

localTest :: Reader UserTable (Int, Int)
localTest = do
    count1 <- usersCount -- ридер читающий длину таблицы (для енв переданного сверху)
    count2 <- local (("Mike", "xz") : ) usersCount -- local трансформер ридер
    -- второй счетчик берется из модифицированного ридера
    -- модифицированный ридер: применяется функция (подклеить голову) к енв, потом применяется ридек usersCount к новому енв
    return (count1, count2)
-- этот фокус работает, ибо енв (таблица) протаскивается через цепочку монадических вычислений, за кадром, через лямбду в bind,
-- тут это не заметно, но оно есть
-- если расписать полную явную цепочку вычислений (лямбды дают ленивость дополнительную, таблица идет по пайплайну)

runReader localTest pwds
(3,4)

-- reader, конструктор ридера
reader :: (r -> a) -> Reader r a
reader f = do
    r <- ask -- левая часть bind, вытаскиваем енв
    return (f r) -- формируем новый ридер на вытащенном енв
{--
Конструктор с маленькой буквы полезен (как и в других монадах) ибо

MTL: monad transfer library
библиотека преобразования монад (расширения перечня эффектов, накручивая монаду на монаду)
к примеру, накрутить Maybe потом Reader, ...
В либе нет простых нативных конструкторов.

И нативные конструкторы монад, определенные в этой либе нам мало полезны и неудобны и недоступны.
Поэтому есть выставленные наружу интерфейсные методы - конструкторы.
--}
```
repl

https://hackage.haskell.org/package/transformers-0.5.1.0/docs/Control-Monad-Trans-Reader.html

```hs
{--
В последнем видео мы познакомились с функцией `local`
позволяющей произвести некоторое вычисление во временно измененном окружении
При этом значение, задающее новое окружение, имело тот же тип, что и исходное

Если попытаться обобщить эту функцию таким образом, чтобы новое окружение потенциально имело другой тип
какая сигнатура будет у обобщенной функции `local'`?

Select one option from the list
- local' :: (r' -> r) -> Reader r' a -> Reader r a
- (да) local' :: (r -> e) -> Reader e a -> Reader r a
- local' :: (r -> r') -> Reader r' a -> Reader r ()
- local' :: (r -> e) -> Reader r a -> Reader e a
- Такая обобщенная функция не может существовать 
--}

-- solution (чтобы новое окружение потенциально имело другой тип)
-- возьмем реализацию и подставим на выходе трансформера енва тип `e`
local :: (r -> r) -> Reader r a -> Reader r a
local f mr = Reader (\env -> runReader mr (f env))
-- f :: r -> e
-- mr :: Reader e a
-- Reader (\env -> ...) :: Readed r a
-- получается
local :: (r -> e) -> Reader e a -> Reader r a
(r -> e) -> (e -> a) -> (r -> a)
-- флипнутая композиция
```
test

```hs
{--
Реализуйте функцию `local'` из прошлого задания
Считайте, что монада `Reader` определена так, как на видео:

data Reader r a = Reader { runReader :: (r -> a) }
instance Monad (Reader r) where
  return x = Reader $ \_ -> x
  m >>= k  = Reader $ \r -> runReader (k (runReader m r)) r
--}
local' :: (r -> r') -> Reader r' a -> Reader r a
local' f m = ?

-- solution
local' :: (r -> r') -> Reader r' a -> Reader r a
local' f m = Reader (\ env -> runReader m (f env))

-- alternative
local' :: (r -> r') -> Reader r' a -> Reader r a
local' f m = Reader $ (runReader m) . f
```
test

```hs
{--
Вспомним пример с базой пользователей и паролей

type User = String
type Password = String
type UsersTable = [(User, Password)]

Реализуйте функцию, принимающую в качестве окружения `UsersTable`
и возвращающую список пользователей, использующих пароль "123456"
в том же порядке, в котором они перечислены в базе

GHCi> runReader usersWithBadPasswords [("user", "123456"), ("x", "hi"), ("root", "123456")]
["user","root"]
--}
usersWithBadPasswords :: Reader UsersTable [User]
usersWithBadPasswords = ?

-- solution

usersWithBadPasswords :: Reader UsersTable [User]
usersWithBadPasswords = asks (map fst . selected) where
    selected = filter (\ (_, pwd) -> pwd == "123456")

-- alternative

usersWithBadPasswords :: Reader UsersTable [User]
usersWithBadPasswords =
    asks (\ table -> do
        (user, "123456") <- table
        return user)

usersWithBadPasswords :: Reader UsersTable [User]
usersWithBadPasswords = asks (usersWithPassword "123456") where
    usersWithPassword = (map fst .) . filter . (. snd) . (==)

usersWithBadPasswords :: Reader UsersTable [User]
usersWithBadPasswords = do
  e <- ask
  return [ fst x | x <- e, snd x == "123456"]

usersWithBadPasswords :: Reader UsersTable [User]
usersWithBadPasswords = let badPassword = "123456" in
    local (filter (\(u, p) -> p == badPassword)) (Reader $ map fst)
```
test

## chapter 5.7, Монада Writer

https://stepik.org/lesson/8442/step/1?unit=1577

- Монада Writer
- Интерфейс для монады Writer 

### 5.7.2 Monad Writer

Монада нужна для такого эффекта:
запись (в лог), простая реализация которого выполнена через пару `(a, b)`
где `a` это моноид лога (доступны бинарная операция свертки и нейтраль), `b` это наше вычисляемое значение.

Как это может быть реализовано
```hs
-- алиас = конструктор { метка-доступа-к-внутреннему-значению }
newtype Writer w a = Writer { runWriter :: (a, w) } -- n.b. флипнуты типы
runWriter :: Writer w a -> (a, w)
-- w тип лога, a тип вычисляемого значения

-- конструктор, для имитации стдлиб
writer :: (a, w) -> Writer w a
writer = Writer

-- получить эффект и проигнорировать значение, хелпер
execWriter :: Writer w a -> w
execWriter m = snd (runWriter m)

-- reference
import Control.Monad
import Data.Monoid
class Monad m where
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b --  bind
    (>>) :: m a -> m b -> m b -- then, sequence
instance (Monoid w) => Functor (Writer w) where
    fmap = liftM
instance (Monoid w) => Applicative (Writer w) where
    pure = return
    (<*>) = ap
-- end of reference

-- монада Writer

instance (Monoid w) => Monad (Writer w) where
    return x = writer (x, mempty) -- нейтральное значение лога
    m >>= k = -- bind
        let -- монада и стрелка Клейсли на входе
            (x1, w1) = runWriter m -- левое вычисление, достали содержимое из монады
            (x2, w2) = runWriter (k x1) -- правое вычисление
        in writer (x2, (w1 `mappend` w2)) -- накопление лога

-- examples

ghci> import Control.Monad.Writer

-- лог: моноид строки
ghci> runWriter (return 42 :: Writer String Int)
(42,"") -- mempty = ""

-- лог: моноид суммы чисел
ghci> runWriter (return 42 :: Writer (Sum Int) Int)
(42,Sum {getSum = 0})  -- mempty = 0

-- лог: моноид произведения чисел
ghci> runWriter (return 42 :: Writer (Product Int) Int)
(42,Product {getProduct = 1}) -- mempty = 0

-- вычислить и достать эффект
ghci> execWriter (return 42 :: Writer (Product Int) Int)
Product {getProduct = 1}
```
repl

В стдлиб обычно используется соглашение:
- `runFoo` для запуска вычислений в монаде (и значение и эффекты),
- `execFoo` для получения эффектов от вычислений (значение игнорируется),
- `evalFoo` для получения значения и игнорирования эффектов

```hs
{--
Функция `execWriter` запускает вычисление, содержащееся в монаде `Writer`
и возвращает получившийся лог, игнорируя сам результат вычисления
Реализуйте функцию `evalWriter`, которая, наоборот,
игнорирует накопленный лог и возвращает только результат вычисления
--}
evalWriter :: Writer w a -> a
evalWriter = ?

-- solution

evalWriter :: Writer w a -> a
evalWriter = fst . runWriter

-- reference

execWriter :: Writer w a -> w
execWriter m = snd (runWriter m)
```
test

```hs
{--
Выберите все верные утверждения про монаду `Writer`

- В качестве типа лога можно использовать произвольную группу
- Тип результата вычисления и тип лога не могут совпадать
- Тип результата вычисления и тип лога могут как совпадать, так и не совпадать
- В качестве типа лога можно использовать произвольный тип
- Тип результата вычисления и тип лога должны совпадать
- В качестве типа результата вычисления можно использовать произвольный тип 
--}
{--
- полугруппа - это где есть ассоциативная бинарная операция
- моноид - это полугруппа с единицей
- группа - это моноид с обратными элементами
- Не любой моноид - группа, но любая группа - уже моноид.
--}

-- solution

- (да) В качестве типа лога можно использовать произвольную группу
- Тип результата вычисления и тип лога не могут совпадать
- (да) Тип результата вычисления и тип лога могут как совпадать, так и не совпадать
- В качестве типа лога можно использовать произвольный тип
- Тип результата вычисления и тип лога должны совпадать
- (да) В качестве типа результата вычисления можно использовать произвольный тип 

Лог это моноид, значение любое.
```
test

### 5.7.5 функция tell

Вспомогательные функции для монады Writer
```hs
-- функция записи в лог, по сути: заворачивание моноида в монаду Writer (стрелка Клейсли)
-- позволяет писать в лог находясь внутри цепочки монадических вычислений
-- tell (writer) vs ask (reader)
tell :: (Monoid w) => w -> Writer w ()
tell w = writer ((), w)

-- ффект монады Writer - запись в лог
-- При сцеплении двух монадических вычислений в этой монаде с помощью (>>=) или (>>) логи соединяются с помощью mappend
ghci> runWriter $ tell "A" >> tell "B" >> tell "C" -- конкатенация трех списков
((),"ABC")

-- example

calc :: (Int -> Int -> Int) -> Int -> Int -> Writer String Int
calc op x y = do
    let res = x `op` y
    tell $ (show x) ++ " op " ++ (show y) ++ " = " ++ (show res) ++ " " -- для иллюстрации аппенда лога
    if abs res < 128 then
        return res
    else do
        tell "overflow"
        return res

ghci> execWriter $ calc (+) 33 44
""
ghci> runWriter $ calc (+) 33 44
(77,"")
ghci> runWriter $ calc (+) 99 44
(143,"overflow")

-- лог аппендится
ghci> runWriter $ calc (+) 33 44
(77,"33 op 44 = 77")
ghci> runWriter $ calc (+) 99 44
(143,"99 op 44 = 143 overflow")
```
repl

```hs
{--
Давайте разработаем программное обеспечение для кассовых аппаратов одного исландского магазина
Заказчик собирается описывать товары, купленные покупателем, с помощью типа `Shopping` следующим образом

type Shopping = Writer (Sum Integer) ()

shopping1 :: Shopping
shopping1 = do
  purchase "Jeans"   19200
  purchase "Water"     180
  purchase "Lettuce"   328

Последовательность приобретенных товаров записывается с помощью `do`-нотации
Для этого используется функция `purchase`
которую вам предстоит реализовать

Эта функция принимает наименование товара, а также его стоимость в исландских кронах 
(исландскую крону не принято делить на меньшие единицы, потому используется целочисленный тип Integer)
Кроме того, вы должны реализовать функцию `total`:

GHCi> total shopping1 
19708
--}
purchase :: String -> Integer -> Shopping
purchase item cost = ?

total :: Shopping -> Integer
total = ?

-- solution

import Data.Monoid
import Control.Monad
import Control.Monad.Writer ( Writer, writer, runWriter, tell )
type Shopping = Writer (Sum Integer) () -- двух-параметрический конструктор: моноид-суммы, юнит
-- по факту, весь шоппинг это накапливание суммы в виде эффекта, значение нас не интересует

purchase :: String -> Integer -> Shopping
purchase item cost = do
    tell $ Sum cost

total :: Shopping -> Integer
total = getSum . snd . runWriter -- можно было использовать exec

```
test

```hs
{--
Измените определение типа `Shopping` и доработайте функцию `purchase`
из предыдущего задания таким образом, чтобы можно было реализовать функцию `items`
возвращающую список купленных товаров 
(в том же порядке, в котором они были перечислены при покупке):

shopping1 :: Shopping
shopping1 = do
  purchase "Jeans"   19200
  purchase "Water"     180
  purchase "Lettuce"   328

GHCi> total shopping1 
19708
GHCi> items shopping1
["Jeans","Water","Lettuce"]

Реализуйте функцию `items` и исправьте функцию `total`, чтобы она работала как и прежде
--}
type Shopping = Writer ? ()

purchase :: String -> Integer -> Shopping
purchase item cost = ?

total :: Shopping -> Integer
total = ?

items :: Shopping -> [String]
items = ?

-- solution

type Shopping = Writer (Sum Integer, [String]) ()

purchase :: String -> Integer -> Shopping
purchase item cost = do
    tell (Sum cost, [item])

total :: Shopping -> Integer
total = getSum . fst . execWriter

items :: Shopping -> [String]
items = snd . execWriter

-- alternative

type Shopping = Writer [(String, Integer)] ()

purchase :: String -> Integer -> Shopping
purchase v i = tell $ return (v, i)

total :: Shopping -> Integer
total = sum . map snd . execWriter

items :: Shopping -> [String]
items = map fst . execWriter
```
test

## chapter 5.8, Монада State

https://stepik.org/lesson/8444/step/1?unit=1579

- Монада State
- Интерфейс для монады State
- Программирование в монаде State

### 5.8.2 Monad State

Изменяемое состояние, сопровождающее цепочку монадических вычислений.
Комбинация Reader, Writer монад.
На каждом шаге пайплайна может быть создан новый объект стейта, который затем передается downstream.
```hs
-- имеем внутри стрелочный тип, как в Reader
-- имеем внутри пару, как в Writer
newtype State s a = State { runState :: s -> (a, s) } -- алиас вокруг стрелки `s -> (a,s)`
runState :: State s a -> s -> (a, s) -- можно читать как "функция двух аргуметов, возвращает пару"
runState :: State s a -> (s -> (a, s)) -- а можно как "функция одного аргумента, возвращает функцию одого аргумента"
-- в любом прочтении, для получения результатов вычислений, надо скормить два параметра: ньютайп и затравку стейта

class Monad m where
    return :: a -> m a -- pure
    (>>=) :: m a -> (a -> m b) -> m b --  bind
    (>>) :: m a -> m b -> m b -- then, sequence

instance Monad (State s) where
    return a = State (\ st -> (a, st)) -- заворачиваем стрелку -- pure, как лямбда завернутая в newtype
    return a = State $ \st -> (a, st) -- альтернативная запись -- pure
    -- на входе (в bind) монада и стрелка Клейсли, на выходе монада
    m >>= k = 
        State $ \st1 -> -- заворачиваем стрелку
            let
                (a, st2) = runState m st1 -- первое вычисление, левая часть bind
                m2 = k a -- создадим второе вычисление, очередность правильная, правая часть bind
            in runState m2 st2 -- и запускаем второе вычисление на (возможно модифицированном) стейте

-- два хелпера

execState :: State s a -> s -> s -- интересует стейт на выходе
execState m s = snd (runState m s)

evalState :: State s a -> s -> a -- интересует значение на выходе
evalState m s = fst (runState m s)
```
repl

```hs
{--
Выберите все верные утверждения про монаду `State`

- Монада State является частным случаем монады Writer
- Монада State является частным случаем монады Reader
- Монада Writer является частным случаем монады State 
--}

-- solution

- Монада State является частным случаем монады Writer
- Монада State является частным случаем монады Reader
- (да) Монада Writer является частным случаем монады State 

Если спросить "можно ли реализовать reader/writer через state" и наоборот, то ...
да, можно. Наоборот? Нет, нельзя

newtype State s a  = State  { runState :: s -> (a, s) }
newtype Reader r a = Reader { runReader :: (r -> a) }
newtype Writer w a = Writer { runWriter :: (a, w) }
```
test

```hs
{--
Где реализована монада `State`?
Select one option from the list

- Монада State реализована в одном из пакетов Haskell Platform
- Монада State встроена в компилятор GHC, поскольку позволяет осуществлять вычисления с изменяемым состоянием, что невозможно в «чистом» Хаскеле 
--}

-- solution

- (да) Монада State реализована в одном из пакетов Haskell Platform
- Монада State встроена в компилятор GHC, поскольку позволяет осуществлять вычисления с изменяемым состоянием, что невозможно в «чистом» Хаскеле 

Смысл этого вопроса, вероятно, в том, что речь идет о "мутабельном" стейте а язык чисто функциональный, без мутабельности.
Ответ очевиден, если подумать (или посмотреть) о цепочке монадических вычислений в этой монаде.
Там нет мутаций, там есть создание нового стейта (или пробрасывание старого).
```
test

### 5.8.5 функции get, put, modify

Стандартный интерфейс для монады State (get, put)
чтение и запись эффекта (стейта)
```hs
-- завернутый в монаду id (как бы) -- ask
get :: State s s
get = State $ \ st -> (st, st) -- прокидывает внешний стейт

-- стрелка Клейсли, -- tell
put :: s -> State s ()
put st = State $ \ _ -> ((), st) -- игнорирует внешний стейт, кладет в монаду новый

-- examples

ghci> import Control.Monad.State
ghci> runState get 42
(42,42)

ghci> runState (put 7) 42
((),7)

-- при каждом использовании увеличивает счетчик
tick :: State Int Int
tick = do -- тут три bind, чтобы осознать детали, надо вспомнить как реализован bind для Monad State
    n <- get -- получает стейт
    put (n + 1) -- обновляет стейт
    return n -- возвращает старый стейт как значение (и новый стейт как эффект)

ghci> runState tick 5
(5,6) -- (старый стейт как значение, новый стейт как эффект)

-- `modify`, Kleisli arrow
-- обновляет (put) стейт через переданную функцию трансформации стейта
modify :: (s -> s) -> State s ()
modify f = State $ \ s -> ((), f s) -- пакует стрелку: из оригинального стейта в трансформированный стейт
modify f = do -- альтернативная реализация
    s <- get
    put (f s)

ghci> runState (modify (^2)) 5
((),25)
```
repl

```hs
{--
Давайте убедимся, что с помощью монады `State` можно эмулировать монаду `Reader`
Напишите функцию `readerToState`, «поднимающую» вычисление из монады `Reader` в монаду `State`

GHCi> evalState (readerToState $ asks (+2)) 4
6
GHCi> runState (readerToState $ asks (+2)) 4
(6,4) 
--}
readerToState :: Reader r a -> State r a
readerToState m = ?

-- solution

-- смотрим на сигнатуры
-- newtype State s a  = State  { runState :: s -> (a, s) }
-- newtype Reader r a = Reader { runReader :: (r -> a) }
-- видим, что нам нужно стрелку ридера превратить в похожую стрелку, но на выходе пара (a, r)

-- import Control.Monad.State ( ap, liftM, State, runState, evalState, execState, get, put, modify, state )
readerToState :: Reader r a -> State r a
readerToState rm = state valStatePair where
    valStatePair givenState = (runReader rm givenState, givenState)

-- alternative

readerToState :: Reader r a -> State r a
readerToState m = State $ \st -> (runReader m st, st)
```
test

```hs
{--
Теперь убедимся, что с помощью монады `State` можно эмулировать монаду `Writer`
Напишите функцию `writerToState`, «поднимающую» вычисление из монады `Writer` в монаду `State`:

GHCi> runState (writerToState $ tell "world") "hello,"
((),"hello,world")
GHCi> runState (writerToState $ tell "world") mempty
((),"world")

Обратите внимание на то, что при работе с монадой `Writer` предполагается, что изначально лог пуст
(точнее, что в нём лежит нейтральный элемент моноида), 
поскольку интерфейс монады просто не позволяет задать стартовое значение.
Монада `State` же начальное состояние (оно же стартовое значение в логе) задать позволяет
--}
writerToState :: Monoid w => Writer w a -> State w a
writerToState m = ?

-- solution

-- моноид w напоминает, что лог надо накапливать, поэтому mappend
-- newtype State s a  = State  { runState :: s -> (a, s) }
-- newtype Writer w a = Writer { runWriter :: (a, w) }
-- import Control.Monad.Writer ( Writer, writer, runWriter, execWriter, tell )

writerToState :: Monoid w => Writer w a -> State w a
writerToState wa = state valStatePair where
    valStatePair givenState = (a, givenState `mappend` w)
    (a, w) = runWriter wa -- значение и лог из данного врайтера

-- alternative

writerToState :: Monoid w => Writer w a -> State w a
writerToState m = State $ \s -> let (v, l) = runWriter m in (v, s `mappend` l)
```
test

### 5.8.8 examples (tick), `replicateM = sequence . replicate`

Примеры на базе функции `tick`
```hs
tick :: State Int Int -- тут стрелки не видно, но она есть, стейт это монада над стрелочным типом
tick = do
    n <- get
    put (n + 1) -- new state
    return n -- new value

ghci> runState tick 5
(5,6) -- (value, state) предыдущее значение в качестве "значения"

ghci> execState tick 5
6

succ :: Int -> Int
succ n = execState tick n -- only state

-- сумма через список тиков
plus :: Int -> Int -> Int
plus n x = execState (sequence (replicate n tick)) x
-- replicate n tick -- list
-- sequence (replicate n tick) -- список монад в монаду списка
-- идея в том, чтобы эн раз добавить единицу через превращение списка в цепочку монадических тиков
-- стартовое значение будет х

ghci> runState (sequence (replicate 4 tick)) 5
([5,6,7,8],9) -- список значений цепочки монад.вычислений, эффект (стейт) = 9

ghci> runState (sequence_ (replicate 4 tick)) 5 -- `sequence_` игнорирует значения
((),9)

-- композиция sequence . replicate
-- настолько часто используется для порождения цепочки монад.вычислений
sequence $ replicate n
-- что сделали отдельную функцию
replicateM n = sequence . replicate n

ghci> :i replicateM
replicateM :: Applicative m => Int -> m a -> m [a] -- Defined in ‘Control.Monad’

plus n x = execState (replicateM n tick) x

ghci> runState (replicateM 4 tick) 5
([5,6,7,8],9)
```
repl

К этому моменту должно быть понятно, что, поскольку монады это интерфейсы и законы для тайп-классов,
мы можем части программы заворачивать в монадические вычисления и компоновать их всяко.
Абстракция вычислений с эффектами, стандартные интерфейсы -- инструменты ФП модуляризации программ.

```hs
{--
Если бы мы хотели вычислить n-е число Фибоначчи на императивном языке программирования
мы бы делали это с помощью двух переменных и цикла, обновляющего эти переменные

def fib(n):
  a, b = 0, 1
  for i in [1 .. n]:
    a, b = b, a + b
  return a

С точки зрения Хаскеля, такую конструкцию удобно представлять себе как вычисление с состоянием. 
Состояние в данном случае — это два целочисленных значения

Императивный алгоритм действует очень просто: он совершает n шагов, каждый из которых некоторым образом изменяет текущее состояние. 
Первым делом, реализуйте функцию `fibStep`
изменяющую состояние таким же образом, как и один шаг цикла в императивном алгоритме

GHCi> execState fibStep (0,1)
(1,1)
GHCi> execState fibStep (1,1)
(1,2)
GHCi> execState fibStep (1,2)
(2,3)

После этого останется лишь применить этот шаг n раз к правильному стартовому состоянию и выдать ответ
Реализуйте вспомогательную функцию `execStateN`, которая принимает число шагов n,
вычисление с состоянием и начальное состояние, 
запускает вычисление n раз и выдает получившееся состояние (игнорируя сами результаты вычислений)

Применяя эту функцию к `fibStep`, мы сможем вычислять числа Фибоначчи:

fib :: Int -> Integer
fib n = fst $ execStateN n fibStep (0, 1)
--}
fibStep :: State (Integer, Integer) ()
fibStep = ?

execStateN :: Int -> State s a -> s -> s
execStateN n m = ?

-- solution

-- newtype State s a  = State  { runState :: s -> (a, s) }
fibStep :: State (Integer, Integer) () -- type state value -- runState (value, state)
fibStep = do
    (n1, n2) <- get
    put (n2, n1 + n2)
    return ()

execStateN :: Int -> State s a -> s -> s
execStateN n ms = execState (replicateM n ms)

-- alternative

fibStep :: State (Integer, Integer) ()
fibStep = modify $ \(a,b) -> (b, a + b)

execStateN :: Int -> State s a -> s -> s
execStateN n m = execState $ replicateM_ n m

fibStep :: State (Integer, Integer) ()
fibStep = do
    start <- get
    put (snd start, uncurry (+) start)

execStateN :: Int -> State s a -> s -> s
execStateN n m = execState $ replicateM_ n m
```
test

```hs
{--
Некоторое время назад мы определили тип двоичных деревьев, содержащих значения в узлах

data Tree a = Leaf a | Fork (Tree a) a (Tree a)

В этой задаче вам дано значение типа `Tree ()`, иными словами, вам задана форма дерева.

Требуется пронумеровать вершины дерева данной формы, обойдя их `in-order` 
то есть, сначала обходим левое поддерево, затем текущую вершину, затем правое поддерево

GHCi> numberTree (Leaf ())
Leaf 1
GHCi> numberTree (Fork (Leaf ()) () (Leaf ()))
Fork (Leaf 1) 2 (Leaf 3)
--}
numberTree :: Tree () -> Tree Integer
numberTree tree = ?

-- solution

numberTree :: Tree () -> Tree Integer -- replace values `()` with ordering numbers
numberTree t = evalState (numberTreeS t) 1
-- обойдем дерево с протаскиванием стейта
numberTreeS :: Tree () -> State Integer (Tree Integer) -- state value
-- Tree is a sum type, pat.mat. for 2 cases
numberTreeS (Leaf _) = do
    n <- get
    put (n + 1)
    return (Leaf n) -- set current number
numberTreeS (Fork left _ right) = do
    lt <- numberTreeS left -- in-order: left, node, right
    n <- get
    put (n + 1)
    rt <- numberTreeS right
    return $ Fork lt n rt -- construct current node

-- alternative

numberTree :: Tree () -> Tree Integer
numberTree tree = evalState (number tree) 1
  where
    number :: Tree () -> State Integer (Tree Integer)
    number (Leaf ()) = get >>= \i -> modify (+1) >> return (Leaf i)
    number (Fork l () r) = do
      la <- number l
      i <- get
      modify (+1)
      ra <- number r
      return $ Fork la i ra

-- решение через Traversable

import Control.Applicative
import Data.Traversable
import Data.Foldable
instance Functor Tree where
  fmap = fmapDefault
instance Foldable Tree where
  foldMap = foldMapDefault
instance Traversable Tree where
  traverse g (Leaf x) = Leaf <$> g x
  traverse g (Fork l x r) = Fork <$> traverse g l <*> g x <*> traverse g r
numberTree :: Tree () -> Tree Integer
numberTree tree = evalState (traverse (const $ modify succ >> get) tree) 0
```
test
