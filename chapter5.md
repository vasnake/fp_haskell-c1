# FP Haskell, chapter 5, monads

[Функциональное программирование на языке Haskell / Денис Москвин / stepik](https://stepik.org/course/75/syllabus?next=)

definitions
- Functor: `fmap :: (a -> b) -> f a -> f b` поднимает ф. в контекст, оператор "применения" `<$>`. Структура "контейнера" не меняется.
Законы функтора: 1) `fmap id = id`; 2) `fmap (f . g) = (fmap f) . (fmap g)`

- Monad:

> Правильней о функторах думать как о естественных конструкциях над типами. Контейнер -- это только пример естественной конструкции
мы используем термин "контейнер" в более широком ... смысле, и заменить его на более точный термин - "вычислительный контекст"

## chapter 5.1, Класс типов (type-class) Functor и законы для него

https://stepik.org/lesson/8432/step/1?unit=2743

- Класс типов Functor
- Представитель класса типов Functor для бинарного дерева
- Представители Functor для двухпараметрических типов
- Законы для функторов

### 5.1.2 тайп-классы для конструкторов типов, Functor, fmap

Если тайп-класс для типа с кайндом `*` осознать довольно легко,
то тайп-класс для "конструктора типов", с кайндом `* -> *`
это абстракция более высокого порядка и задает API для (потенциально бесконечного) множества компонент, реализующих этот интерфейс.

Рассмотрим тайп-класс Functor
```hs
-- type-class, полностью полиморфный, без ограничений на типы (переменные типов) a, b, f
-- класс типов параметризован переменной (типа) `f`
class Functor f where
    -- "поднимает" функцию `a -> b` в "контекст" `f`: принимает `f a`, на выходе `f b`
    -- при этом контекст не меняется, нет "эффекта"
    fmap :: (a -> b) -> f a -> f b -- видно, что эф это конструктор типов, ибо "применяется" к а и к бе
-- переменная `f` используется как функция над типами, у нее должен быть "стрелочный кайнд": `* -> *`

-- реализация тайп-класса Функтор для списков: очевидная
instance Functor [] where
    fmap = map

ghci> map succ [1,2,3]
[2,3,4]
ghci> fmap succ [1,2,3]
[2,3,4]

ghci> :i fmap
type Functor :: (* -> *) -> Constraint
class Functor f where
  fmap :: (a -> b) -> f a -> f b -- Defined in ‘GHC.Base’

-- правая ассоциативность скобок для стрелочных типов, позволяет сказать:
-- fmap берет функцию над элементами и возвращает функцию над "контейнерами" элементов
(a -> b) -> f a -> f b -- эквивалентно
(a -> b) -> (f a -> f b)
-- demo
ghci> let fs = fmap succ
ghci> :t fs
fs :: (Functor f, Enum b) => f b -> f b
ghci> fs [1,2,3]
[2,3,4]

ghci> fs $ Just 42
Just 43
-- вы чувствуете мощь концепции тайпклассов? До тех пока тип реализует интерфейс, мы можем его использовать в большом наборе операций,
-- понятия не имеющих о конкретике контекста

instance Functor Maybe where -- два конструктора у Maybe, сигнатуры однозначно определяют реализацию
    -- (a -> b) -> f a -> f b
    fmap _ Nothing = Nothing
    fmap f (Just a) = Just (f a)
```
repl

```hs
https://stepik.org/lesson/8432/step/3?unit=2743
TODO
```
test

```hs
https://stepik.org/lesson/8432/step/4?unit=2743
TODO
```
test

### 5.1.5 Functor Tree

Пример: определим функтор для бинарного дерева
```hs
-- дерево: одно-параметрический тип, только такой можно сделать функтором
-- два конструктора (сумма): лист-со-значением, ветвление-со-значением-и-левой-правой-ветками
-- думается, правильнее было бы не Branch а Node
data Tree a = Leaf a | Branch (Tree a) a (Tree a)
    deriving Show
-- `Branch (Tree a) a (Tree a)` это конструктор данных, принимающий три значения левое-дерево, значение-в-узле, правое-дерево

instance Functor Tree where
    -- (a -> b) -> f a -> f b
    fmap fn (Leaf x) = Leaf $ fn x
    fmap fn (Branch left x right) = Branch (fmap fn left) (fn x) (fmap fn right)
-- рекурсивно проходим дерево, сигнатуры однозначно определяют реализацию

testTree = Branch (Leaf 2) 3 (Leaf 4)
ghci> fmap (^2) testTree -- поднимем возведение в квадрат в дерево
Branch (Leaf 4) 9 (Leaf 16)

-- важно: структура "контейнера" не меняется (нет "эффекта"?). Про законы функтора чуть позже ...

-- оператор - синоним fmap
(^2) `fmap` testTree
ghci> (^2) <$> testTree -- лево-ассоциативный, приоритет 4
Branch (Leaf 4) 9 (Leaf 16)

ghci> :i <$>
(<$>) :: Functor f => (a -> b) -> f a -> f b -- Defined in ‘Data.Functor’
infixl 4 <$>

-- левая ассоциативность "применения": +5 применяется к результату ^2
ghci> (+5) <$> (^2) <$> testTree
Branch (Leaf 9) 14 (Leaf 21)

42 <$ testTree -- что-то вроде `const`
Branch (Leaf 42) 42 (Leaf 42) -- сохраняется структура, значение заменяется на переданное
-- поднимает значение (не функцию) в контекст
ghci> :i <$
type Functor :: (* -> *) -> Constraint
class Functor f where
  ...
  (<$) :: a -> f b -> f a -- Defined in ‘GHC.Base’
infixl 4 <$
```
repl

```hs
https://stepik.org/lesson/8432/step/6?unit=2743
TODO
```
test

### 5.1.7 Функтор для двух-параметрических типов

Как быть с двух-параметрическими типами, вроде `Either` или `(,)` или `->`?
Мы не можем определить одно-параметрический функтор для кайнда `* -> * -> *`, конструктора типов с двумя параметрами.
Надо связать первый параметр
```hs
-- как это сделать для типа Пара (тип-произведение)
instance Functor ((,) s) where
    fmap fn (x, y) = (x, fn y) -- первый элемент пары не трогаем, ко второму применяем функцию
-- связываем первый параметр пары с переменной s, тогда работать функтор будет с вторым значением пары

-- вот так выглядит механика снижения арности у конструктора типов
ghci> :k (,) -- кайнд пары
(,) :: * -> * -> * -- это три звезды: два параметра
ghci> :k (,) Char -- свяжем первый параметр пары с типом Чар
(,) Char :: * -> * -- получим кайнд одно-параметрического конструктора типа

-- посмотрим на тип fmap
(a -> b) -> f a -> f b -- подставляем конструктор пары из определения функтора пары
(a -> b) -> (,) s a -> (,) s b -- перепишем префиксный стиль в инфиксном виде
(a -> b) -> (s, a) -> (s, b) -- вот такой результ. тип у fmap для пары со связанным первым параметром

-- пример
ghci> fmap succ (1, 'a')
(1,'b')

-- похожим образом для Either (тип-сумма)
instance Functor (Either e) where
    fmap _ (Left x) = Left x -- левую часть не трогаем, она связана
    fmap fn (Right x) = Right $ fn x -- работаем с правой частью

ghci> :k Either
Either :: * -> * -> *
ghci> :k Either Char
Either Char :: * -> *

-- тип fmap
(a -> b) -> f a -> f b
(a -> b) -> Either e a -> Either e b

-- пример
ghci> fmap (+3) $ Right 39
Right 42
ghci> fmap (+3) $ Left "oops"
Left "oops"

-- функтор для одно-параметрической функции, аналогично (но надо определиться с семантикой, что значит "поднять функцию в контекст функции)
ghci> :k (->)
(->) :: * -> * -> *

ghci> :k (->) Char
(->) Char :: * -> *

instance Functor ((->) inp) where
    fmap fn inpTo = (\ x -> fn (inpTo x))
    fmap f g = f . g -- то есть, сконструированная по сигнатуре функция это просто композиция
    fmap = (.)      -- (декорирование) контекста поднимаемой в контекст функцией
-- т.е. сначала нечто из связанного параметра маппится на входной параметр функции, потом выполняется функция на этом обработанном параметре
-- где-то здесь рядом ходит монада Read

-- выведем тип фмап
(a -> b) -> f a -> f b
(a -> b) -> (->) inp a -> (->) inp b
(a -> b) -> (inp -> a) -> (inp -> b)
-- на выходе нужно получить ф. из связанного входа в бэ

instance Functor ((->) e) where -- e это environment
    fmap :: (a -> b) -> (e -> a) -> (e -> b)
    fmap = (.)
-- поднимаем ф. a -> b в контекст, где из енва читается а; получаем функцию, где из енва читается бэ

-- пример, поднимем ф. length в контекст "получить-список-из-списка"
ghci> fmap length tail "abc"
2
-- эквивалентно композиции
ghci> length . tail $ "abc"
2

ghci> :t fmap length tail -- результатом должен быть функтор от стрелки (так и есть, функция из списка это функтор)
fmap length tail :: [a] -> Int

-- про наростание арности функции при использовании полиморфизма
fmap :: (a -> b) -> (e -> a) -> (e -> b) -- arity 2
fmap :: (a -> b) -> (e -> a) -> e -> b -- arity 3
-- парамушта внутрениий тип это стрелка, вот она и проявилась
```
repl

```hs
https://stepik.org/lesson/8432/step/8?unit=2743
TODO
```
test

### 5.1.9 functor laws

Чтобы функтор был функтором, должны выполняться два закона:
гарантия неизменности "структуры контейнера" или "отсутствия эффектов".
```hs
-- 1) fmap id x = id x
-- 2) fmap (f . g) x = (fmap f . fmap g) x

-- или, в pointfree стиле
-- 1) fmap id = id
-- 2) fmap (f . g) = (fmap f) . (fmap g) -- композиция лифтов заменяется на 1 лифт композиции функций, типа оптимизация

ghci> fmap (+1) . fmap (^2) $ [1,2,3]
[2,5,10]

ghci> fmap ((+1) . (^2)) $ [1,2,3]
[2,5,10]

-- пример реализации с нарушением законов
instance Functor [] where
    fmap _ [] = []
    fmap g (x:xs) = g x : g x : fmap g xs
-- на каждом применении fmap длина списка удваивается
```
repl

> Второй закон можно не проверять, он следует из первого.
Для функторов в общем виде это неверно, но в Haskell это работает из-за полиморфности Functor
https://www.schoolofhaskell.com/user/edwardk/snippets/fmap

## chapter 5.2, Определение монады

https://stepik.org/lesson/8437/step/1?unit=1572

- Стрелка Клейсли
- Класс типов Monad
- Оператор монадического связывания
- Полное определение класса Monad

### 5.2.2 Стрелка Клейсли, вычислительный контекст, вычисления с эффектами (монадические вычисления)

Присоединение к вычислениям полезных эффектов.

Говоря про контейнеры мы теперь будем иметь в виду вычислительные контексты, где, кроме вычисления результата функции,
возможны "эффекты", т.е. некое "дополнительное значение" как результат работы функции.
Или, как некий набор данных, сопровождающий вычисление чистых функций.
Или просто (не)мутабельный контекст вычисления функции.
Ввод-вывод, ошибки, конфигурация, стейт (состояние), ... это примеры контекстов.
```hs
f :: a -> b -- стрелочный тип, абстрактная функция из а в бэ, чистая математика

-- добавим ограничение: пусть бэ будет упаковано в одно-параметрический "контейнер"
-- тогда мы можем добавить некоторую семантику к таким функциям
f :: a -> Maybe b       -- возможен фейл, вычислительный эффект: вероятна ошибка и отсутствие значения бэ
f :: a -> [b]           -- возможно разное количество результатов: [0 ..] значений, семантика зависит от домена, не-детерминированные вычисления
f :: a -> (Either s) b  -- возможна типизированная ошибка: расширенный Maybe
f :: a -> (s, b)        -- возможна запись в лог
f :: a -> ((->) e) b    -- возможно чтение из окружения (конфигурации)
f :: a -> (State s) b   -- возможен мутабельный стейт
f :: a -> IO b          -- возможен выход во внешний мир, файлы (консоль, сеть, ...)

-- Этот подход к поддержке вычислений с эффектами можно обобщить, абстрагировать.
-- Монадическое вычисление.
-- Получившаяся абстаркция имеет название Стрелка Клейсли, где результат функции это
-- результат работы одно-параметрического конструктора (контейнера) над собственно значением
f :: a -> m b
-- Чтобы этим пользоваться, нам нужен интерфейс, API работы с монадическими вычислениями.
-- Входит Монада ...

f :: a -> m b -- Примеры:
f :: a -> Maybe b            -- m = Maybe
f :: a -> [] b               -- m = []
f :: a -> (Either s) b       -- m = Either s
f :: a -> ((,) s) b          -- m = ((,) s)
f :: a -> ((->) e) b         -- m = ((->) e)
f :: a -> (State s) b        -- m = State s
f :: a -> IO b               -- m = IO
```
repl

```hs
https://stepik.org/lesson/8437/step/3?unit=1572
TODO
```
test

### 5.2.4
https://stepik.org/lesson/8437/step/4?unit=1572
```hs

```
repl



Grep `TODO` markers, fix it. After that you're done.
