# FP Haskell, chapter 5, monads

[Функциональное программирование на языке Haskell / Денис Москвин / stepik](https://stepik.org/course/75/syllabus?next=)

Мотивация: абстракция и композиция вычислений с эффектами.
Мы хотим тотальные чистые функции и мы хотим модульность и композиционность (собирать сложные решения из простых компонент).
Для обработки эффектов придумали Стрелку Клейсли `a -> m a` и монады (композиция вычислений с контекстом).

definitions
- Functor: тайпкласс с методом `fmap :: (a -> b) -> f a -> f b`
поднимает ф. в контекст, оператор "применения" `<$>`. Структура "контейнера" не меняется.
Законы функтор: 1) `fmap id = id`; 2) `fmap (f . g) = (fmap f) . (fmap g)`

- Monad: тайпкласс с двумя методами
`return :: a -> m a` aka `pure` поднимает значение в монаду, позволяет любую стрелку сделать стрелкой Клейсли `k`.
`bind :: m a -> (a -> m b) -> m b` aka `>>=` оператор монадического связывания вычислений.
Законы монад: 1) левая "единица" pure `(return a) >>= k = k a`; 2) правая "единица" pure `m >>= return = m`; 3) ассоциативность bind `(m >>= k1) >>= k2 = m >>= (\ x -> k1 x >>= k2)`

> (Монад это) Моноид в категории эндофункторов (моноид это бинарная операция и нейтральный элемент, (эндо)функтор это стрелка в контексте).
Т.е. монада композирует (складывает) стрелки в контексте (а нейтраль какая?).

> мы используем термин "контейнер" в более широком ... смысле, и можно заменить его на более точный термин - "вычислительный контекст"
> правильней о функторах думать как о естественных конструкциях над типами. Контейнер -- это только пример естественной конструкции

## chapter 5.1, Класс типов (type-class) Functor и законы для него

https://stepik.org/lesson/8432/step/1?unit=2743

- Класс типов Functor
- Представитель класса типов Functor для бинарного дерева
- Представители Functor для двухпараметрических типов
- Законы для функторов

### 5.1.2 тайп-классы для конструкторов типов, Functor, fmap

Если тайп-класс для типа с кайндом `*` осознать довольно легко,
то тайп-класс для "конструктора типов", с кайндом `* -> *`
это абстракция более высокого порядка и задает API для (потенциально бесконечного) множества компонент, реализующих этот интерфейс.

Рассмотрим тайп-класс Functor
```hs
-- type-class, полностью полиморфный, без ограничений на типы (переменные типов) a, b, f
-- класс типов параметризован переменной (типа) `f`
class Functor f where
    -- "поднимает" функцию `a -> b` в "контекст" `f`: принимает `f a`, на выходе `f b`
    -- при этом контекст не меняется, нет "эффекта"
    fmap :: (a -> b) -> f a -> f b -- видно, что эф это конструктор типов, ибо "применяется" к а и к бе
-- переменная `f` используется как функция над типами, у нее должен быть "стрелочный кайнд": `* -> *`

-- реализация тайп-класса Функтор для списков: очевидная
instance Functor [] where
    fmap = map

ghci> map succ [1,2,3]
[2,3,4]
ghci> fmap succ [1,2,3]
[2,3,4]

ghci> :i fmap
type Functor :: (* -> *) -> Constraint
class Functor f where
  fmap :: (a -> b) -> f a -> f b -- Defined in ‘GHC.Base’

-- правая ассоциативность скобок для стрелочных типов, позволяет сказать:
-- fmap берет функцию над элементами и возвращает функцию над "контейнерами" элементов
(a -> b) -> f a -> f b -- эквивалентно
(a -> b) -> (f a -> f b)
-- demo
ghci> let fs = fmap succ
ghci> :t fs
fs :: (Functor f, Enum b) => f b -> f b
ghci> fs [1,2,3]
[2,3,4]

ghci> fs $ Just 42
Just 43
-- вы чувствуете мощь концепции тайпклассов? До тех пока тип реализует интерфейс, мы можем его использовать в большом наборе операций,
-- понятия не имеющих о конкретике контекста

instance Functor Maybe where -- два конструктора у Maybe, сигнатуры однозначно определяют реализацию
    -- (a -> b) -> f a -> f b
    fmap _ Nothing = Nothing
    fmap f (Just a) = Just (f a)
```
repl

```hs
https://stepik.org/lesson/8432/step/3?unit=2743
TODO
```
test

```hs
https://stepik.org/lesson/8432/step/4?unit=2743
TODO
```
test

### 5.1.5 Functor Tree

Пример: определим функтор для бинарного дерева
```hs
-- дерево: одно-параметрический тип, только такой можно сделать функтором
-- два конструктора (сумма): лист-со-значением, ветвление-со-значением-и-левой-правой-ветками
-- думается, правильнее было бы не Branch а Node
data Tree a = Leaf a | Branch (Tree a) a (Tree a)
    deriving Show
-- `Branch (Tree a) a (Tree a)` это конструктор данных, принимающий три значения левое-дерево, значение-в-узле, правое-дерево

instance Functor Tree where
    -- (a -> b) -> f a -> f b
    fmap fn (Leaf x) = Leaf $ fn x
    fmap fn (Branch left x right) = Branch (fmap fn left) (fn x) (fmap fn right)
-- рекурсивно проходим дерево, сигнатуры однозначно определяют реализацию

testTree = Branch (Leaf 2) 3 (Leaf 4)
ghci> fmap (^2) testTree -- поднимем возведение в квадрат в дерево
Branch (Leaf 4) 9 (Leaf 16)

-- важно: структура "контейнера" не меняется (нет "эффекта"?). Про законы функтора чуть позже ...

-- оператор - синоним fmap
(^2) `fmap` testTree
ghci> (^2) <$> testTree -- лево-ассоциативный, приоритет 4
Branch (Leaf 4) 9 (Leaf 16)

ghci> :i <$>
(<$>) :: Functor f => (a -> b) -> f a -> f b -- Defined in ‘Data.Functor’
infixl 4 <$>

-- левая ассоциативность "применения": +5 применяется к результату ^2
ghci> (+5) <$> (^2) <$> testTree
Branch (Leaf 9) 14 (Leaf 21)

42 <$ testTree -- что-то вроде `const`
Branch (Leaf 42) 42 (Leaf 42) -- сохраняется структура, значение заменяется на переданное
-- поднимает значение (не функцию) в контекст
ghci> :i <$
type Functor :: (* -> *) -> Constraint
class Functor f where
  ...
  (<$) :: a -> f b -> f a -- Defined in ‘GHC.Base’
infixl 4 <$
```
repl

```hs
https://stepik.org/lesson/8432/step/6?unit=2743
TODO
```
test

### 5.1.7 Функтор для двух-параметрических типов

Как быть с двух-параметрическими типами, вроде `Either` или `(,)` или `->`?
Мы не можем определить одно-параметрический функтор для кайнда `* -> * -> *`, конструктора типов с двумя параметрами.
Надо связать первый параметр
```hs
-- как это сделать для типа Пара (тип-произведение)
instance Functor ((,) s) where
    fmap fn (x, y) = (x, fn y) -- первый элемент пары не трогаем, ко второму применяем функцию
-- связываем первый параметр пары с переменной s, тогда работать функтор будет с вторым значением пары

-- вот так выглядит механика снижения арности у конструктора типов
ghci> :k (,) -- кайнд пары
(,) :: * -> * -> * -- это три звезды: два параметра
ghci> :k (,) Char -- свяжем первый параметр пары с типом Чар
(,) Char :: * -> * -- получим кайнд одно-параметрического конструктора типа

-- посмотрим на тип fmap
(a -> b) -> f a -> f b -- подставляем конструктор пары из определения функтора пары
(a -> b) -> (,) s a -> (,) s b -- перепишем префиксный стиль в инфиксном виде
(a -> b) -> (s, a) -> (s, b) -- вот такой результ. тип у fmap для пары со связанным первым параметром

-- пример
ghci> fmap succ (1, 'a')
(1,'b')

-- похожим образом для Either (тип-сумма)
instance Functor (Either e) where
    fmap _ (Left x) = Left x -- левую часть не трогаем, она связана
    fmap fn (Right x) = Right $ fn x -- работаем с правой частью

ghci> :k Either
Either :: * -> * -> *
ghci> :k Either Char
Either Char :: * -> *

-- тип fmap
(a -> b) -> f a -> f b
(a -> b) -> Either e a -> Either e b

-- пример
ghci> fmap (+3) $ Right 39
Right 42
ghci> fmap (+3) $ Left "oops"
Left "oops"

-- функтор для одно-параметрической функции, аналогично (но надо определиться с семантикой, что значит "поднять функцию в контекст функции)
ghci> :k (->)
(->) :: * -> * -> *

ghci> :k (->) Char
(->) Char :: * -> *

instance Functor ((->) inp) where
    fmap fn inpTo = (\ x -> fn (inpTo x))
    fmap f g = f . g -- то есть, сконструированная по сигнатуре функция это просто композиция
    fmap = (.)      -- (декорирование) контекста поднимаемой в контекст функцией
-- т.е. сначала нечто из связанного параметра маппится на входной параметр функции, потом выполняется функция на этом обработанном параметре
-- где-то здесь рядом ходит монада Read

-- выведем тип фмап
(a -> b) -> f a -> f b
(a -> b) -> (->) inp a -> (->) inp b
(a -> b) -> (inp -> a) -> (inp -> b)
-- на выходе нужно получить ф. из связанного входа в бэ

instance Functor ((->) e) where -- e это environment
    fmap :: (a -> b) -> (e -> a) -> (e -> b)
    fmap = (.)
-- поднимаем ф. a -> b в контекст, где из енва читается а; получаем функцию, где из енва читается бэ

-- пример, поднимем ф. length в контекст "получить-список-из-списка"
ghci> fmap length tail "abc"
2
-- эквивалентно композиции
ghci> length . tail $ "abc"
2

ghci> :t fmap length tail -- результатом должен быть функтор от стрелки (так и есть, функция из списка это функтор)
fmap length tail :: [a] -> Int

-- про наростание арности функции при использовании полиморфизма
fmap :: (a -> b) -> (e -> a) -> (e -> b) -- arity 2
fmap :: (a -> b) -> (e -> a) -> e -> b -- arity 3
-- парамушта внутрениий тип это стрелка, вот она и проявилась
```
repl

```hs
https://stepik.org/lesson/8432/step/8?unit=2743
TODO
```
test

### 5.1.9 functor laws

Чтобы функтор был функтором, должны выполняться два закона:
гарантия неизменности "структуры контейнера" или "отсутствия эффектов".
```hs
-- 1) fmap id x = id x
-- 2) fmap (f . g) x = (fmap f . fmap g) x

-- или, в pointfree стиле
-- 1) fmap id = id
-- 2) fmap (f . g) = (fmap f) . (fmap g) -- композиция лифтов заменяется на 1 лифт композиции функций, типа оптимизация

ghci> fmap (+1) . fmap (^2) $ [1,2,3]
[2,5,10]

ghci> fmap ((+1) . (^2)) $ [1,2,3]
[2,5,10]

-- пример реализации с нарушением законов
instance Functor [] where
    fmap _ [] = []
    fmap g (x:xs) = g x : g x : fmap g xs
-- на каждом применении fmap длина списка удваивается
```
repl

> Второй закон можно не проверять, он следует из первого.
Для функторов в общем виде это неверно, но в Haskell это работает из-за полиморфности Functor
https://www.schoolofhaskell.com/user/edwardk/snippets/fmap

## chapter 5.2, Определение монады

https://stepik.org/lesson/8437/step/1?unit=1572

- Стрелка Клейсли
- Класс типов Monad
- Оператор монадического связывания
- Полное определение класса Monad

### 5.2.2 Стрелка Клейсли, вычислительный контекст, вычисления с эффектами (монадические вычисления)

Присоединение к вычислениям полезных эффектов.

Говоря про контейнеры мы будем иметь в виду вычислительные контексты,
где, кроме вычисления результата функции,
возможны "эффекты", т.е. некое "дополнительное значение" (или said-effect) как результат работы функции.
Или, как некий набор данных, сопровождающий вычисление чистых функций.
Или просто (не)мутабельный контекст вычисления функции.
Примеры контекстов: ввод-вывод, ошибки, конфигурация, стейт (состояние), ...
```hs
-- мы знаем про фунцию, что она либо вычисляется, либо ломает программу (не сходится)
f :: a -> b -- стрелочный тип, абстрактная функция из а в бэ, чистая математика

-- добавим ограничение: пусть бэ будет упаковано в "одно-параметрический контейнер"
-- тогда мы можем добавить некоторую семантику к таким функциям
f :: a -> Maybe b       -- возможен фейл, вычислительный эффект: вероятна ошибка и отсутствие значения бэ
f :: a -> [b]           -- возможно разное количество результатов: [0 ..] значений, семантика зависит от домена, не-детерминированные вычисления
f :: a -> (Either s) b  -- возможна типизированная ошибка: расширенный Maybe
f :: a -> (s, b)        -- возможна запись в лог
f :: a -> ((->) e) b    -- возможно чтение из окружения (конфигурации, е это енвайронмент)
f :: a -> (State s) b   -- возможен мутабельный стейт
f :: a -> IO b          -- возможен выход во внешний мир, файлы (консоль, сеть, ...)

-- Этот подход к поддержке вычислений с эффектами можно обобщить, абстрагировать.
-- Монадическое вычисление.
-- Получившаяся абстаркция имеет название Стрелка Клейсли, где результат функции это
-- результат работы одно-параметрического конструктора (контейнера) над собственно значением
f :: a -> m b
-- Чтобы этим пользоваться, нам нужен интерфейс, API работы с монадическими вычислениями.
-- Входит Монада ...

f :: a -> m b -- Примеры монад:
f :: a -> Maybe b            -- m = Maybe
f :: a -> [] b               -- m = []
f :: a -> (Either s) b       -- m = Either s
f :: a -> ((,) s) b          -- m = ((,) s)
f :: a -> ((->) e) b         -- m = ((->) e)
f :: a -> (State s) b        -- m = State s
f :: a -> IO b               -- m = IO
```
repl

```hs
https://stepik.org/lesson/8437/step/3?unit=1572
TODO
```
test

### 5.2.4 тайпкласс Monad и его свойства

```hs
class Monad m where -- переменная эм это одно-параметрический (кайнд * -> *) конструктор типов
    return :: a -> m a -- одно-параметричность видно из сигнатур методов интерфейса
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind (flatMap in Scala)

-- ретурн: поднимает значение в монаду, тривиальным образом, что важно!
-- позволяет любую стрелку a -> b превратить в стрелку Клейсли

-- байнд: применяет стрелку-клейсли в контексте монады (поднимает стрелку в монаду)
-- байнд построен так, чтобы контекст не терялся в процессе выполнения операций

-- bind: лево-ассоциативный с низким приоритетом
ghci> :i >>=
type Monad :: (* -> *) -> Constraint
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b -- Defined in ‘GHC.Base’
infixl 1 >>=

-- позже рассмотрим законы для монад, законы определяют возможные реализации для разных типов контекста с разной семантикой

-- посмотрим на реализации return

-- вывод типов говорит нам, что на выходе будет некая монада содержащая булево значение
ghci> :t return True
return True :: Monad m => m Bool -- выражение полиморфно по "контейнеру"

-- укажем список как тип монады, получим результат ретурна для монады-списка
ghci> return True :: [] Bool
[True]

-- для опции ретурн работает вот так:
ghci> return True :: Maybe Bool
Just True

-- как с помощью return получить стрелку Клейсли
toKleisli :: (Monad m) => (a -> b) -> (a -> m b) -- на входе просто стрелка, на выходе уже Клейсли
toKleisli f = return . f -- результат работы a -> b заворачиваем в ретурн: композиция двух функций
-- toKleisli f = (\ x -> return (f x)) -- вот так это записывается в развернутом виде
-- альтернативная запись:
-- можно убрать правые скобки в сигнатуре (это эквивалентно, каррирование бесплатно)
toKleisli :: (Monad m) => (a -> b) -> a -> m b -- функция двух аргументов, возвращает монаду-бе
toKleisli f x = return (f x)
-- вот совсем пойнтфри вариант записи
toKleisli :: (Monad m) => (a -> b) -> a -> m b
toKleisli = (return .)

-- стрелка К. на выходе
ghci> :t toKleisli cos
toKleisli cos :: (Monad m, Floating b) => b -> m b

ghci> toKleisli cos 0 :: [Double] -- укажем тип монады список
[1.0]
ghci> toKleisli cos 0 :: Maybe Float -- тип монады опция
Just 1.0

-- ghci работает в контексте монады IO, поэтому вывод видно сразу в репл
ghci> toKleisli cos 0 :: IO Double
1.0
ghci> :t toKleisli cos 0 :: IO Double
toKleisli cos 0 :: IO Double :: IO Double
```
repl

```hs
https://stepik.org/lesson/8437/step/5?unit=1572
TODO
```
test

### 5.2.6 operator bind

Первый аргумент это монада-а, второй аргумент это стрелка Клейсли из-а-в-монаду-б.
Оператор монадического связывания нужен для связывания монадических вычислений (в цепочку).

```hs
class Monad m where -- переменная эм это одно-параметрический (кайнд * -> *) конструктор типов
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind
-- сигнатура байнда говорит нам о доступности контекста на каждом шаге обработки, через это
-- оператор обеспечивает выполнение эффекта при отображении м-а в -м-б.
-- т.е. байнд может менять структуру "контейнера"

-- bind: лево-ассоциативный с низким приоритетом
ghci> :i >>=
type Monad :: (* -> *) -> Constraint
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b -- Defined in ‘GHC.Base’
infixl 1 >>=

-- другие операторы применения функции, ($), (&)
ghci> :i $
($) :: (a -> b) -> a -> b       -- Defined in ‘GHC.Base’
infixr 0 $
-- право-ассоциативный и аргументы флипнуты (относительно байнд)

-- оператор амперсанд (евро) очень похож на монадический байнд
-- лево-ассоциативный и порядок аргументов такой же
ghci> import Data.Function
ghci> :i &
(&) :: a -> (a -> b) -> b       -- Defined in ‘Data.Function’
infixl 1 &

-- (+1 (*3 (+2 5)))
ghci> (+1) $ (*3) $ (+2) $ 5 -- function application
22

-- (((5 +2) *3) +1)
ghci> 5 & (+2) & (*3) & (+1) -- pipeline, left-to-right
22
-- монадический bind вот таким образом и работает, как пайплайн, слева-направо

-- сравним bind с fmap: порядок аргументов обратный (к bind), аналогичен оператору `$`
ghci> :i fmap
type Functor :: (* -> *) -> Constraint
class Functor f where
  fmap :: (a -> b) -> f a -> f b -- Defined in ‘GHC.Base’

-- вот теперь уже ближе к bind, но стрелочка не-Клейсли, поэтому цепочка эффектов прерывается
-- структура "контейнера" не меняется, но bind может менять структуру контейнера (для того и сделан)
ghci> :t flip fmap
flip fmap :: Functor f => f a -> (a -> b) -> f b

```
repl

```hs
https://stepik.org/lesson/8437/step/7?unit=1572
TODO
```
test

```hs
https://stepik.org/lesson/8437/step/8?unit=1572
TODO
```
test

### 5.2.9 дополнительные методы монад (`>> =<< <=<`, `fail`)

У дополнительных операторов есть дефолтная реализация, переписывать их необязательно
```hs
class Monad m where -- переменная эм это одно-параметрический (кайнд * -> *) конструктор типов
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind

-- "облегченная версия" байнд, поднимает в первый аргумент вычисление-пустышку, возвращает второй аргумент
-- зачем так? чтобы продемонстрировать, что нас интересует только эффект (подробнее позже)
    (>>) :: m a -> m b -> m b
    mx >> my = mx >>= (\ _ -> my) -- связываем два монадических вычисления, второе-пустышка

-- дефолтная реализация прерывает программу, конкретная реализация монады может переопределить это поведение (Maybe, Either, ...)
    fail :: String -> m a
    fail s = error s

-- пайплайн развернут в обратную сторону (работает как $, справа-налево)
(=<<) :: Monad m => (a -> m b) -> m a -> m b
(=<<) = flip (>>=)

-- оператор `рыбка`, композиция стрелок Клейсли
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
f <=< g = (\ x -> g x) >>= f -- а-в-бэ и связываем с бэ-в-це, получаем а-в-це но в контексте монады
-- это композиция двух монадических вычислений, наподобие оператора `.`
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c -- можно записать более внятным способом
(<=<) f g x = (g x) >>= f -- эф и же это две стрелки Клейсли, выполняем же и заворачиваем в эф.

ghci> :i .
(.) :: (b -> c) -> (a -> b) -> a -> c   -- Defined in ‘GHC.Base’
infixr 9 .

```
test

## chapter 5.3, Монада Identity

https://stepik.org/lesson/8438/step/1?unit=1573

- Identity как монада
- Первый и второй законы для монад
- Третий закон для монад
- От законов монад к императивному программированию
- do нотация

Разберем реализацию некоторых монад, начнем с Identity

### 5.3.2 Monad Identity

Самый простой контекст
```hs
class Monad m where -- переменная эм это одно-параметрический (кайнд * -> *) конструктор типов
    return :: a -> m a -- тривиальная стрелка Клейсли --  ‘return = pure’
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind

newtype Identity a = Identity { runIdentity :: a } -- (дезайн-тайм) конструктор типа = конструктор данных { метка-доступа-к-значению }
    deriving (Eq, Show) -- авто-вывод тайпклассов

-- Update lesson materials
instance Functor Identity where
  fmap  f (Identity x) = Identity (f x)
instance Applicative Identity where
  pure x = Identity x -- Monad return
  Identity f <*> Identity v = Identity (f v) 
-- End Of Update

instance Monad Identity where
    return x = Identity x -- однопараметрический конструктор, тривиальная стрелка Клейсли
    (Identity x) >>= k = k x -- никаких эффектов, прозрачное выполнение стрелки Клейсли
    -- вынуть значение из контекста, применить стрелку К., вернуть результат
    -- вынули через пат.мат, тривиально вернули результат применения стрелки К.

-- для изучения, примеров и иллюстраций: создадим не-тривиальную стрелку Клейсли
wrap'n'succ :: Integer -> Identity Integer
wrap'n'succ = Identity . succ

-- типично для монадических вычислений: вычисляем, потом вызываем геттер
-- с учетом ленивости тут намек на то, что в монаде реально вычисления происходят только в момент вызова `run...`
ghci> runIdentity $ wrap'n'succ 3
4

-- оператор bind: слева монада, справа стрелка Клейсли, результат: монада
ghci> runIdentity $ (wrap'n'succ 3) >>= wrap'n'succ 
5
-- связываем (bind) цепочку вычислений (монадических)
ghci> runIdentity $ (wrap'n'succ 3) >>= wrap'n'succ >>= wrap'n'succ 
6

-- без контекста (монады) это выглядит так
ghci> succ 3 & succ & succ
6
ghci> 3 & succ & succ & succ
6
-- форма вызова идентичная второму варианту без монад
ghci> runIdentity $ (return 3) >>= wrap'n'succ >>= wrap'n'succ >>= wrap'n'succ
6
-- обратите внимание, как `wrap'n'succ 3` был убран в пользу затаскивания стрелок в монаду, созданную в самом начале пайплайна
```
repl

Обратите внимание, как через оператор `bind` монады мы получаем "пайплайн" вычислений-в-контексте.

```hs
https://stepik.org/lesson/8438/step/3?unit=1573
TODO
```
test

### 5.3.4 первые два закона монад

Законы монад, первые два (из трех)
```hs
-- remember that
class Monad m where
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind
newtype Identity a = Identity { runIdentity :: a } deriving (Eq, Show)

instance Functor Identity where fmap  f (Identity x) = Identity (f x)
instance Applicative Identity where
  pure x = Identity x -- Monad return
  Identity f <*> Identity v = Identity (f v) 

instance Monad Identity where
    return = Identity
    (Identity x) >>= k = k x

wrap'n'succ :: Integer -> Identity Integer
wrap'n'succ = Identity . succ

-- мы запускали цепочку двумя разными способами
ghci> runIdentity $ (wrap'n'succ 3) >>= wrap'n'succ >>= wrap'n'succ
ghci> runIdentity $ (return 3) >>= wrap'n'succ >>= wrap'n'succ >>= wrap'n'succ
-- т.е. вот эти две формы эквивалентны
(return 3) >>= wrap'n'succ
wrap'n'succ 3
-- это иллюстрация к первому закону монад

-- первый закон (левый pure)
(return a) >>= k    =    k a
-- применение стрелки Клейсли к значению х эквивалентно применению оператора bind к этой стрелке К. и значению завернутому в return (pure)

-- иллюстрация ко второму закону
ghci> (wrap'n'succ 3) >>= return    -- Identity {runIdentity = 4}
ghci> (wrap'n'succ 3)               -- Identity {runIdentity = 4}
-- return это стрелка К., связав ее байндом с монадой мы не меняем ничего

-- второй закон (правый pure)
m >>= return    =    m

-- первый и второй законы отражают "тривиальную" природу оператора `return`
-- он не выполняет эффектов и не меняет значение

-- extra
-- язык, в котором законы монад выглядят как законы моноидов, оперирует композицией стрелок Клейсли
return :: (Monad m) => a -> m a
f :: (Monad m) => a -> m b
g :: (Monad m) => b -> m c
h :: (Monad m) => c -> m d
(>=>) :: (Monad m) => (a -> m b) -> (b -> m c) -> (a -> m c)

-- Левая единица
return >=> f    === f
-- Правая единица
f >=> return    === f
-- Ассоциативность
f >=> (g >=> h) === (f >=> g) >=> h

```
repl

Похоже на законы для моноида (правая и левая единица).
Т.е. (в категории эндофункторов) bind это бинарная операция, return это нейтральное значеие (единица).

### 5.3.5 третий закон монад, ассоциативность

Третий закон должен постулировать ассоциативность (как у моноид).
Как бы да, но реализуется это через фокус с добавлением лямбды (ленивости) и честной ассоциативности тут нет
```hs
-- remember that
-- (a -> m b) это Стрелка Клейсли
class Monad m where
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind
-- первый закон (левый pure)
(return a) >>= k    =    k a
-- второй закон (правый pure)
m >>= return    =    m

-- думаете так?:
(m >>= k) >>= k'  =   m >>= (k >>= k')
-- нет, не так. По типам нет соответствия
-- левая часть рабоатает, правая часть не работает, (монада байнд монада) не соответствует сигнатуре байнд

-- хакнем чутка, добавим свободный х :: a
(m >>= k) >>= k'  =   m >>= ((\ x -> k x) >>= k')
-- (\ x -> k x) вот эта лямбда приводит к подгонке типов выражений под сигнатуру bind
-- ((\ x -> k x) >>= k') это стрелка Клейсли, которая по факту есть ленивый враппер над двумя внутренними стрелками.
-- мы лениво ждем в стрелке к, пока нам подадут на вход значение из монады м.
-- после этого можем запускать вычисление в стрелке к.
-- Так что это не "честная" ассоциативность, это фокус для имитации ассоциативности.

-- идея третьего закона:
-- мы можем лево-ассоциативные байнды заменить на право-ассоциативные,
-- но для этого мы должны завернуть стрелки К. в лямбды, ждущие значения из предыдущего шага пайплайна.

-- третий закон, ассоциативность bind (скобки опциональны, и без них корректно)
(m >>= k) >>= k'  =   m >>= (\ x -> k x >>= k')

-- иллюстрация
-- левая ассоциативность
ghci> runIdentity $ (wrap'n'succ 3) >>= wrap'n'succ >>= wrap'n'succ
6
ghci> runIdentity $ ((wrap'n'succ 3) >>= wrap'n'succ) >>= wrap'n'succ
6
-- правая ассоциативность
ghci> runIdentity $ (wrap'n'succ 3) >>= (\ x -> wrap'n'succ x >>= wrap'n'succ)
6

-- затравка к теме "do нотация", явное выражение параметров для каждой стрелки Клейсли
ghci> runIdentity $ (wrap'n'succ 3) >>= (\ x -> wrap'n'succ x >>= (\ y -> wrap'n'succ y))
6
```
repl

```hs
https://stepik.org/lesson/8438/step/6?unit=1573
TODO
```
test

```hs
https://stepik.org/lesson/8438/step/7?unit=1573
TODO
```
test

```hs
https://stepik.org/lesson/8438/step/8?unit=1573
TODO
```
test

### 5.3.9 подходим к do-нотации

Упражнения с цепочками монадический вычислений
```hs
-- reference
class Monad m where
    return :: a -> m a -- pure
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind
-- первый закон (левый pure)
(return a) >>= k    =    k a
-- второй закон (правый pure)
m >>= return    =    m
-- ассоциативность bind
(m >>= k1) >>= k2 = m >>= (\ x -> k1 x >>= k2)

-- сделаем небольшой массаж нашему выражению
runIdentity $ (wrap'n'succ 3) >>= wrap'n'succ >>= wrap'n'succ

goWrap0 = 
    wrap'n'succ 3 >>=
    wrap'n'succ >>=
    wrap'n'succ >>=
    return -- по второму закону этот ретурн ничего не меняет

ghci> :t goWrap0 
goWrap0 :: Identity Integer
ghci> goWrap0
Identity {runIdentity = 6}
ghci> runIdentity goWrap0 
6

-- перепишем по третьему закону, сменим ассоциативность на правую (на самом деле введем в скоуп переменные x,y,z)
-- x,y,z это значения вынутые из монадических оберток
goWrap1 = 
    wrap'n'succ 3   >>= (\ x ->
    wrap'n'succ x   >>= (\ y ->
    wrap'n'succ y   >>= (\ z ->
    return      z)))

ghci> :t goWrap1 
goWrap1 :: Identity Integer
ghci> goWrap1
Identity {runIdentity = 6}
ghci> runIdentity goWrap1
6

-- иллюстрация скоупа переменных
goWrap2 = 
    wrap'n'succ 3   >>= (\ x ->
    wrap'n'succ x   >>= (\ y ->
    wrap'n'succ y   >>= (\ z ->
    return (x, y, z)    )))

ghci> :t goWrap2
goWrap2 :: Identity (Integer, Integer, Integer)
ghci> goWrap2
Identity {runIdentity = (4,5,6)}
ghci> runIdentity goWrap2
(4,5,6)

-- ой, мы изобрели императивное кодирование, смотрите:
wrap'n'succ 3   >>= (\ x ->     -- x = succ 3;
wrap'n'succ x   >>= (\ y ->     -- y = succ x;
wrap'n'succ y   >>= (\ z ->     -- z = succ y;
return (x, y, z)    )))         -- return (x, y, z)
-- оператор байнд можно рассматривать как оператор `;` из императивных языков
-- здесь мы нагружаем оператор `;` таким смыслом: этот оператор выполняет те эффекты, для которых данная монада создана.
-- т.е. в хаскель мы сами определяем семантику оператора `;` (в отличие от не ФП языков)

goWrap3 = 
    wrap'n'succ 3   >>= (\ x ->
    wrap'n'succ x   >>= (\ y ->
    wrap'n'succ y   >>          -- облегченный bind, игнорирует результат `succ y`, хотя и выполняет его
    return (x + y)      ))
-- облегченный байнд нужен для протаскивания эффектов по цепочке, когда значение вычисления не требуется (ф. возвращает юнит)
ghci> :t (>>)
(>>) :: Prelude.Monad m => m a -> m b -> m b
```
repl

### 5.3.10 do-нотация

Синтаксический сахар для цепочки монадических вычислений
```hs
-- reference
import Prelude hiding (Monad, (>>=), (>>), return)
class Monad m where
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind
    (>>) :: m a -> m b -> m b
    mx >> my = mx >>= (\ _ -> my) -- облегченный bind, выполняет эффект но игнорирует значение
newtype Identity a = Identity { runIdentity :: a } deriving (Eq, Show)
instance Functor Identity where fmap  f (Identity x) = Identity (f x)
instance Applicative Identity where
  pure = Identity -- Monad return
  Identity f <*> Identity v = Identity (f v) 
instance Monad Identity where
    return = Identity
    (Identity x) >>= k = k x
wrap'n'succ :: Integer -> Identity Integer
wrap'n'succ = Identity . succ
-- End Of Reference

-- правила трансляции сахара в монадические цепочки
do { e1; e2 } = e1 >> e2 -- облегченный байнд
do { p <- e1; e2 } = e1 >>= \ p -> e2 -- байнд со связыванием значения из первого маонадического выражения
do { let v = e1; e2 } = let v = e1 in do e2 -- не-монадические вычисления `v = e1` внутри ду-блока

-- правило немного сложнее чем это
do { p <- e1; e2 } = e1 >>= \ p -> e2
-- тут в лямбде возможно применение пат.мат. и пат.мат. может быть неудачен
do { (Just p) <- e1; e2 } = e1 >>= \ (Just p) -> e2
-- тогда в монаде будет вызван метод `fail`
-- этот метод `fail` в каждой монаде реализован по-совему.

-- пример
goWrap4 =
    let i = 3 in
    wrap'n'succ i   >>= \ x ->
    wrap'n'succ x   >>= \ y ->
    wrap'n'succ y   >>
    return          (i, x + y)

import Control.Monad.Identity
goWrap5 = do
    let i = 3
    x <- wrap'n'succ i
    y <- wrap'n'succ x
    wrap'n'succ y
    return (i, x + y)

ghci> goWrap4
Identity {runIdentity = (3,9)}
ghci> :t goWrap4
goWrap4 :: Num a => Identity (a, Integer)

ghci> goWrap5 
Identity (3,9)
ghci> :t goWrap5 
goWrap5 :: Identity (Integer, Integer) -- тип контейнера один для всего блока do. типы значений могут быть разные

-- надо понимать, что оператор bind требует одинаковых типов (монад) слева и справа,
-- поэтому мы не можем внутри одного блока do оперировать разными монадами, по типам не будет сочетаться
-- каждые две строчки это левый и правый операнды для bind (с учетом лямбды)

```
repl

## chapter 5.4, Список и Maybe как монады

https://stepik.org/lesson/8439/step/1?unit=1574

- Монада Maybe
- Пример использования монады Maybe
- Монада списка
- Условные вычисления в монадах

### 5.4.2 Monad Maybe

Maybe: Эффект вычисления с возможной ошибкой, незавершающееся вычисление, опциональный результат.
Семантика: если ошибки нет, то поведение как у Identity;
если сломалось вычисление, то остаток пайплайна не выполняется.
```hs
-- reminder, for reference
class Monad m where
    return :: a -> m a -- pure
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind
    (>>) :: m a -> m b -> m b -- облегченный bind, выполняет эффект левого операнда но игнорирует значение
    mx >> my = mx >>= (\ _ -> my)
    fail :: String -> m a

data Maybe a = Nothing | Just a -- одно-параметрический тип, с двумя конструкторами (сумма)
    deriving (Show, Eq, Ord)

instance Monad Maybe where
    -- pure
    return = Just -- тривиальная упаковка значения в монаду
    -- bind
    Nothing  >>= _ = Nothing -- bind с уже выстрелившим эффектом
    (Just x) >>= k = k x -- happy path
    -- light bind
    Nothing  >> _ = Nothing
    (Just _) >> m = m
    -- облом
    fail _ = Nothing -- на тот случай, если внутри монады вычисление сломалось
    -- например, при упавшем пат.мат. в поднятой лямбде

-- сопоставление с образцом транслируется в case of, который имеет fail

```
repl

### 5.4.3 Использование монад Maybe

Будем имитировать базу данных
```hs
import Data.Maybe (fromMaybe)
import Text.Printf (printf)

type Name = String
type DataBase = [(Name, Name)] -- ассоциативный список child -> parent

fathers, mothers :: DataBase 
fathers = [ ("Bill", "John")
          , ("Ann", "John")
          , ("John", "Peter")] 
mothers = [ ("Bill", "Jane")
          , ("Ann", "Jane")
          , ("John", "Alice")
          , ("Jane", "Dorothy")
          , ("Alice", "Mary")]

-- стрелки Клейсли, достать маму, достать папу
getM, getF :: Name -> Maybe Name
getM person = lookup person mothers
getF person = lookup person fathers

ghci> :i lookup 
lookup :: Eq a => a -> [(a, b)] -> Maybe b -- Defined in ‘GHC.List’

-- папа билла, мама папы билла, мама мамы папы билла
getF "Bill" >>= getM >>= getM -- три стрелки К, связанные в монаде Maybe
do { fb <- getF "Bill"; mfb <- getM fb; mmfb <- getM mfb; return mmfb }
do { fb <- getF "Bill"; mfb <- getM fb; getM mfb } -- последняя операция это `>> 	then, sequence`

-- поиск бабушек (бабушка по маме, бабушка по папе)
granmas :: Name -> Maybe (Name, Name)
granmas person = do
  m   <- getM person
  gmm <- getM m
  f   <- getF person
  gmf <- getM f
  return (gmm, gmf)

ghci> granmas "Ann"
Just ("Dorothy","Alice")

-- одна бабушка есть в БД, но кумулятивный результат пустой, одна цепочка в рамках одного Maybe только так работает
ghci> granmas "John"
Nothing

-- как видно, программа пишется как бы без учета эффектов, эффекты за кадром.
-- К тому же, благодаря общему интерфейсу монад, такие вычисления композибельны

-- extra
main :: IO ()
main = do
  print $ getF "Bill" >>= getM >>= getM
  let (gmmA, gmfA) = fromMaybe ("NA","NA") (granmas "Ann")
      (gmmJ, gmfJ) = fromMaybe ("NA","NA") (granmas "John")
  printf "Ann's mothers mother: %s, fathers mother: %s\n" gmmA gmfA
  printf "John's mothers mother: %s, fathers mother: %s\n" gmmJ gmfJ
```
repl

```hs
https://stepik.org/lesson/8439/step/4?unit=1574
TODO
```
test

### 5.4.5 Монад списка

Сложная (удивительная) монада.
Эффект: у вычисления много значений,
цепочка расходится по результатам предыдущего шага. Дерево вычислений, конкатенируется в конце в список.
Недетерминированное вычисление.
У списка эффект это структура списка (количество элементов).
```hs
class Monad m where
    return :: a -> m a -- pure
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind
    (>>) :: m a -> m b -> m b -- `>> 	then, sequence`, выполняет эффект левого операнда но игнорирует его значение
    fail :: String -> m a

-- работа pure списка: упаковка значения в список
ghci> return 4 :: [Int]
[4]

-- работа bind списка: для каждого элемента слева выполняется операция справа (вложенные циклы)
ghci> [1,2] >>= (\ x -> [x,x,x])
[1,1,1, 2,2,2]

-- результатов вычисления нет, эффект пустого списка результатов, аналог Nothing
ghci> [1,2] >>= (\ x -> [])
[]
-- с точки зрения дерева вычислений: пустой список дает "засохшую" ветку, от которой ничего уже не вырастет
ghci> [1,2] >>= (\ x -> []) >>= (\ y -> [y,y])
[]

-- применим стрелку К. к каждому элементу списка
ghci> map (\ x -> [x,x,x]) [1,2]
[[1,1,1],[2,2,2]]
-- структура контейнера не изменилась (а должна)

-- вот это ожидаемое поведение bind
ghci> concat $ map (\ x -> [x,x,x]) [1,2]
[1,1,1,2,2,2]

instance Monad [] where
    return x = [x]
    xs >>= k = concat (map k xs)
    fail _ = [] -- как у Maybe, ветка сломалась, в конкатенацию вклада не будет

-- иллюстрация связи монады списка и list comprehension
ghci> [(x, y) | x <- [1,2,3], y <- [4,5,6]] -- правый цикл - внутренний
[(1,4),(1,5),(1,6), (2,4),(2,5),(2,6), (3,4),(3,5),(3,6)]
-- транслируется в
ghci> do { x <- [1,2,3]; y <- [4,5,6]; return (x,y) }
[(1,4),(1,5),(1,6), (2,4),(2,5),(2,6), (3,4),(3,5),(3,6)]
-- транслируется в
ghci> [1,2,3] >>= (\ x -> [4,5,6] >>= (\ y -> return (x,y)))
[(1,4),(1,5),(1,6), (2,4),(2,5),(2,6), (3,4),(3,5),(3,6)]

-- extra
import Control.Monad (guard)
list = do
  x <- [1,2,3]
  y <- [2,3,4]
  guard $ x == y
  return (x, y)

```
repl

```hs
https://stepik.org/lesson/8439/step/6?unit=1574
TODO
```
test

### 5.4.7 ветвления по условию в монадической цепочке

```hs
-- без условия
ghci> [(x, y) | x <- [1,2,3], y <- [1,2]]
[(1,1),(1,2), (2,1),(2,2), (3,1),(3,2)]
-- с условием
ghci> [(x, y) | x <- [1,2,3], y <- [1,2], x /= y]
[(1,2), (2,1), (3,1),(3,2)]
-- пропали (1,1) (2,2)

do
    x <- [1,2,3]
    y <- [1,2]
    return (x,y)
    True <- return (x /= y) -- упаковка условия в монаду и распаковка результата в пат.мат.
    -- пат.мат. в левой части замаскированной лямбды,
    -- неуспешный пат.мат. дергает fail и он дает пустой список для данной пары
    -- пустой список "убиват" эту ветку дерева вычислений
    return (x, y)
-- т.е. здесь мы наблюдаем проявление эффекта монады списка, эффект влияет на результат

-- под капотом это как-то так будет
[1,2,3]         >>= (\ x ->
[1,2]           >>= (\ y ->
return (x /= y) >>= (\ b ->
case b of True -> return (x,y)
          _    -> fail "..." )))

-- иногда удобнее выразить условие через if then else
do
    x <- [1,2,3]
    y <- [1,2]
    if x /= y then [42] else [] -- тут работает `>> then aka sequence`, IMHO
    -- значение игнорируется, структура (эффект, список из одного элемента) используется downstream
    return (x, y)
```
repl

```hs
https://stepik.org/lesson/8439/step/8?unit=1574
TODO
```
test

## chapter 5.5, Монада IO

https://stepik.org/lesson/8443/step/1?unit=1578

- Ввод-вывод
- Тип IO
- Монада IO
- Устройство getLine и putStr
- Полезные вспомогательные функции

### 5.5.2 IO, Monad

В Хаскел ввод-вывод реализован через монаду IO, эффекты этой монады и есть IO
```hs
module Main where
main = do
    putStrLn "What's your nme?" -- >> aka then aka sequence
    name <- getLine
    putStrLn $ "Nice to meet you, " ++ name ++ "!"

ghci> :t main
main :: IO () -- IO unit
-- IO это монада над типом "юнит"

-- юнит можно рассматривать как пустой тупл, маркер того, что значение нас не интересует
ghci> :t ()
() :: ()
ghci> :k ()
() :: *

-- на выходе main у нас тип последней операции пайплайна
ghci> :t putStrLn 
putStrLn :: String -> IO () -- стрелка Клейсли

ghci> :t getLine 
getLine :: IO String -- строка завернутая в монаду IO

```
repl

> любое монадическое значение можно интерпретировать как (вырожденную) стрелку Клейсли

```hs
https://stepik.org/lesson/8443/step/3?unit=1578
TODO
```
test

### 5.5.4 newtype IO

А почему непременно монада IO? Почему не обычные функции?
```hs
-- по законам ФП это должна быть константа, но с консоли мы можем получить любой символ (прерывание программы Ctrl-C)
getCharFromConsole :: Char

-- вот так уже похоже на правду, значение полученного символа определяет "окружение", state, енв., мир, контекст, whatchamacallit
getCharFromConsole :: RealWorld -> (RealWorld, Char)

-- можно считать, что реализация монады айо опирается на та такой тип
newtype IO a = IO (RealWorld -> (RealWorld, a))
-- где RealWorld это 
-- RealWorld is deeply magical

-- на самом деле, про айо мы гарантированно знаем его кайнд
ghci> :k IO
IO :: * -> * -- что позволяет сделать его монадой
-- и интерфейс https://hackage.haskell.org/package/base-4.19.0.0/docs/GHC-IO.html#t:IO

-- There is really only one way to "perform" an I/O action: bind it to Main.main in your program
```
repl

### 5.5.5

https://stepik.org/lesson/8443/step/5?unit=1578

```hs

```
repl

Grep `TODO` markers, fix it. After that you're done.
