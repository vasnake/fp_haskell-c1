# FP Haskell, chapter 5, monads

[Функциональное программирование на языке Haskell / Денис Москвин / stepik](https://stepik.org/course/75/syllabus?next=)

definitions
- Functor: `fmap :: (a -> b) -> f a -> f b` поднимает ф. в контекст, оператор "применения" `<$>`. Структура "контейнера" не меняется.
Законы функтора: 1) `fmap id = id`; 2) `fmap (f . g) = (fmap f) . (fmap g)`

- Monad: `return :: a -> m a` поднимает значение в монаду, позволяет любую стрелку сделать стрелкой Клейсли.
`bind :: m a -> (a -> m b) -> m b` оператор монадического связывания вычислений, оператор `>>=`.

> (Монад это) Моноид в категории эндофункторов (моноид это бинарная операция и нейтральный элемент, (эндо)функтор это стрелка в контексте).
Т.е. монада композирует (складывает) стрелки в контексте (а нейтраль какая?).

> мы используем термин "контейнер" в более широком ... смысле, и можно заменить его на более точный термин - "вычислительный контекст"
> правильней о функторах думать как о естественных конструкциях над типами. Контейнер -- это только пример естественной конструкции

## chapter 5.1, Класс типов (type-class) Functor и законы для него

https://stepik.org/lesson/8432/step/1?unit=2743

- Класс типов Functor
- Представитель класса типов Functor для бинарного дерева
- Представители Functor для двухпараметрических типов
- Законы для функторов

### 5.1.2 тайп-классы для конструкторов типов, Functor, fmap

Если тайп-класс для типа с кайндом `*` осознать довольно легко,
то тайп-класс для "конструктора типов", с кайндом `* -> *`
это абстракция более высокого порядка и задает API для (потенциально бесконечного) множества компонент, реализующих этот интерфейс.

Рассмотрим тайп-класс Functor
```hs
-- type-class, полностью полиморфный, без ограничений на типы (переменные типов) a, b, f
-- класс типов параметризован переменной (типа) `f`
class Functor f where
    -- "поднимает" функцию `a -> b` в "контекст" `f`: принимает `f a`, на выходе `f b`
    -- при этом контекст не меняется, нет "эффекта"
    fmap :: (a -> b) -> f a -> f b -- видно, что эф это конструктор типов, ибо "применяется" к а и к бе
-- переменная `f` используется как функция над типами, у нее должен быть "стрелочный кайнд": `* -> *`

-- реализация тайп-класса Функтор для списков: очевидная
instance Functor [] where
    fmap = map

ghci> map succ [1,2,3]
[2,3,4]
ghci> fmap succ [1,2,3]
[2,3,4]

ghci> :i fmap
type Functor :: (* -> *) -> Constraint
class Functor f where
  fmap :: (a -> b) -> f a -> f b -- Defined in ‘GHC.Base’

-- правая ассоциативность скобок для стрелочных типов, позволяет сказать:
-- fmap берет функцию над элементами и возвращает функцию над "контейнерами" элементов
(a -> b) -> f a -> f b -- эквивалентно
(a -> b) -> (f a -> f b)
-- demo
ghci> let fs = fmap succ
ghci> :t fs
fs :: (Functor f, Enum b) => f b -> f b
ghci> fs [1,2,3]
[2,3,4]

ghci> fs $ Just 42
Just 43
-- вы чувствуете мощь концепции тайпклассов? До тех пока тип реализует интерфейс, мы можем его использовать в большом наборе операций,
-- понятия не имеющих о конкретике контекста

instance Functor Maybe where -- два конструктора у Maybe, сигнатуры однозначно определяют реализацию
    -- (a -> b) -> f a -> f b
    fmap _ Nothing = Nothing
    fmap f (Just a) = Just (f a)
```
repl

```hs
https://stepik.org/lesson/8432/step/3?unit=2743
TODO
```
test

```hs
https://stepik.org/lesson/8432/step/4?unit=2743
TODO
```
test

### 5.1.5 Functor Tree

Пример: определим функтор для бинарного дерева
```hs
-- дерево: одно-параметрический тип, только такой можно сделать функтором
-- два конструктора (сумма): лист-со-значением, ветвление-со-значением-и-левой-правой-ветками
-- думается, правильнее было бы не Branch а Node
data Tree a = Leaf a | Branch (Tree a) a (Tree a)
    deriving Show
-- `Branch (Tree a) a (Tree a)` это конструктор данных, принимающий три значения левое-дерево, значение-в-узле, правое-дерево

instance Functor Tree where
    -- (a -> b) -> f a -> f b
    fmap fn (Leaf x) = Leaf $ fn x
    fmap fn (Branch left x right) = Branch (fmap fn left) (fn x) (fmap fn right)
-- рекурсивно проходим дерево, сигнатуры однозначно определяют реализацию

testTree = Branch (Leaf 2) 3 (Leaf 4)
ghci> fmap (^2) testTree -- поднимем возведение в квадрат в дерево
Branch (Leaf 4) 9 (Leaf 16)

-- важно: структура "контейнера" не меняется (нет "эффекта"?). Про законы функтора чуть позже ...

-- оператор - синоним fmap
(^2) `fmap` testTree
ghci> (^2) <$> testTree -- лево-ассоциативный, приоритет 4
Branch (Leaf 4) 9 (Leaf 16)

ghci> :i <$>
(<$>) :: Functor f => (a -> b) -> f a -> f b -- Defined in ‘Data.Functor’
infixl 4 <$>

-- левая ассоциативность "применения": +5 применяется к результату ^2
ghci> (+5) <$> (^2) <$> testTree
Branch (Leaf 9) 14 (Leaf 21)

42 <$ testTree -- что-то вроде `const`
Branch (Leaf 42) 42 (Leaf 42) -- сохраняется структура, значение заменяется на переданное
-- поднимает значение (не функцию) в контекст
ghci> :i <$
type Functor :: (* -> *) -> Constraint
class Functor f where
  ...
  (<$) :: a -> f b -> f a -- Defined in ‘GHC.Base’
infixl 4 <$
```
repl

```hs
https://stepik.org/lesson/8432/step/6?unit=2743
TODO
```
test

### 5.1.7 Функтор для двух-параметрических типов

Как быть с двух-параметрическими типами, вроде `Either` или `(,)` или `->`?
Мы не можем определить одно-параметрический функтор для кайнда `* -> * -> *`, конструктора типов с двумя параметрами.
Надо связать первый параметр
```hs
-- как это сделать для типа Пара (тип-произведение)
instance Functor ((,) s) where
    fmap fn (x, y) = (x, fn y) -- первый элемент пары не трогаем, ко второму применяем функцию
-- связываем первый параметр пары с переменной s, тогда работать функтор будет с вторым значением пары

-- вот так выглядит механика снижения арности у конструктора типов
ghci> :k (,) -- кайнд пары
(,) :: * -> * -> * -- это три звезды: два параметра
ghci> :k (,) Char -- свяжем первый параметр пары с типом Чар
(,) Char :: * -> * -- получим кайнд одно-параметрического конструктора типа

-- посмотрим на тип fmap
(a -> b) -> f a -> f b -- подставляем конструктор пары из определения функтора пары
(a -> b) -> (,) s a -> (,) s b -- перепишем префиксный стиль в инфиксном виде
(a -> b) -> (s, a) -> (s, b) -- вот такой результ. тип у fmap для пары со связанным первым параметром

-- пример
ghci> fmap succ (1, 'a')
(1,'b')

-- похожим образом для Either (тип-сумма)
instance Functor (Either e) where
    fmap _ (Left x) = Left x -- левую часть не трогаем, она связана
    fmap fn (Right x) = Right $ fn x -- работаем с правой частью

ghci> :k Either
Either :: * -> * -> *
ghci> :k Either Char
Either Char :: * -> *

-- тип fmap
(a -> b) -> f a -> f b
(a -> b) -> Either e a -> Either e b

-- пример
ghci> fmap (+3) $ Right 39
Right 42
ghci> fmap (+3) $ Left "oops"
Left "oops"

-- функтор для одно-параметрической функции, аналогично (но надо определиться с семантикой, что значит "поднять функцию в контекст функции)
ghci> :k (->)
(->) :: * -> * -> *

ghci> :k (->) Char
(->) Char :: * -> *

instance Functor ((->) inp) where
    fmap fn inpTo = (\ x -> fn (inpTo x))
    fmap f g = f . g -- то есть, сконструированная по сигнатуре функция это просто композиция
    fmap = (.)      -- (декорирование) контекста поднимаемой в контекст функцией
-- т.е. сначала нечто из связанного параметра маппится на входной параметр функции, потом выполняется функция на этом обработанном параметре
-- где-то здесь рядом ходит монада Read

-- выведем тип фмап
(a -> b) -> f a -> f b
(a -> b) -> (->) inp a -> (->) inp b
(a -> b) -> (inp -> a) -> (inp -> b)
-- на выходе нужно получить ф. из связанного входа в бэ

instance Functor ((->) e) where -- e это environment
    fmap :: (a -> b) -> (e -> a) -> (e -> b)
    fmap = (.)
-- поднимаем ф. a -> b в контекст, где из енва читается а; получаем функцию, где из енва читается бэ

-- пример, поднимем ф. length в контекст "получить-список-из-списка"
ghci> fmap length tail "abc"
2
-- эквивалентно композиции
ghci> length . tail $ "abc"
2

ghci> :t fmap length tail -- результатом должен быть функтор от стрелки (так и есть, функция из списка это функтор)
fmap length tail :: [a] -> Int

-- про наростание арности функции при использовании полиморфизма
fmap :: (a -> b) -> (e -> a) -> (e -> b) -- arity 2
fmap :: (a -> b) -> (e -> a) -> e -> b -- arity 3
-- парамушта внутрениий тип это стрелка, вот она и проявилась
```
repl

```hs
https://stepik.org/lesson/8432/step/8?unit=2743
TODO
```
test

### 5.1.9 functor laws

Чтобы функтор был функтором, должны выполняться два закона:
гарантия неизменности "структуры контейнера" или "отсутствия эффектов".
```hs
-- 1) fmap id x = id x
-- 2) fmap (f . g) x = (fmap f . fmap g) x

-- или, в pointfree стиле
-- 1) fmap id = id
-- 2) fmap (f . g) = (fmap f) . (fmap g) -- композиция лифтов заменяется на 1 лифт композиции функций, типа оптимизация

ghci> fmap (+1) . fmap (^2) $ [1,2,3]
[2,5,10]

ghci> fmap ((+1) . (^2)) $ [1,2,3]
[2,5,10]

-- пример реализации с нарушением законов
instance Functor [] where
    fmap _ [] = []
    fmap g (x:xs) = g x : g x : fmap g xs
-- на каждом применении fmap длина списка удваивается
```
repl

> Второй закон можно не проверять, он следует из первого.
Для функторов в общем виде это неверно, но в Haskell это работает из-за полиморфности Functor
https://www.schoolofhaskell.com/user/edwardk/snippets/fmap

## chapter 5.2, Определение монады

https://stepik.org/lesson/8437/step/1?unit=1572

- Стрелка Клейсли
- Класс типов Monad
- Оператор монадического связывания
- Полное определение класса Monad

### 5.2.2 Стрелка Клейсли, вычислительный контекст, вычисления с эффектами (монадические вычисления)

Присоединение к вычислениям полезных эффектов.

Говоря про контейнеры мы будем иметь в виду вычислительные контексты,
где, кроме вычисления результата функции,
возможны "эффекты", т.е. некое "дополнительное значение" (или said-effect) как результат работы функции.
Или, как некий набор данных, сопровождающий вычисление чистых функций.
Или просто (не)мутабельный контекст вычисления функции.
Примеры контекстов: ввод-вывод, ошибки, конфигурация, стейт (состояние), ...
```hs
-- мы знаем про фунцию, что она либо вычисляется, либо ломает программу (не сходится)
f :: a -> b -- стрелочный тип, абстрактная функция из а в бэ, чистая математика

-- добавим ограничение: пусть бэ будет упаковано в "одно-параметрический контейнер"
-- тогда мы можем добавить некоторую семантику к таким функциям
f :: a -> Maybe b       -- возможен фейл, вычислительный эффект: вероятна ошибка и отсутствие значения бэ
f :: a -> [b]           -- возможно разное количество результатов: [0 ..] значений, семантика зависит от домена, не-детерминированные вычисления
f :: a -> (Either s) b  -- возможна типизированная ошибка: расширенный Maybe
f :: a -> (s, b)        -- возможна запись в лог
f :: a -> ((->) e) b    -- возможно чтение из окружения (конфигурации, е это енвайронмент)
f :: a -> (State s) b   -- возможен мутабельный стейт
f :: a -> IO b          -- возможен выход во внешний мир, файлы (консоль, сеть, ...)

-- Этот подход к поддержке вычислений с эффектами можно обобщить, абстрагировать.
-- Монадическое вычисление.
-- Получившаяся абстаркция имеет название Стрелка Клейсли, где результат функции это
-- результат работы одно-параметрического конструктора (контейнера) над собственно значением
f :: a -> m b
-- Чтобы этим пользоваться, нам нужен интерфейс, API работы с монадическими вычислениями.
-- Входит Монада ...

f :: a -> m b -- Примеры монад:
f :: a -> Maybe b            -- m = Maybe
f :: a -> [] b               -- m = []
f :: a -> (Either s) b       -- m = Either s
f :: a -> ((,) s) b          -- m = ((,) s)
f :: a -> ((->) e) b         -- m = ((->) e)
f :: a -> (State s) b        -- m = State s
f :: a -> IO b               -- m = IO
```
repl

```hs
https://stepik.org/lesson/8437/step/3?unit=1572
TODO
```
test

### 5.2.4 тайпкласс Monad и его свойства

```hs
class Monad m where -- переменная эм это одно-параметрический (кайнд * -> *) конструктор типов
    return :: a -> m a -- одно-параметричность видно из сигнатур методов интерфейса
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind (flatMap in Scala)

-- ретурн: поднимает значение в монаду, тривиальным образом, что важно!
-- позволяет любую стрелку a -> b превратить в стрелку Клейсли

-- байнд: применяет стрелку-клейсли в контексте монады (поднимает стрелку в монаду)
-- байнд построен так, чтобы контекст не терялся в процессе выполнения операций

-- bind: лево-ассоциативный с низким приоритетом
ghci> :i >>=
type Monad :: (* -> *) -> Constraint
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b -- Defined in ‘GHC.Base’
infixl 1 >>=

-- позже рассмотрим законы для монад, законы определяют возможные реализации для разных типов контекста с разной семантикой

-- посмотрим на реализации return

-- вывод типов говорит нам, что на выходе будет некая монада содержащая булево значение
ghci> :t return True
return True :: Monad m => m Bool -- выражение полиморфно по "контейнеру"

-- укажем список как тип монады, получим результат ретурна для монады-списка
ghci> return True :: [] Bool
[True]

-- для опции ретурн работает вот так:
ghci> return True :: Maybe Bool
Just True

-- как с помощью return получить стрелку Клейсли
toKleisli :: (Monad m) => (a -> b) -> (a -> m b) -- на входе просто стрелка, на выходе уже Клейсли
toKleisli f = return . f -- результат работы a -> b заворачиваем в ретурн: композиция двух функций
-- toKleisli f = (\ x -> return (f x)) -- вот так это записывается в развернутом виде
-- альтернативная запись:
-- можно убрать правые скобки в сигнатуре (это эквивалентно, каррирование бесплатно)
toKleisli :: (Monad m) => (a -> b) -> a -> m b -- функция двух аргументов, возвращает монаду-бе
toKleisli f x = return (f x)
-- вот совсем пойнтфри вариант записи
toKleisli :: (Monad m) => (a -> b) -> a -> m b
toKleisli = (return .)

-- стрелка К. на выходе
ghci> :t toKleisli cos
toKleisli cos :: (Monad m, Floating b) => b -> m b

ghci> toKleisli cos 0 :: [Double] -- укажем тип монады список
[1.0]
ghci> toKleisli cos 0 :: Maybe Float -- тип монады опция
Just 1.0

-- ghci работает в контексте монады IO, поэтому вывод видно сразу в репл
ghci> toKleisli cos 0 :: IO Double
1.0
ghci> :t toKleisli cos 0 :: IO Double
toKleisli cos 0 :: IO Double :: IO Double
```
repl

```hs
https://stepik.org/lesson/8437/step/5?unit=1572
TODO
```
test

### 5.2.6 operator bind

Первый аргумент это монада-а, второй аргумент это стрелка Клейсли из-а-в-монаду-б.
Оператор монадического связывания нужен для связывания монадических вычислений (в цепочку).

```hs
class Monad m where -- переменная эм это одно-параметрический (кайнд * -> *) конструктор типов
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind
-- сигнатура байнда говорит нам о доступности контекста на каждом шаге обработки, через это
-- оператор обеспечивает выполнение эффекта при отображении м-а в -м-б.
-- т.е. байнд может менять структуру "контейнера"

-- bind: лево-ассоциативный с низким приоритетом
ghci> :i >>=
type Monad :: (* -> *) -> Constraint
class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b -- Defined in ‘GHC.Base’
infixl 1 >>=

-- другие операторы применения функции, ($), (&)
ghci> :i $
($) :: (a -> b) -> a -> b       -- Defined in ‘GHC.Base’
infixr 0 $
-- право-ассоциативный и аргументы флипнуты (относительно байнд)

-- оператор амперсанд (евро) очень похож на монадический байнд
-- лево-ассоциативный и порядок аргументов такой же
ghci> import Data.Function
ghci> :i &
(&) :: a -> (a -> b) -> b       -- Defined in ‘Data.Function’
infixl 1 &

-- (+1 (*3 (+2 5)))
ghci> (+1) $ (*3) $ (+2) $ 5 -- function application
22

-- (((5 +2) *3) +1)
ghci> 5 & (+2) & (*3) & (+1) -- pipeline, left-to-right
22
-- монадический bind вот таким образом и работает, как пайплайн, слева-направо

-- сравним bind с fmap: порядок аргументов обратный (к bind), аналогичен оператору `$`
ghci> :i fmap
type Functor :: (* -> *) -> Constraint
class Functor f where
  fmap :: (a -> b) -> f a -> f b -- Defined in ‘GHC.Base’

-- вот теперь уже ближе к bind, но стрелочка не-Клейсли, поэтому цепочка эффектов прерывается
-- структура "контейнера" не меняется, но bind может менять структуру контейнера (для того и сделан)
ghci> :t flip fmap
flip fmap :: Functor f => f a -> (a -> b) -> f b

```
repl

```hs
https://stepik.org/lesson/8437/step/7?unit=1572
TODO
```
test

```hs
https://stepik.org/lesson/8437/step/8?unit=1572
TODO
```
test

### 5.2.9 дополнительные методы монад (`>> =<< <=<`, `fail`)

У дополнительных операторов есть дефолтная реализация, переписывать их необязательно
```hs
class Monad m where -- переменная эм это одно-параметрический (кайнд * -> *) конструктор типов
    return :: a -> m a
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind

-- "облегченная версия" байнд, поднимает в первый аргумент вычисление-пустышку, возвращает второй аргумент
-- зачем так? чтобы продемонстрировать, что нас интересует только эффект (подробнее позже)
    (>>) :: m a -> m b -> m b
    mx >> my = mx >>= (\ _ -> my) -- связываем два монадических вычисления, второе-пустышка

-- дефолтная реализация прерывает программу, конкретная реализация монады может переопределить это поведение (Maybe, Either, ...)
    fail :: String -> m a
    fail s = error s

-- пайплайн развернут в обратную сторону (работает как $, справа-налево)
(=<<) :: Monad m => (a -> m b) -> m a -> m b
(=<<) = flip (>>=)

-- оператор `рыбка`, композиция стрелок Клейсли
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
f <=< g = (\ x -> g x) >>= f -- а-в-бэ и связываем с бэ-в-це, получаем а-в-це но в контексте монады
-- это композиция двух монадических вычислений, наподобие оператора `.`
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c -- можно записать более внятным способом
(<=<) f g x = (g x) >>= f -- эф и же это две стрелки Клейсли, выполняем же и заворачиваем в эф.

ghci> :i .
(.) :: (b -> c) -> (a -> b) -> a -> c   -- Defined in ‘GHC.Base’
infixr 9 .

```
test

## chapter 5.3, Монада Identity

https://stepik.org/lesson/8438/step/1?unit=1573

- Identity как монада
- Первый и второй законы для монад
- Третий закон для монад
- От законов монад к императивному программированию
- do нотация

Разберем реализацию некоторых монад, начнем с Identity

### 5.3.2 Monad Identity

Самый простой контекст
```hs
class Monad m where -- переменная эм это одно-параметрический (кайнд * -> *) конструктор типов
    return :: a -> m a -- тривиальная стрелка Клейсли --  ‘return = pure’
    (>>=) :: m a -> (a -> m b) -> m b -- оператор bind

newtype Identity a = Identity { runIdentity :: a } -- (дезайн-тайм) конструктор типа = конструктор данных { метка-доступа-к-значению }
    deriving (Eq, Show) -- авто-вывод тайпклассов

-- Update lesson materials
instance Functor Identity where
  fmap  f (Identity x) = Identity (f x)
instance Applicative Identity where
  pure x = Identity x -- Monad return
  Identity f <*> Identity v = Identity (f v) 
-- End Of Update

instance Monad Identity where
    return x = Identity x -- однопараметрический конструктор, тривиальная стрелка Клейсли
    (Identity x) >>= k = k x -- никаких эффектов, прозрачное выполнение стрелки Клейсли
    -- вынуть значение из контекста, применить стрелку К., вернуть результат
    -- вынули через пат.мат, тривиально вернули результат применения стрелки К.

-- для изучения, примеров и иллюстраций: создадим не-тривиальную стрелку Клейсли
wrap'n'succ :: Integer -> Identity Integer
wrap'n'succ = Identity . succ

-- типично для монадических вычислений: вычисляем, потом вызываем геттер
-- с учетом ленивости тут намек на то, что в монаде реально вычисления происходят только в момент вызова `run...`
ghci> runIdentity $ wrap'n'succ 3
4

-- оператор bind: слева монада, справа стрелка Клейсли, результат: монада
ghci> runIdentity $ (wrap'n'succ 3) >>= wrap'n'succ 
5
-- связываем (bind) цепочку вычислений (монадических)
ghci> runIdentity $ (wrap'n'succ 3) >>= wrap'n'succ >>= wrap'n'succ 
6

-- без контекста (монады) это выглядит так
ghci> succ 3 & succ & succ
6
ghci> 3 & succ & succ & succ
6
-- форма вызова идентичная второму варианту без монад
ghci> runIdentity $ (return 3) >>= wrap'n'succ >>= wrap'n'succ >>= wrap'n'succ
6
-- обратите внимание, как `wrap'n'succ 3` был убран в пользу затаскивания стрелок в монаду, созданную в самом начале пайплайна
```
repl

```hs
https://stepik.org/lesson/8438/step/3?unit=1573
TODO
```
test

### 5.3.4
https://stepik.org/lesson/8438/step/4?unit=1573
```hs

```
repl



Grep `TODO` markers, fix it. After that you're done.
